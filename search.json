[{"title":"[題解]城市旅遊","url":"/a051/","content":"a051. 城市旅遊\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 1000using namespace std;int n,m;bool visit[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    visit[cur] = 1;    for(auto i:edge[cur])&#123;        if(visit[i])continue;        dfs(i);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    for(int i=0;i&lt;=n+100;i++)edge[i].clear();        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);    &#125;    int from,to;cin&gt;&gt;from&gt;&gt;to;    dfs(from);    if(visit[to])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]秘密差","url":"/a065/","content":"a065. 秘密差\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        int ans = 0,len = s.size(),p=1;        for(int i=0;i&lt;len;i++)&#123;            ans+=(s[i]-&#x27;0&#x27;)*p;            p *=-1;        &#125;        cout&lt;&lt;abs(ans)&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]排隊買飲料","url":"/a071/","content":"a071. 排隊買飲料\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;&gt;&gt;pq;        cin&gt;&gt;n&gt;&gt;m;    int ans=0,time=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;time;        if(i&gt;m)&#123;            time+=pq.top();            pq.pop();        &#125;        pq.push(time);        ans = max(ans,time);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]ROT13","url":"/a067/","content":"a067. ROT13\n#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    string s;    getline(cin,s);    for(auto p:s)&#123;        if(isalpha(p))&#123;            if(isupper(p))                cout&lt;&lt;(char)((p-&#x27;A&#x27;+13)%26+&#x27;A&#x27;);            else                cout&lt;&lt;(char)((p-&#x27;a&#x27;+13)%26+&#x27;a&#x27;);        &#125;        else&#123;            cout&lt;&lt;p;        &#125;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]醜數","url":"/a075/","content":"a075. 醜數\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n;signed main()&#123;    Orz;    cin&gt;&gt;n;    vector&lt;int&gt; vec;    vec.push_back(1);    int id2 = 0,id3 = 0,id5 = 0;    //用前面的醜數推後面的，不會有其他質樹    for(int i=1;i&lt;n;i++)&#123;        int ugly = min(vec[id2]*2,min(vec[id3]*3,vec[id5]*5));        vec.push_back(ugly);        if(vec[i]==vec[id2]*2)id2+=1;        if(vec[i]==vec[id3]*3)id3+=1;        if(vec[i]==vec[id5]*5)id5+=1;    &#125;    cout&lt;&lt;vec[n-1]&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]Dropping Balls","url":"/a077/","content":"a077. Dropping Balls\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];int drop(int id)&#123;    if(id&gt;=(1&lt;&lt;(n-1)))return id;        tree[id]=!tree[id];    if(!tree[id])return drop(2*id+1);    else return drop(2*id);&#125;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        int ans = 0;cin&gt;&gt;n&gt;&gt;m;        memset(tree,0,sizeof(tree));        for(int i=0;i&lt;m;i++)&#123;            ans = drop(1);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]二元搜尋樹高度","url":"/a076/","content":"a076. 二元搜尋樹高度\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];bool used[3000];int main()&#123;    ios;    string s;    memset(used,0,sizeof(used));    memset(tree,0,sizeof(tree));        getline(cin,s);    stringstream ss(s);    int ans = 0,temp;    while(ss&gt;&gt;temp)&#123;        int cur = 1,height = 1;        while(used[cur])&#123;            if(temp&lt;tree[cur])cur = cur*2;            else cur = cur*2+1;            height++;        &#125;        tree[cur] = temp;        used[cur] = 1;        ans = max(ans,height);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]最大乘積","url":"/a088/","content":"a088. 最大乘積\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 20#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    int c = 0;    while(cin&gt;&gt;n)&#123;        c++;        int dp[N][N];memset(dp,0,sizeof(dp));        int ans = 0;        FOR(i,n)&#123;            int temp;cin&gt;&gt;temp;            dp[i][i] = temp;            ans = max(ans,temp);        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                dp[i][j] = dp[i][j-1]*dp[j][j];                ans = max(dp[i][j],ans);            &#125;        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;c&lt;&lt;&quot;: The maximum product is &quot;&lt;&lt;max(ans,(ll)0)&lt;&lt;&quot;.&quot;&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]Add All","url":"/a091/","content":"a091. Add All\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            pq.push(temp);        &#125;        int ans = 0;        while(pq.size()!=1)&#123;            int cur = pq.top();            pq.pop();            cur += pq.top();            pq.pop();            ans+=cur;            pq.push(cur);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]蘇丹王位繼承者","url":"/a089/","content":"a089. 蘇丹王位繼承者\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,chess[N][N],Q[N],ans=0;bool check(int row,int col)&#123;    for(int i=1;i&lt;row;i++)&#123;        if(col == Q[i]||abs(row-i)==abs(col-Q[i]))return 0;    &#125;    return 1;&#125;void Queen(int row)&#123;    if(row&gt;8)&#123;        int sum = 0;        rep(i,1,8)sum += chess[i][Q[i]];        ans = max(ans,sum);        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(row,i))&#123;            Q[row] = i;            Queen(row+1);        &#125;    &#125;&#125;void solve()&#123;    memset(chess,0,sizeof(chess));    memset(Q,0,sizeof(Q));    ans = 0;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            cin&gt;&gt;chess[i][j];        &#125;    &#125;    Queen(1);    cout&lt;&lt;right&lt;&lt;setw(5)&lt;&lt;ans&lt;&lt;endl;    &#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]質數環","url":"/a090/","content":"a090. 質數環\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 20#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,prime[105],ans[N],cnt = 0;bool visit[N];void init()&#123;    rep(i,0,100)prime[i] = 1;    prime[1] = 0;    for(int i=2;i&lt;=100;i++)&#123;        if(prime[i]==0)continue;        for(int j=2*i;j&lt;=100;j+=i)&#123;            prime[j] = 0;        &#125;    &#125;&#125;void dfs(int id,int val)&#123;    ans[id] = val;    if(id&gt;=n-1)&#123;        if(!prime[val+1])return;        for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;        return;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        if(visit[i])continue;        if(prime[val+i]==0)continue;        visit[i] = 1;        dfs(id+1,i);        visit[i] = 0;    &#125;&#125;signed main()&#123;    Orz;    init();    while(cin&gt;&gt;n)&#123;        cnt+=1;        memset(ans,0,sizeof(ans));        memset(visit,0,sizeof(visit));        cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt&lt;&lt;&quot;:&quot;&lt;&lt;endl;        dfs(0,1);    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]時間差計算","url":"/a096/","content":"a096/ 時間差計算\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    int a1,b1,c1,a2,b2,c2;    scanf(&quot;%d:%d:%d&quot;,&amp;a1,&amp;b1,&amp;c1);    scanf(&quot;%d:%d:%d&quot;,&amp;a2,&amp;b2,&amp;c2);    int a = a1*3600+b1*60+c1,b = a2*3600+b2*60+c2;        if(b-a&gt;=0)&#123;        int temp = b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;    else&#123;        int temp = 86400+b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]小群體","url":"/a103/","content":"a103. 小群體\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 50005using namespace std;signed main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];    &#125;    bool used[N];    int ans = 0;    memset(used,0,sizeof(used));        for(int i=0;i&lt;n;i++)&#123;        if(used[i])continue;        int cur = arr[i];        used[cur] = 1;        while(cur!=i)&#123;            cur = arr[cur];            used[cur] = 1;        &#125;        ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]雪花片片","url":"/a104/","content":"a104/ 雪花片片\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;int n,product[100];void solve()&#123;    memset(product,0,sizeof(product));    product[0] = 1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;80;j++)&#123;            product[j]=product[j]*4;        &#125;        for(int j=0;j&lt;80;j++)&#123;            if(product[j]&gt;=10)&#123;                product[j+1] += product[j]/10;                product[j] %=10;            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    product[0]-=1;    int temp=0;    for(int i=80;i&gt;=0;i--)&#123;        product[i] += temp*10;        temp = product[i]%3;        product[i] /= 3;    &#125;        int start = 80;    for(int i=80;i&gt;=0;i--)        if(product[i]!=0)&#123;            start = i;            break;        &#125;    for(int i=start;i&gt;=0;i--)cout&lt;&lt;product[i];    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]油田","url":"/a102/","content":"a102. 油田\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 105using namespace std;int n,m,ans = 0;int dx[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;;int dy[8] = &#123;1,0,-1,-1,-1,0,1,1&#125;;bool visit[N][N],maze[N][N];void dfs(int x,int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;8;i++)&#123;        int nx = x+dx[i],ny = y+dy[i];        if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;        if(visit[nx][ny])continue;        if(maze[nx][ny]==1)dfs(nx,ny);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    memset(maze,0,sizeof(maze));    ans = 0;        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;@&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                dfs(i,j);                ans+=1;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n&amp;&amp; m)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]賓果遊戲","url":"/a106/","content":"a106. 賓果遊戲\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;char name[N],line[N][10];pair&lt;int,int&gt; mp[N][N];bool check(int people,int number)&#123;    int r = mp[people][number].first,c = mp[people][number].second;    line[people][r]+=1;    line[people][c+4]+=1;    if(line[people][r]==4)return 1;    if(line[people][c+4]==4)return 1;        if(r+c==3)&#123;        line[people][8]+=1;        if(line[people][8]==4)return 1;    &#125;    if(r==c)&#123;        line[people][9]+=1;        if(line[people][9]==4)return 1;    &#125;    return 0;&#125;signed main()&#123;    ios;    int n;    char cha;    cin&gt;&gt;cha&gt;&gt;n;    memset(line,0,sizeof(line));        for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;name[i];        for(int j=0;j&lt;16;j++)&#123;            int temp;cin&gt;&gt;temp;            mp[i][temp].first = j/4;            mp[i][temp].second = j%4;        &#125;    &#125;    int cnt = 16,flag = 0;    cin&gt;&gt;cha;    while(cnt--)&#123;        int temp;cin&gt;&gt;temp;        cout&lt;&lt;temp&lt;&lt;&quot; &quot;;        for(int i=0;i&lt;n;i++)&#123;            if(check(i,temp))&#123;                cout&lt;&lt;name[i]&lt;&lt;&quot; &quot;;                flag = 1;            &#125;        &#125;        if(flag)break;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]爺爺種樹","url":"/a105/","content":"a105. 爺爺種樹\n#include &lt;bits/stdc++.h&gt;#define N 505#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n,m,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;    bool arr[N][N];    memset(arr,0,sizeof(arr));        while(t--)&#123;        int r1,r2,c1,c2;cin&gt;&gt;r1&gt;&gt;c1&gt;&gt;r2&gt;&gt;c2;        int dr = r2-r1,dc = c2-c1;        if(dr&gt;0)dr = 1;else dr = -1;        if(dc&gt;0)dc = 1;else dc = -1;                if(r1==r2)&#123;            for(int i=c1;i!=c2;i+=dc)arr[r1][i] = 1;            arr[r1][c2] = 1;        &#125;        else if(c1==c2)&#123;            for(int i=r1;i!=r2;i+=dr)arr[i][c1] = 1;            arr[r2][c1] = 1;        &#125;        else&#123;            for(int i=r1,j=c1;i!=r2;i+=dr,j+=dc)&#123;                arr[i][j] = 1;                arr[r2][c2] = 1;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(arr[i][j])ans+=1;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]成績指標","url":"/a064/","content":"a064/ 成績指標\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;void solve()&#123;    int n,arr[25];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    cout&lt;&lt;arr[0];    for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;arr[i];    cout&lt;&lt;endl;        if(arr[0]&gt;=60)cout&lt;&lt;&quot;best case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60)-1)&lt;&lt;endl;        if(arr[n-1]&lt;60)cout&lt;&lt;&quot;worst case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60))&lt;&lt;endl;    &#125;signed main()&#123;    int t;    t = 1;//    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]加密解密","url":"/a107/","content":"a107. 加密解密\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;string a = &quot;abcdefghijklmnoprstuvwxyz&quot;;string b = &quot;EXAMPLBCDFGHIJKNORSTUVWYZ&quot;;signed main()&#123;    ios;    int n;string s;    cin&gt;&gt;n;cin.ignore();    getline(cin,s);    reverse(s.begin(),s.end());    string origin = b ,key = a;    if(s[0]&gt;=&#x27;a&#x27;&amp;&amp; s[0]&lt;=&#x27;z&#x27;)swap(origin,key);        for(int i=0;i&lt;n;i+=2)&#123;        int p1 = origin.find(s[i]),p2 = origin.find(s[i+1]);        cout&lt;&lt;key[5*(p1/5)+(p2%5)]&lt;&lt;key[5*(p2/5)+(p1%5)];    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]計算字串間隔距離","url":"/a108/","content":"a108. 計算字串間隔距離\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//地點、動物名、數量int main()&#123;    string s;    char ch;    cin&gt;&gt;s&gt;&gt;ch;    ch = tolower(ch);    int len = s.size(),a1;    for(int i=0;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a1 = i;            break;        &#125;    &#125;    int a2;    for(int i=a1+1;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a2 = i;            cout&lt;&lt;a2-a1&lt;&lt;&quot; &quot;;            a1 = a2;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]跑長編碼與資料壓縮","url":"/a109/","content":"a109. 跑長編碼與資料壓縮\n#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    int n,origin,after,times;    string s,t,binary[8]=&#123;&quot;000&quot;,&quot;001&quot;,&quot;010&quot;,&quot;011&quot;,&quot;100&quot;,&quot;101&quot;,&quot;110&quot;,&quot;111&quot;&#125;;    char ch;    cin&gt;&gt;n;    cin.ignore();    while(n--)&#123;        getline(cin,s);        t=&quot;&quot;;        origin = s.size();        after = 0;        ch = s[0];        times = 1;        int len = s.size();        for(int i=1;i&lt;=len;i++)&#123;            if(i!=len &amp;&amp; s[i]!=&#x27;0&#x27;&amp;&amp;s[i]!=&#x27;1&#x27;)&#123;                after = -1;                break;            &#125;            if(s[i]!=ch)&#123;                t+=ch;                t+=binary[times];                t+=&quot; &quot;;                times=1;                ch = s[i];                after+=4;            &#125;            else&#123;                times++;                if(times==7)&#123;                    t+=ch;                    t+=binary[7];                    t+=&quot; &quot;;                    times=1;                    after +=4;                    ch = s[i+1];                    i++;                &#125;            &#125;        &#125;        if(after==-1)cout&lt;&lt;after&lt;&lt;endl;        else cout&lt;&lt;t&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;(double)after*100/origin&lt;&lt;&quot;%&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]棒球遊戲","url":"/a110/","content":"a110. 棒球遊戲\n#include &lt;bits/stdc++.h&gt;using namespace std;int num_of_out,d[3] = &#123;0&#125;;int transfer(string a)&#123;    if(a==&quot;SO&quot;||a==&quot;FO&quot;||a==&quot;GO&quot;)return 0;    else if(a==&quot;1B&quot;)return 1;    else if(a==&quot;2B&quot;)return 2;    else if(a==&quot;3B&quot;)return 3;    else return 4;&#125;int win(int c)&#123;    int s = 0;    if(c!=4)&#123;        for(int i=0;i&lt;c;i++)&#123;            if(d[2-i])s++;        &#125;        for(int i=0;i&lt;3-c;i++)&#123;            d[2-i] = d[2-c-i];        &#125;    &#125;    if(c==4)&#123;        for(int i=0;i&lt;3;i++)if(d[i])s++;        s++;    &#125;    else d[c-1] = 1;    for(int i=0;i&lt;c-1;i++)d[i] = 0;    return s;&#125;int main()&#123;    int data[9][5];    for(int i=0;i&lt;9;i++)&#123;        int temp;        cin&gt;&gt;temp;        for(int k=0;k&lt;temp;k++)&#123;            string a;            cin&gt;&gt;a;            data[i][k] = transfer(a);        &#125;    &#125;    cin&gt;&gt;num_of_out;    int now_out = 0,ans = 0;    for(int k=0;k&lt;5;k++)&#123;        for(int i=0;i&lt;9;i++)&#123;            if(now_out&gt;=num_of_out)break;            if(data[i][k])&#123;                ans+=win(data[i][k]);            &#125;            else&#123;                now_out++;                if(now_out%3==0)&#123;                    for(int i =0;i&lt;3;i++)d[i] = 0;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]排隊","url":"/a111/","content":"a111. 排隊\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    int t[1005][3],line=0,ans=0,cur=0;        cin&gt;&gt;t[0][0]&gt;&gt;t[0][1];    t[0][2] = t[0][0]+t[0][1];    for(int i=1;i&lt;n;i++)&#123;        cin&gt;&gt;t[i][0]&gt;&gt;t[i][1];        if(t[i][0]&lt;t[i-1][2])t[i][2] = t[i-1][2]+t[i][1];        else t[i][2] = t[i][0]+t[i][1];                if(t[i][0]&gt;=t[cur][2])&#123;            ans = max(ans,line);            while(t[i][0]&gt;=t[cur][2])&#123;                if(cur==i)break;                line--;                cur++;            &#125;        &#125;        if(t[i][0]&lt;t[cur][2])line++;    &#125;    ans = max(ans,line);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]動物數量統計","url":"/a112/","content":"a112. 動物數量統計\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//地點、動物名、數量int main()&#123;    int n;cin&gt;&gt;n;    vector&lt;string&gt; p;    while(n--)&#123;        string animal,pos;        int qu,ind;        cin&gt;&gt;animal&gt;&gt;qu&gt;&gt;pos;        ind = find(p.begin(),p.end(),pos)-p.begin();        if(ind==p.size())p.push_back(pos);        mp[pos].push(&#123;animal,qu&#125;);    &#125;    for(auto i:p)&#123;        cout&lt;&lt;i&lt;&lt;&quot;:&quot;;        map&lt;string,int&gt; sta;        vector&lt;string&gt; almp;        while(!mp[i].empty())&#123;            string an = mp[i].front().first;            int qu = mp[i].front().second;            mp[i].pop();            int ind = find(almp.begin(),almp.end(),an)-almp.begin();            if(ind==almp.size())almp.push_back(an);            sta[an]+=qu;        &#125;        bool c = 0;        for(auto j:almp)&#123;            if(c)cout&lt;&lt;&quot;,&quot;;            cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;sta[j];            c = 1;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]99遊戲","url":"/a113/","content":"a113. 99遊戲\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int,queue&lt;string&gt;&gt; mp;int main()&#123;    for(int i=0;i&lt;4;i++)&#123;        char ch;cin&gt;&gt;ch;        for(int j=0;j&lt;13;j++)&#123;            string s;cin&gt;&gt;s;            mp[ch-&#x27;A&#x27;].push(s);        &#125;    &#125;    int id = 0,dir=1,sum=0;    while(sum&lt;=99)&#123;        string card = mp[id].front();        if(card==&quot;A&quot;)sum=0;        else if(card==&quot;4&quot;)dir*=-1;        else if(card==&quot;5&quot;);        else if(card==&quot;10&quot;)&#123;            sum+=10;            if(sum&gt;99)sum-=20;        &#125;        else if(card==&quot;J&quot;);        else if(card==&quot;Q&quot;)&#123;            sum+=20;            if(sum&gt;99)sum-=40;        &#125;        else if(card==&quot;K&quot;)sum=99;        else&#123;            sum+=(card[0]-&#x27;0&#x27;);            if(sum&gt;99)&#123;                cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;mp[id].size()-1&lt;&lt;endl;                break;            &#125;        &#125;        mp[id].pop();        if(mp[id].empty())&#123;            cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;            break;        &#125;        id = (id+dir+4)%4;//        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]找出最小的完全平方數","url":"/a114/","content":"a114/ 找出最小的完全平方數\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;void solve()&#123;    int k;cin&gt;&gt;k;    int a = ceil(sqrt(pow(10,(k-1))));    for(int i=a;;i++)&#123;        string s = to_string(i*i);        int len = s.size(),flag = 0;        for(int i=0;i&lt;len;i++)&#123;            if((s[i]-&#x27;0&#x27;)%2!=0)&#123;                flag = 1;                break;            &#125;        &#125;        if(flag==0)&#123;            cout&lt;&lt;i*i&lt;&lt;endl;            break;        &#125;    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]賓果遊戲","url":"/a115/","content":"a115/ 賓果遊戲\n#include &lt;bits/stdc++.h&gt;//#define int ll//#define ll long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int maze[10][10],cur[10][10],n;    for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            cin&gt;&gt;maze[i][j];            cur[i][j] = maze[i][j];        &#125;    &#125;    while(cin&gt;&gt;n &amp;&amp; n!= -1)&#123;        for(int i=0;i&lt;5;i++)&#123;            for(int j=0;j&lt;5;j++)&#123;                if(maze[i][j]==n)maze[i][j] = 0;            &#125;        &#125;    &#125;        int ind = 1,num = -1;        for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            if(maze[i][j]!=0)&#123;                maze[i][j] = 0;                int k,ans = 0;                for(k=0;k&lt;5;k++)if(maze[k][j]!=0)break;                if(k==5)ans+=1;                for(k=0;k&lt;5;k++)if(maze[i][k]!=0)break;                if(k==5)ans+=1;                                if(i==j)&#123;                    for(k=0;k&lt;5;k++)if(maze[k][k]!=0)break;                    if(k==5)ans+=1;                &#125;                if(i+j==4)&#123;                    int x = 4,y = 0;                    for(k=0;k&lt;5;k++)&#123;                        if(maze[x][y]!=0)break;                        else&#123;                            x--;y++;                        &#125;                    &#125;                    if(k==5)ans++;                &#125;                if(ans&gt;num)&#123;                    num = ans;                    ind = cur[i][j];                &#125;                else if(ans==num &amp;&amp; ind&gt;cur[i][j])ind = cur[i][j];                maze[i][j] = cur[i][j];            &#125;        &#125;    &#125;    cout&lt;&lt;ind&lt;&lt;endl;&#125;signed main()&#123;    ios;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]一起回家的日子","url":"/a116/","content":"a116/ 一起回家的日子\n#include &lt;bits/stdc++.h&gt;//#define ll long long//#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;int gcd(int a,int b)&#123;    if(a==b)return a;        if(a&lt;b)swap(a,b);    while(b!=0)&#123;        int c = a%b;        a = b;        b = c;    &#125;    return a;&#125;bool leap(int a)&#123;    if((a%100!=0||a%400==0)&amp;&amp;(a%4==0))return 1;    else return 0;&#125;void solve()&#123;    int n,arr[100];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int ans = arr[0];    for(int i=1;i&lt;n;i++)ans=(ans*arr[i])/gcd(ans,arr[i]);        int y,m,d;    scanf(&quot;%d/%d/%d&quot;,&amp;y,&amp;m,&amp;d);        int month[15] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    d+=ans;        while(d&gt;month[m])&#123;        d-=month[m];        if(m==12)&#123;            y++;            m = 1;        &#125;        else&#123;            if(leap(y)&amp;&amp;m==2)&#123;                d--;            &#125;            m++;        &#125;    &#125;    printf(&quot;%04d/%02d/%02d\\n&quot;,y,m,d);&#125;signed main()&#123;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]三色河內塔","url":"/a117/","content":"a117/ 三色河內塔\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void move(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    move(n-1,by,to,from);&#125;void honai(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    honai(n-2,by,from,to);&#125;signed main()&#123;    ios;    int n;cin&gt;&gt;n;    t = 0;    honai(n,&#x27;A&#x27;,&#x27;C&#x27;,&#x27;B&#x27;);    cout&lt;&lt;&quot;共需&quot;&lt;&lt;t&lt;&lt;&quot;個移動&quot;&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]指數2^k的四個自然數平方和之所有表示法","url":"/a118/","content":"a118/ 指數2^k的四個自然數平方和之所有表示法\n#include &lt;bits/stdc++.h&gt;#define N 64000#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int num[5],sqr[N];int solution = 0,n;void init()&#123;    for(int i=0;i&lt;N;i++)sqr[i] = i*i;&#125;void pick(int remain,int id)&#123;    if(id==4)&#123;        int r = sqrt(remain);        if(sqr[r]==remain)&#123;            cout&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;&quot; &quot;&lt;&lt;num[3]&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;            solution++;        &#125;        return;    &#125;    int lower = max(1,num[id-1]),upper = sqrt(remain/(5-id));        for(int i=lower;i&lt;=upper;i++)&#123;        num[id]= i;        pick(remain-sqr[i],id+1);    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    pick(1&lt;&lt;n,1);    if(solution==0)cout&lt;&lt;0&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]括號問題","url":"/a119/","content":"a119. 括號問題\n#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; stk;int main()&#123;    string s;    getline(cin,s);    int len = s.size(),ans = 0,f=1;    for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)stk.push(1);        else if(s[i]==&#x27;)&#x27;)&#123;            if(!stk.empty())&#123;                stk.pop();                ans++;            &#125;            else f = 0;        &#125;    &#125;    if(!stk.empty())f= 0;        if(f)cout&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;0&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]中置式轉後置式","url":"/a120/","content":"a120. 中置式轉後置式\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;char,int&gt; mp&#123;&#123;&#x27;+&#x27;,1&#125;,&#123;&#x27;-&#x27;,1&#125;,&#123;&#x27;*&#x27;,2&#125;,&#123;&#x27;/&#x27;,2&#125;,&#123;&#x27;(&#x27;,0&#125;&#125;;    string s;cin&gt;&gt;s;    stack&lt;char&gt; st;    int len = s.size();        for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)st.push(&#x27;(&#x27;);        else if(s[i]==&#x27;)&#x27;)&#123;            while(!st.empty()&amp;&amp;st.top()!=&#x27;(&#x27;)&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.pop();        &#125;        else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;            while(!st.empty() &amp;&amp; mp[st.top()]&gt;=mp[s[i]])&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.push(s[i]);        &#125;        else cout&lt;&lt;s[i];    &#125;    while(!st.empty())&#123;        cout&lt;&lt;st.top();        st.pop();    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]電腦算術運算","url":"/a121/","content":"a121. 電腦算術運算\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    string s;    while(n--)&#123;        cin&gt;&gt;s;        stack&lt;int&gt; stk;        bool legal = 1;                for(int i=0;i&lt;s.size();i++)&#123;            if(s[i]==&#x27;)&#x27;||s[i]==&#x27;,&#x27;||s[i]==&#x27;(&#x27;);            else if(isdigit(s[i]))&#123;                int sum = s[i]-&#x27;0&#x27;;                while(isdigit(s[++i]))&#123;                    sum=sum*10+(s[i]-&#x27;0&#x27;);                &#125;                stk.push(sum);                i--;            &#125;            else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;                if(s[i+1]!=&#x27;)&#x27;)&#123;                    legal = 0;                    break;                &#125;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;&amp;&amp; a==0)&#123;                    legal = 0;                    break;                &#125;                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);            &#125;            else&#123;                legal = 0;                break;            &#125;        &#125;        if(legal==0)cout&lt;&lt;-1&lt;&lt;endl;        else if(stk.size()==1)cout&lt;&lt;stk.top()&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]血緣關係","url":"/a122/","content":"a122. 血緣關係\n#include &lt;bits/stdc++.h&gt;#define N 100005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,start,dis[N];bool visit[N];vector&lt;int&gt;edge[N];int dfs(int id,int cur_dis)&#123;  //尋找點id的最遠點距離    if(visit[id])return 0;    visit[id] = 1;    int len = edge[id].size(),max_len=0;    for(int i=0;i&lt;len;i++)&#123;        int next = edge[id][i];        if(visit[next])continue;        dis[next] = cur_dis+1;        int temp = dfs(next,cur_dis+1);        max_len = max(max_len,temp);    &#125;    return max_len+1;&#125;int main()&#123;    ios;    cin&gt;&gt;n;    for(int i=0;i&lt;n-1;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    start = 0;    memset(visit,0,sizeof(visit));    int distance = dfs(2,0);distance--;    for(int i=0;i&lt;n;i++)&#123;        if(dis[i]==distance)&#123;            start = i;            break;        &#125;    &#125;    memset(visit,0,sizeof(visit));    cout&lt;&lt;dfs(start,0)-1&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]樹狀圖分析","url":"/a123/","content":"a123. 樹狀圖分析\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,father[N],h[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    int maxn = 0;    for(auto next:edge[cur])&#123;        dfs(next);        maxn = max(maxn,h[next]+1);    &#125;    h[cur] = maxn;&#125;signed main()&#123;    ios;    memset(h,0,sizeof(h));    memset(father,0,sizeof(father));        cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int k;cin&gt;&gt;k;        for(int j=0;j&lt;k;j++)&#123;            int temp;cin&gt;&gt;temp;            edge[i].push_back(temp);            father[temp] = i;        &#125;    &#125;    int root = 1;    while(father[root]!=0)root++;        dfs(root);        lld ans = 0;    for(int i=1;i&lt;=n;i++)ans += h[i];        cout&lt;&lt;root&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl;&#125;//O(N)的作法#include &lt;bits/stdc++.h&gt;#define lld long longusing namespace std;lld n,m;int main()&#123;    int t;scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        int n,m,ans = 1;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        m--;    //從0開始        for(int i=1;i&lt;n;i++)&#123;         //共n-1步要走            if(m&amp;1)ans = ans*2+1;     //往右邊走            else ans = ans*2;            m = m&gt;&gt;1;                 //由低bit到高bit決定每一步要怎麼走        &#125;        printf(&quot;%lld\\n&quot;,ans);    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]二分圖","url":"/a124/","content":"a124. 二分圖\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,m,ans = 0,cnt[2];vector&lt;int&gt; edge[N];int color[N];bool dfs(int cur,int c)&#123;    color[cur] = c;    cnt[c]+=1;    bool flag = 1;    for(auto i:edge[cur])&#123;        if(color[i]==color[cur])return 0;        if(color[i]==-1)flag = (flag &amp;&amp; dfs(i,!c));    &#125;    return flag;&#125;void solve()&#123;    memset(color,0,sizeof(color));        for(int i=0;i&lt;n;i++)color[i] = -1;        for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;a--;b--;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(color[i]==-1)&#123;            cnt[0] = 0;cnt[1] = 0;            if(!dfs(i,0))&#123;                cout&lt;&lt;0&lt;&lt;endl;                return;            &#125;            ans += min(cnt[0],cnt[1]);            //有可能是非連通圖，用+=        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    solve();&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]Agar.io","url":"/a128/","content":"a128. Agar.io\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,full[N];set&lt;int&gt; s[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    fill(full,full+n+1,10);    for(int i=1;i&lt;=n;i++)s[i].insert(i);        while(m--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(full[b]&gt;full[a])swap(a,b);        full[a] += full[b];        full[b] = 0;        for(auto p:s[b])s[a].insert(p);        s[b].clear();    &#125;    int ans = max_element(full,full+n+1)-full;    cout&lt;&lt;ans&lt;&lt;endl;    for(auto p:s[ans])cout&lt;&lt;p&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]連號或不連號","url":"/a127/","content":"a127. 連號或不連號\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int n;int main()&#123;    while(cin&gt;&gt;n)&#123;        set&lt;int&gt;s;        for(int i=0;i&lt;n;i++)&#123;            int x;cin&gt;&gt;x;            s.insert(x);        &#125;        int maxn = *(--s.end());        int minn = *s.begin();        if(s.size()==maxn-minn+1)cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; yes&quot;&lt;&lt;endl;        else cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; no&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]飛天桑妮","url":"/a129/","content":"a129. 飛天桑妮\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;vector&lt;pii&gt; vec;bool cmp(pii a,pii b)&#123;    if(a.first==b.first)return a.second&gt;b.second;    return a.first&lt;b.first;&#125;int main()&#123;    int n,x,y,h;cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;h;        vec.push_back(&#123;x*x+y*y,h&#125;);    &#125;    sort(vec.begin(),vec.end(),cmp);    int ans  = 0,maxh = 0;    for(int i=0;i&lt;n;i++)&#123;        maxh = max(maxh,vec[i].second);        ans = max(ans,maxh-vec[i].second);    &#125;//維護最高的樹    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]人員調動","url":"/a130/","content":"a130. 人員調動\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    int wait[N][N];memset(wait,0,sizeof(wait));        int m,ans = 0;cin&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(wait[b][a]&gt;0)&#123;            ans++;wait[b][a]--;        &#125;        else wait[a][b]++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]大黑馬","url":"/a131/","content":"a131. 大黑馬\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int k,n;int normal[N][N],lower[N][N],upper[N][N];bool win(int a,int b,int is_normal)&#123;    for(int i=0;i&lt;k+1;i++)&#123;        if(is_normal==0)&#123;            if(normal[a][i]&lt;=normal[b][k+i])return 0;        &#125;        else&#123;            if(upper[a][i]&lt;=lower[b][k+i])return 0;        &#125;    &#125;    return 1;&#125;int main()&#123;    cin&gt;&gt;k&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int s;cin&gt;&gt;s;        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;normal[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;upper[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;lower[s][j];    &#125;    for(int p=0;p&lt;=1;p++)&#123;        for(int i=n;i&gt;0;i--)&#123;    //從種子序較小的開始            bool f = 1;            for(int j=1;j&lt;=n;j++)&#123;                if(!win(i,j,p))&#123;                    f = 0;                    break;                &#125;            &#125;            if(f)&#123;                cout&lt;&lt;i&lt;&lt;&quot; &quot;;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]採蘑菇攻略問題","url":"/a133/","content":"a133. 採蘑菇攻略問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    cin&gt;&gt;n;    int ans = 0,dp[N][N];    memset(dp,0,sizeof(dp));        FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        dp[i][i] = temp;        ans = max(ans,temp);    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            dp[i][j] = dp[i][j-1]+dp[j][j];            ans = max(ans,dp[i][j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]主機排程","url":"/a132/","content":"a132. 主機排程\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define max_ele(a) max_element(a,a+dh)using namespace std;int n,dh;void solve()&#123;    int s;cin&gt;&gt;s;    int arr[N]=&#123;0&#125;,brr[N]=&#123;0&#125;,crr[N]=&#123;0&#125;;    while(s--)&#123;        int a,b,c,d,e,f;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;        int start = (a-1)*24+b;        for(int j=0;j&lt;c;j++)&#123;            arr[(start+j)%dh]+=d;            brr[(start+j)%dh]+=e;            crr[(start+j)%dh]+=f;        &#125;    &#125;    cout&lt;&lt;*max_ele(arr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(brr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(crr)&lt;&lt;endl;    cin&gt;&gt;s;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;dh;    dh = dh*24;    while(n--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]巧克力擺盒","url":"/a135/","content":"a135. 巧克力擺盒\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,k;int r[9],box[9];;bool cmp(vector&lt;int&gt; r)&#123;    for(int i=0;i&lt;9;i+=3)&#123;        if(r.size()==3)&#123;            if((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1])&amp;&amp;(r[2]&amp;box[i+2]))&#123;                return true;            &#125;            //對於這一行的指定是有滿足的，回傳正確（下一個要求繼續再呼叫一次）        &#125;        else if(((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1]))||((r[0]&amp;box[i+1])&amp;&amp;(r[1]&amp;box[i+2])))&#123;            return true;        &#125;    &#125;    return false;&#125;vector&lt;int&gt; rule;vector&lt;vector&lt;int&gt;&gt; rule_list;void solve()&#123;    for(int i=0;i&lt;9;i++)&#123;        int temp=1;temp = temp&lt;&lt;i;        r[i] = temp;        box[i] = temp;    &#125;    map&lt;string,int&gt; mp = &#123;        &#123;&quot;PS&quot;,r[0]&#125;,        &#123;&quot;PC&quot;,r[1]&#125;,        &#123;&quot;PT&quot;,r[2]&#125;,        &#123;&quot;P?&quot;,r[0]|r[1]|r[2]&#125;,        &#123;&quot;BS&quot;,r[3]&#125;,        &#123;&quot;BC&quot;,r[4]&#125;,        &#123;&quot;BT&quot;,r[5]&#125;,        &#123;&quot;B?&quot;,r[3]|r[4]|r[5]&#125;,        &#123;&quot;YS&quot;,r[6]&#125;,        &#123;&quot;YC&quot;,r[7]&#125;,        &#123;&quot;YT&quot;,r[8]&#125;,        &#123;&quot;Y?&quot;,r[6]|r[7]|r[8]&#125;,        &#123;&quot;?S&quot;,r[0]|r[3]|r[6]&#125;,        &#123;&quot;?C&quot;,r[1]|r[4]|r[7]&#125;,        &#123;&quot;?T&quot;,r[2]|r[5]|r[8]&#125;,        &#123;&quot;??&quot;,511&#125;,    &#125;;    cin&gt;&gt;n;    while(n--)&#123;        cin&gt;&gt;k;        rule.resize(k);        for(int i=0;i&lt;k;i++)&#123;            char temp[3];cin&gt;&gt;temp[0]&gt;&gt;temp[1];            rule[i] = (mp[temp]);        &#125;        rule_list.push_back(rule);    &#125;    int ans = 0;    do&#123;        ans += all_of(rule_list.begin(),rule_list.end(),cmp);            &#125;while(next_permutation(box,box+9));        cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]元件測試排程問題","url":"/a136/","content":"a136. 元件測試排程問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 30#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,ans[N];;bool edge[N][N],is_root[N];bool is_front(int u, int v)&#123;    if(edge[u][v])return true;    for(int i=0;i&lt;n;i++)&#123;        if(edge[u][i] &amp;&amp; is_front(i,v))            return true;    &#125;    return false;&#125;bool togological()&#123;    int deg[N],sum = 0,ind = 0;    memset(deg,0,sizeof(deg));    rep(i,0,n-1)&#123;        rep(j,0,n-1)&#123;            if(edge[i][j])deg[j] += 1;        &#125;    &#125;    queue&lt;int&gt; que;    rep(i,0,n-1)if(deg[i]==0)&#123;        if(sum == 1)return false;        sum += 1;        que.push(i);    &#125;    while(!que.empty())&#123;        int cur = que.front();sum = 0;        ans[ind++] = cur;        que.pop();        for(int i=0;i&lt;n;i++)&#123;            if(edge[cur][i])&#123;                deg[i]--;                if(deg[i] == 0)&#123;                    if(sum == 1)return false;                    sum += 1;                    que.push(i);                &#125;            &#125;        &#125;    &#125;    if(ind &lt; n)return false;    return true;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    bool flag = 1;    memset(edge,0,sizeof(edge));    fill(is_root,is_root+N,1);    for(int i=1;i&lt;=m;i++)&#123;        char a,b;cin&gt;&gt;a&gt;&gt;b;        int from = a-&#x27;A&#x27;,to = b-&#x27;A&#x27;;        is_root[to] = 0;        edge[from][to] = 1;        if(is_front(to,from))&#123;            flag = 0;            cout&lt;&lt;&quot;Order conflict after getting pair &quot;&lt;&lt;i&lt;&lt;endl;            break;        &#125;        else if(togological())&#123;            flag = 0;            cout&lt;&lt;&quot;Determine the testing sequence after getting pair &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;;            for(int i=0;i&lt;n;i++)cout&lt;&lt;(char)(ans[i]+&#x27;A&#x27;);            cout&lt;&lt;endl;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;No answer&quot;&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]勇者冒險","url":"/a137/","content":"a137. 勇者冒險\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,0,sizeof(mp));    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return 0;            &#125;            if(mp[nx][ny] == 0)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;    return 0;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]回文日期問題","url":"/a134/","content":"a134. 回文日期問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;vector&lt;int&gt;ans;bool leap(int temp)&#123;    return (((temp%4)==0 &amp;&amp;(temp%100)!=0)||(temp%400)==0);&#125;void check(string s)&#123;    string temp = s;    reverse(temp.begin(),temp.end());    if(temp==s)ans.push_back(stoi(s));&#125;void solve()&#123;    cin&gt;&gt;n;    ans.clear();    int month[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    month[2]+=((leap(n))?1:0);    for(int i=1;i&lt;=12;i++)&#123;        for(int j=1;j&lt;=month[i];j++)&#123;            check(to_string(n)+to_string(i)+to_string(j));            if(i&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+to_string(j));            if(j&lt;10)check(to_string(n)+to_string(i)+&quot;0&quot;+to_string(j));            if(i&lt;10 &amp;&amp; j&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+&quot;0&quot;+to_string(j));        &#125;    &#125;    sort(ans.begin(),ans.end());    cout&lt;&lt;ans.size();    for(auto i:ans)cout&lt;&lt;&quot; &quot;&lt;&lt;i;    cout&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]物品堆疊","url":"/a140/","content":"a140. 物品堆疊\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii p[N];bool cmp(pii a, pii b)&#123;    return a.x*b.y &lt; a.y*b.x;    //p[1~n]變成從上到下&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,0,n-1)cin&gt;&gt;p[i].x;    rep(i,0,n-1)cin&gt;&gt;p[i].y;    sort(p,p+n,cmp);    int weight = 0,ans = 0;    for(int i=0;i&lt;n-1;i++)&#123;        weight += p[i].x;        ans += weight*p[i+1].y;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]基地台","url":"/a141/","content":"a141. 基地台\n#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 50005using namespace std;int n,k,arr[N];//確認直徑可否覆蓋全部（greedy）bool check(int sum)&#123;    int max_cover = arr[0]+sum;    int cnt=1;    for(int i=1;i&lt;n;i++)&#123;        if(max_cover &lt; arr[i])&#123;            max_cover = arr[i]+sum;            cnt++;        &#125;    &#125;    return (cnt&lt;=k);&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    int l = 1,r = ceil((arr[n-1]-arr[0])/k);    //區間[l,r]二分搜尋直徑    while(l&lt;r)&#123;        int mid = (l+r)/2;        if(check(mid))r = mid;        else l = mid+1;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]無刻度容器倒水問題","url":"/a142/","content":"a142. 無刻度容器倒水問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define double long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int x,y,z;int a[N][N];bool visit[N][N];void solve()&#123;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;    memset(a,0x3f3f3f3f,sizeof(a));memset(visit,0,sizeof(visit));    a[0][0] = 0;    queue&lt;pii&gt;que;    que.push(&#123;0,0&#125;);    visit[0][0] = 1;        bool f = 0;    while(!que.empty())&#123;        pii cur = que.front();        que.pop();        int mmin = cur.x,mmax = cur.y;        int dx[6] = &#123;max(0,mmax-(y-mmin)),min(mmax+mmin,x),x,mmin,0,mmin&#125;;        int dy[6] = &#123;min(y,mmax+mmin),max(0,mmax-(x-mmin)),mmax,y,mmax,0&#125;;                for(int i=0;i&lt;6;i++)&#123;            int nx = dx[i],ny = dy[i];            if(nx==z||ny==z)&#123;                f = 1;                cout&lt;&lt;a[mmin][mmax]+1&lt;&lt;endl;                return;            &#125;            if(visit[nx][ny])continue;            a[nx][ny] = a[mmin][mmax]+1;            visit[nx][ny] = 1;            que.push(&#123;nx,ny&#125;);        &#125;    &#125;    if(!f)cout&lt;&lt;-1&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]背包置物問題","url":"/a139/","content":"a139. 背包置物問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,k;vector&lt;int&gt; vec,p;signed main()&#123;    cin&gt;&gt;n;    vec.assign(1,-1);    cin.ignore();    string s;getline(cin,s);    stringstream ss(s);    int temp;    while(ss&gt;&gt;temp)vec.push_back(temp);    cin&gt;&gt;k;        int ans = 0,len = vec.size();    for(int i=1;i&lt;=len-1;i++)&#123;        if(find(p.begin(),p.end(),vec[i])!=p.end())continue;        else if(p.size()&lt;k)&#123;            p.push_back(vec[i]);            continue;        &#125;        int index = 0, dis = 0, max_dis=0;                for(int j=0;j&lt;p.size();j++)&#123;            dis = 0;            for(int q=i+1;q&lt;=len;q++)&#123;                if(vec[q]==p[j])break;                dis += 1;            &#125;            if(max_dis &lt; dis)&#123;                max_dis = dis;                index = j;            &#125;        &#125;//        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;index&lt;&lt;endl;        p[index] = vec[i];        ans += 1;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]關鍵字搜尋模擬","url":"/a143/","content":"a143. 關鍵字搜尋模擬\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,num_key = 0;string key[N];vector&lt;pif&gt; ans;int com_string(string s1, string s2)&#123;    s1 = &quot;0&quot;+s1;s2 = &quot;0&quot;+s2;    int ans = 0,com[N][N];memset(com,0,sizeof(com));    int len1 = s1.size(),len2 = s2.size();    for(int i=1;i&lt;len1;i++)&#123;        for(int j=1;j&lt;len2;j++)&#123;            if(s1[i] == s2[j])&#123;                com[i][j] = com[i-1][j-1]+1;                ans = max(ans,com[i][j]);            &#125;        &#125;    &#125;    return ans;&#125;bool cmp(pif a,pif b)&#123;    if(a.y == b.y)return a.x &lt; b.x;    return a.y &gt; b.y;&#125;float max_num(string s)&#123;    float ans = 0.0;    for(int i=0;i&lt;num_key;i++)&#123;        ans = max(ans,(float)com_string(s,key[i])/key[i].size());    &#125;    return ans;&#125;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);    while(ss&gt;&gt;key[num_key++]);    cin&gt;&gt;n;cin.ignore();    while(n--)&#123;        int doc_num;        getline(cin,s);        stringstream ss2(s);        ss2&gt;&gt;doc_num;        float score = 0.0;        while(ss2 &gt;&gt; s)score += max_num(s);                score = round(score*100)/100;        ans.push_back(&#123;doc_num,score&#125;);    &#125;    sort(ans.begin(),ans.end(),cmp);    if(ans[0].y &lt;= 0)cout&lt;&lt;&quot;FALSE&quot;&lt;&lt;endl;    else for(auto i: ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]農作物採收問題","url":"/a144/","content":"a144. 農作物採收問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 25#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,num[N][N],dp[N][N];void init()&#123;    memset(num,0,sizeof(num));    memset(dp,0,sizeof(dp));&#125;signed main()&#123;    init();    cin&gt;&gt;n;    rep(i,1,n)rep(j,1,n)cin&gt;&gt;num[i][j];        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];        &#125;    &#125;    int ans = 0;        //左上(a,b)右下(x,y)    rep(i,1,n)rep(j,1,n)rep(a,1,i)rep(b,1,j)    ans = max(ans,num[i][j]-num[a-1][j]-num[i][b-1]+num[a-1][b-1]);        cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]搬家規畫問題","url":"/a145/","content":"a145. 搬家規畫問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);        int w[N],v[N],ind=0;    while(ss&gt;&gt;w[ind++]);    ind--;    for(int i=0;i&lt;ind;i++)cin&gt;&gt;v[i];    int c;cin&gt;&gt;c;    int dp[c+5];    memset(dp,0,sizeof(dp));    for(int i=0;i&lt;ind;i++)&#123;        for(int j=c;j&gt;=w[i];j--)&#123;            dp[j] = max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[c]&lt;&lt;endl;    &#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]促銷活動","url":"/a147/","content":"a147/ 促銷活動\n#include &lt;iostream&gt;using namespace std;void discount(double &amp;a,double &amp;b)&#123;    if(a==b)&#123;        b = 0.5*b;    &#125;&#125;int main()&#123;    double p1, p2;    cout &lt;&lt; &quot;Original price:&quot; &lt;&lt; endl;    cin &gt;&gt; p1 &gt;&gt; p2;    discount(p1,p2);    cout &lt;&lt; &quot;Price after discount:&quot; &lt;&lt; endl;    cout &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; endl;    return 0;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]字元頻率","url":"/a148/","content":"a148. 字元頻率\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;bool cmp(pii a,pii b)&#123;    if(a.second==b.second)return a.first&gt;b.first;    else return a.second&lt; b.second;&#125;int main()&#123;    string s;    while(getline(cin,s))&#123;        map&lt;int,int&gt; mp;    //asci、出現次數        for(auto temp:s)mp[temp]+=1;        vector&lt;pii&gt;vec;        for(auto p:mp)&#123;            vec.push_back(p);        &#125;        sort(vec.begin(),vec.end(),cmp);        for(auto i:vec)&#123;            cout&lt;&lt;i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second&lt;&lt;endl;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]多邊形面積","url":"/a150/","content":"a150. 多邊形面積\n#include &lt;bits/stdc++.h&gt;using namespace std;struct point&#123;    double x;    double y;&#125;;int main()&#123;    int n;    cin&gt;&gt;n;    point p[n];        for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    double a = 0.0;    for(int i=0;i&lt;n;i++)&#123;        if(i==n-1)&#123;            a+=(p[i].x)*(p[0].y)-(p[0].x)*(p[i].y);        &#125;        else&#123;            a+=(p[i].x)*(p[i+1].y)-(p[i+1].x)*(p[i].y);        &#125;    &#125;    a = abs(a/2);    cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]後序式求值","url":"/a151/","content":"a151. 後序式求值\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        stack&lt;int&gt; stk;        for(int i=0;i&lt;s.size();i++)&#123;            if(isdigit(s[i]))stk.push(s[i]-&#x27;0&#x27;);            else&#123;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);                else if(s[i]==&#x27;%&#x27;)stk.push(b%a);            &#125;        &#125;        cout&lt;&lt;stk.top()&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]二分搜尋","url":"/a152/","content":"a152. 二分搜尋\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int t;cin&gt;&gt;t;        int pos = 0,ans = 0,find = 0,l = 0,r = n-1;    //[l,r]        while(l&lt;=r)&#123;        int mid = (l+r)/2;        ans++;        if(arr[mid]==t)&#123;            pos = mid;find = 1;break;        &#125;        else if(arr[mid]&gt;t)r = mid-1;        else l = mid+1;    &#125;    if(find)cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;&quot;not found &quot;&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]二分法求解","url":"/a153/","content":"a153. 二分法求解\n#include &lt;bits/stdc++.h&gt;int main()&#123;  std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(6)&lt;&lt;log(2)&lt;&lt;std::endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]除法","url":"/a154/","content":"a154. 除法\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;bool used[10],f;bool check(int t)&#123;    bool cur_used[10]=&#123;0&#125;;    if(t&lt;10000&amp;&amp;used[0]==1)return 0;    else if(t&lt;10000)cur_used[0] = 1;        while(t&gt;0)&#123;        int d = t%10;        if(cur_used[d])return 0;        else if(used[d])return 0;        cur_used[d] = 1;        t /= 10;    &#125;    return 1;&#125;void dfs(int first,int id)&#123;    if(id&gt;=5)&#123;        if(first%n!=0)return;        int second = first/n;        if(second&lt;1234)return;        if(check(second))&#123;            f = 1;            cout&lt;&lt;first&lt;&lt;&quot; / &quot;;            if(second&lt;10000)cout&lt;&lt;0;            cout&lt;&lt;second&lt;&lt;&quot; = &quot;&lt;&lt;n&lt;&lt;endl;            return;        &#125;    &#125;    for(int i=0;i&lt;10;i++)&#123;        if(used[i])continue;        used[i] = 1;        dfs(first*10+i,id+1);        used[i] = 0;    &#125;&#125;void solve()&#123;    while(cin&gt;&gt;n)&#123;        if(n==0)return;        memset(used,0,sizeof(used));        f=0;        dfs(0,0);        if(f==0)cout&lt;&lt;&quot;There are no solutions for &quot;&lt;&lt;n&lt;&lt;&quot;.&quot;&lt;&lt;endl;        cout&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]費波那契數列","url":"/a157/","content":"a157/ 費波那契數列\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]F91","url":"/a158/","content":"a158/ F91\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]線段覆蓋長度","url":"/a160/","content":"a160. 線段覆蓋長度\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii a[N];signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;        sort(a,a+n);                int sum = a[0].y - a[0].x,R = a[0].y;        for(int i=1;i&lt;n;i++)&#123;            if(a[i].y &gt; R)&#123;                sum += (a[i].y-a[i].x)-(R-a[i].x)*((R-a[i].x)&gt;0);                R = a[i].y;            &#125;        &#125;        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]雙子星塔","url":"/a155/","content":"a155. 雙子星塔\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,dp[N][N],a[N],b[N],cnt = 0;signed main()&#123;        while(cin&gt;&gt;n&gt;&gt;m)&#123;        if(!n &amp;&amp; !m)break;        cnt+=1;        cout&lt;&lt;&quot;Twin Towers #&quot;&lt;&lt;cnt&lt;&lt;endl;        memset(dp,0,sizeof(dp));        rep(i,1,n)cin&gt;&gt;a[i];        rep(i,1,m)cin&gt;&gt;b[i];                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=m;j++)&#123;                if(a[i]==b[j])&#123;                    dp[i][j] = dp[i-1][j-1]+1;                &#125;                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;        cout&lt;&lt;&quot;Number of Tiles : &quot;;        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]印表機佇列","url":"/a163/","content":"a163. 印表機佇列\n#include &lt;bits/stdc++.h&gt;using namespace std;bool Can(int now_priority,int *p)&#123;    for(int i=now_priority+1;i&lt;=9;i++)&#123;        if(p[i]&gt;=1)return 0;    &#125;    return 1;&#125;void solve()&#123;    int n,m,pri[105];cin&gt;&gt;n&gt;&gt;m;    queue&lt;pair&lt;bool,int&gt;&gt; que;    memset(pri,0,sizeof(pri));    for(int i=0;i&lt;n;i++)&#123;        int p;cin&gt;&gt;p;        if(i==m)que.push(&#123;1,p&#125;);        else que.push(&#123;0,p&#125;);        pri[p]++;    &#125;        int ans = 0;    while(!que.empty())&#123;        auto cur = que.front();        que.pop();        if(Can(cur.second,pri))&#123;            //可以印的話            ans++;            pri[cur.second]--;            if(cur.first==1)break;        &#125;        else que.push(cur);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]錯誤更正","url":"/a159/","content":"a159/ 錯誤更正\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        int row_sum[N],col_sum[N],arr[N][N];        memset(row_sum,0,sizeof(row_sum));        memset(col_sum,0,sizeof(col_sum));        memset(arr,0,sizeof(arr));                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                cin&gt;&gt;arr[i][j];                row_sum[i]+=arr[i][j];                col_sum[j]+=arr[i][j];            &#125;        &#125;        int rcnt = 0,ccnt = 0;        int rind = 0,cind = 0;                for(int i=1;i&lt;=n;i++)&#123;            if(row_sum[i]%2)&#123;                rcnt += 1;                rind = i;            &#125;            if(col_sum[i]%2)&#123;                ccnt += 1;                cind = i;            &#125;        &#125;        if(rcnt==0 &amp;&amp; ccnt==0)cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;        else if(rcnt==1 &amp;&amp; ccnt==1)cout&lt;&lt;&quot;Change bit (&quot;&lt;&lt;rind&lt;&lt;&quot;,&quot;&lt;&lt;cind&lt;&lt;&quot;)&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]最近點對問題","url":"/a165/","content":"a165. 最近點對問題\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 10002#define INF 5e18#define FOR(i,n) for(int i=0;i&lt;n;i++)#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;#define pdd pair&lt;double,double&gt;using namespace std;int n;vector&lt;pii&gt; p,temp;void init()&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(4);    temp.clear();    p.assign(n,&#123;0,0&#125;);&#125;bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125;double dis(pii a,pii b)&#123;    double x1 = a.x-b.x,y1 = a.y-b.y;    return sqrt(x1 * x1 + y1 * y1);&#125;//區間[l,r]double solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l+r)/2,mid_pos = p[mid].x;;    double ans = min(solve(l,mid),solve(mid+1,r));        temp.assign((r-l+1),&#123;0,0&#125;);    merge(        p.begin() + l, p.begin() + mid + 1,        p.begin() + mid + 1, p.begin() + r + 1,        temp.begin(), cmp    );    rep(i, l, r)p[i] = temp[i-l];    temp.clear();    rep(i, l, r)&#123;        if(abs(p[i].x - mid_pos) &lt;= ans)            temp.push_back(p[i]);    &#125;    int len = temp.size();    rep(i, 0, len-1)&#123;        rep(j, i+1, len-1)&#123;            ans = min(ans, dis(temp[i],temp[j]));            if(abs(temp[i].y-temp[j].y) &gt; ans)                break;        &#125;    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        init();        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        double ans = solve(0,n-1);        if(ans &gt; 10000)cout&lt;&lt;&quot;INFINITY&quot;&lt;&lt;endl;        else cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"[題解]團體佇列","url":"/a164/","content":"a164. 團體佇列\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int main()&#123;    ios;    int t,c=0;    while(cin&gt;&gt;t &amp;&amp; t)&#123;        c++;        map&lt;int,int&gt; mp;//[成員、團體編號]        for(int i=0;i&lt;t;i++)&#123;            int n;cin&gt;&gt;n;            while(n--)&#123;                int x;cin&gt;&gt;x;                mp[x] = i;            &#125;        &#125;        queue&lt;int&gt; Q,que[1005];//團體順序、團體內順序        cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;c&lt;&lt;endl;        string temp;                while(cin&gt;&gt;temp)&#123;            if(temp[0]==&#x27;E&#x27;)&#123;                int x;cin&gt;&gt;x;                if(que[mp[x]].empty())Q.push(mp[x]);                que[mp[x]].push(x);            &#125;            else if(temp[0]==&#x27;D&#x27;)&#123;                int team = Q.front();                cout&lt;&lt;que[team].front()&lt;&lt;endl;                que[team].pop();                if(que[team].empty())Q.pop();            &#125;            else if(temp[0]==&#x27;S&#x27;)&#123;                cout&lt;&lt;endl;                break;            &#125;        &#125;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","題解"]},{"title":"APCS CLASS PART 2","url":"/apcs2/","content":"APCS Class題目第二部分！\nG. [基礎資料結構 I ] 堆疊、佇列a119. 括號問題\n#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; stk;int main()&#123;    string s;    getline(cin,s);    int len = s.size(),ans = 0,f=1;    for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)stk.push(1);        else if(s[i]==&#x27;)&#x27;)&#123;            if(!stk.empty())&#123;                stk.pop();                ans++;            &#125;            else f = 0;        &#125;    &#125;    if(!stk.empty())f= 0;        if(f)cout&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;0&lt;&lt;endl;&#125;\na120. 中置式轉後置式#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;char,int&gt; mp&#123;&#123;&#x27;+&#x27;,1&#125;,&#123;&#x27;-&#x27;,1&#125;,&#123;&#x27;*&#x27;,2&#125;,&#123;&#x27;/&#x27;,2&#125;,&#123;&#x27;(&#x27;,0&#125;&#125;;    string s;cin&gt;&gt;s;    stack&lt;char&gt; st;    int len = s.size();        for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)st.push(&#x27;(&#x27;);        else if(s[i]==&#x27;)&#x27;)&#123;            while(!st.empty()&amp;&amp;st.top()!=&#x27;(&#x27;)&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.pop();        &#125;        else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;            while(!st.empty() &amp;&amp; mp[st.top()]&gt;=mp[s[i]])&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.push(s[i]);        &#125;        else cout&lt;&lt;s[i];    &#125;    while(!st.empty())&#123;        cout&lt;&lt;st.top();        st.pop();    &#125;    cout&lt;&lt;endl;&#125;\na121. 電腦算術運算#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    string s;    while(n--)&#123;        cin&gt;&gt;s;        stack&lt;int&gt; stk;        bool legal = 1;                for(int i=0;i&lt;s.size();i++)&#123;            if(s[i]==&#x27;)&#x27;||s[i]==&#x27;,&#x27;||s[i]==&#x27;(&#x27;);            else if(isdigit(s[i]))&#123;                int sum = s[i]-&#x27;0&#x27;;                while(isdigit(s[++i]))&#123;                    sum=sum*10+(s[i]-&#x27;0&#x27;);                &#125;                stk.push(sum);                i--;            &#125;            else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;                if(s[i+1]!=&#x27;)&#x27;)&#123;                    legal = 0;                    break;                &#125;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;&amp;&amp; a==0)&#123;                    legal = 0;                    break;                &#125;                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);            &#125;            else&#123;                legal = 0;                break;            &#125;        &#125;        if(legal==0)cout&lt;&lt;-1&lt;&lt;endl;        else if(stk.size()==1)cout&lt;&lt;stk.top()&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;    &#125;&#125;\na151. 後序式求值#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        stack&lt;int&gt; stk;        for(int i=0;i&lt;s.size();i++)&#123;            if(isdigit(s[i]))stk.push(s[i]-&#x27;0&#x27;);            else&#123;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);                else if(s[i]==&#x27;%&#x27;)stk.push(b%a);            &#125;        &#125;        cout&lt;&lt;stk.top()&lt;&lt;endl;    &#125;&#125;\na163. 印表機佇列#include &lt;bits/stdc++.h&gt;using namespace std;bool Can(int now_priority,int *p)&#123;    for(int i=now_priority+1;i&lt;=9;i++)&#123;        if(p[i]&gt;=1)return 0;    &#125;    return 1;&#125;void solve()&#123;    int n,m,pri[105];cin&gt;&gt;n&gt;&gt;m;    queue&lt;pair&lt;bool,int&gt;&gt; que;    memset(pri,0,sizeof(pri));    for(int i=0;i&lt;n;i++)&#123;        int p;cin&gt;&gt;p;        if(i==m)que.push(&#123;1,p&#125;);        else que.push(&#123;0,p&#125;);        pri[p]++;    &#125;        int ans = 0;    while(!que.empty())&#123;        auto cur = que.front();        que.pop();        if(Can(cur.second,pri))&#123;            //可以印的話            ans++;            pri[cur.second]--;            if(cur.first==1)break;        &#125;        else que.push(cur);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na164. 團體佇列#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int main()&#123;    ios;    int t,c=0;    while(cin&gt;&gt;t &amp;&amp; t)&#123;        c++;        map&lt;int,int&gt; mp;//[成員、團體編號]        for(int i=0;i&lt;t;i++)&#123;            int n;cin&gt;&gt;n;            while(n--)&#123;                int x;cin&gt;&gt;x;                mp[x] = i;            &#125;        &#125;        queue&lt;int&gt; Q,que[1005];//團體順序、團體內順序        cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;c&lt;&lt;endl;        string temp;                while(cin&gt;&gt;temp)&#123;            if(temp[0]==&#x27;E&#x27;)&#123;                int x;cin&gt;&gt;x;                if(que[mp[x]].empty())Q.push(mp[x]);                que[mp[x]].push(x);            &#125;            else if(temp[0]==&#x27;D&#x27;)&#123;                int team = Q.front();                cout&lt;&lt;que[team].front()&lt;&lt;endl;                que[team].pop();                if(que[team].empty())Q.pop();            &#125;            else if(temp[0]==&#x27;S&#x27;)&#123;                cout&lt;&lt;endl;                break;            &#125;        &#125;    &#125;&#125;\nH. [基礎資料結構 I ] 樹狀結構a076. 二元搜尋樹高度#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];bool used[3000];int main()&#123;    ios;    string s;    memset(used,0,sizeof(used));    memset(tree,0,sizeof(tree));        getline(cin,s);    stringstream ss(s);    int ans = 0,temp;    while(ss&gt;&gt;temp)&#123;        int cur = 1,height = 1;        while(used[cur])&#123;            if(temp&lt;tree[cur])cur = cur*2;            else cur = cur*2+1;            height++;        &#125;        tree[cur] = temp;        used[cur] = 1;        ans = max(ans,height);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na077. Dropping Balls#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];int drop(int id)&#123;    if(id&gt;=(1&lt;&lt;(n-1)))return id;        tree[id]=!tree[id];    if(!tree[id])return drop(2*id+1);    else return drop(2*id);&#125;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        int ans = 0;cin&gt;&gt;n&gt;&gt;m;        memset(tree,0,sizeof(tree));        for(int i=0;i&lt;m;i++)&#123;            ans = drop(1);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\na122. 血緣關係#include &lt;bits/stdc++.h&gt;#define N 100005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,start,dis[N];bool visit[N];vector&lt;int&gt;edge[N];int dfs(int id,int cur_dis)&#123;  //尋找點id的最遠點距離    if(visit[id])return 0;    visit[id] = 1;    int len = edge[id].size(),max_len=0;    for(int i=0;i&lt;len;i++)&#123;        int next = edge[id][i];        if(visit[next])continue;        dis[next] = cur_dis+1;        int temp = dfs(next,cur_dis+1);        max_len = max(max_len,temp);    &#125;    return max_len+1;&#125;int main()&#123;    ios;    cin&gt;&gt;n;    for(int i=0;i&lt;n-1;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    start = 0;    memset(visit,0,sizeof(visit));    int distance = dfs(2,0);distance--;    for(int i=0;i&lt;n;i++)&#123;        if(dis[i]==distance)&#123;            start = i;            break;        &#125;    &#125;    memset(visit,0,sizeof(visit));    cout&lt;&lt;dfs(start,0)-1&lt;&lt;endl;&#125;\na123. 樹狀圖分析#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,father[N],h[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    int maxn = 0;    for(auto next:edge[cur])&#123;        dfs(next);        maxn = max(maxn,h[next]+1);    &#125;    h[cur] = maxn;&#125;signed main()&#123;    ios;    memset(h,0,sizeof(h));    memset(father,0,sizeof(father));        cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int k;cin&gt;&gt;k;        for(int j=0;j&lt;k;j++)&#123;            int temp;cin&gt;&gt;temp;            edge[i].push_back(temp);            father[temp] = i;        &#125;    &#125;    int root = 1;    while(father[root]!=0)root++;        dfs(root);        lld ans = 0;    for(int i=1;i&lt;=n;i++)ans += h[i];        cout&lt;&lt;root&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl;&#125;//O(N)的作法#include &lt;bits/stdc++.h&gt;#define lld long longusing namespace std;lld n,m;int main()&#123;    int t;scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        int n,m,ans = 1;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        m--;    //從0開始        for(int i=1;i&lt;n;i++)&#123;         //共n-1步要走            if(m&amp;1)ans = ans*2+1;     //往右邊走            else ans = ans*2;            m = m&gt;&gt;1;                 //由低bit到高bit決定每一步要怎麼走        &#125;        printf(&quot;%lld\\n&quot;,ans);    &#125;&#125;\nI. [基礎資料結構 I ] 圖形結構a051. 城市旅遊#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 1000using namespace std;int n,m;bool visit[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    visit[cur] = 1;    for(auto i:edge[cur])&#123;        if(visit[i])continue;        dfs(i);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    for(int i=0;i&lt;=n+100;i++)edge[i].clear();        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);    &#125;    int from,to;cin&gt;&gt;from&gt;&gt;to;    dfs(from);    if(visit[to])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m)&#123;        solve();    &#125;&#125;\na102. 油田#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 105using namespace std;int n,m,ans = 0;int dx[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;;int dy[8] = &#123;1,0,-1,-1,-1,0,1,1&#125;;bool visit[N][N],maze[N][N];void dfs(int x,int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;8;i++)&#123;        int nx = x+dx[i],ny = y+dy[i];        if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;        if(visit[nx][ny])continue;        if(maze[nx][ny]==1)dfs(nx,ny);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    memset(maze,0,sizeof(maze));    ans = 0;        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;@&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                dfs(i,j);                ans+=1;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n&amp;&amp; m)&#123;        solve();    &#125;&#125;\na103. 小群體#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 50005using namespace std;signed main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];    &#125;    bool used[N];    int ans = 0;    memset(used,0,sizeof(used));        for(int i=0;i&lt;n;i++)&#123;        if(used[i])continue;        int cur = arr[i];        used[cur] = 1;        while(cur!=i)&#123;            cur = arr[cur];            used[cur] = 1;        &#125;        ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na124. 二分圖#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,m,ans = 0,cnt[2];vector&lt;int&gt; edge[N];int color[N];bool dfs(int cur,int c)&#123;    color[cur] = c;    cnt[c]+=1;    bool flag = 1;    for(auto i:edge[cur])&#123;        if(color[i]==color[cur])return 0;        if(color[i]==-1)flag = (flag &amp;&amp; dfs(i,!c));    &#125;    return flag;&#125;void solve()&#123;    memset(color,0,sizeof(color));        for(int i=0;i&lt;n;i++)color[i] = -1;        for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;a--;b--;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(color[i]==-1)&#123;            cnt[0] = 0;cnt[1] = 0;            if(!dfs(i,0))&#123;                cout&lt;&lt;0&lt;&lt;endl;                return;            &#125;            ans += min(cnt[0],cnt[1]);            //有可能是非連通圖，用+=        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    solve();&#125;\nJ. [基礎演算法 I ] 複雜度分析、排序a127. 連號或不連號#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int n;int main()&#123;    while(cin&gt;&gt;n)&#123;        set&lt;int&gt;s;        for(int i=0;i&lt;n;i++)&#123;            int x;cin&gt;&gt;x;            s.insert(x);        &#125;        int maxn = *(--s.end());        int minn = *s.begin();        if(s.size()==maxn-minn+1)cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; yes&quot;&lt;&lt;endl;        else cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; no&quot;&lt;&lt;endl;    &#125;&#125;\na128. Agar.io#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,full[N];set&lt;int&gt; s[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    fill(full,full+n+1,10);    for(int i=1;i&lt;=n;i++)s[i].insert(i);        while(m--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(full[b]&gt;full[a])swap(a,b);        full[a] += full[b];        full[b] = 0;        for(auto p:s[b])s[a].insert(p);        s[b].clear();    &#125;    int ans = max_element(full,full+n+1)-full;    cout&lt;&lt;ans&lt;&lt;endl;    for(auto p:s[ans])cout&lt;&lt;p&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\na129. 飛天桑妮#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;vector&lt;pii&gt; vec;bool cmp(pii a,pii b)&#123;    if(a.first==b.first)return a.second&gt;b.second;    return a.first&lt;b.first;&#125;int main()&#123;    int n,x,y,h;cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;h;        vec.push_back(&#123;x*x+y*y,h&#125;);    &#125;    sort(vec.begin(),vec.end(),cmp);    int ans  = 0,maxh = 0;    for(int i=0;i&lt;n;i++)&#123;        maxh = max(maxh,vec[i].second);        ans = max(ans,maxh-vec[i].second);    &#125;//維護最高的樹    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na148. 字元頻率#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;bool cmp(pii a,pii b)&#123;    if(a.second==b.second)return a.first&gt;b.first;    else return a.second&lt; b.second;&#125;int main()&#123;    string s;    while(getline(cin,s))&#123;        map&lt;int,int&gt; mp;    //asci、出現次數        for(auto temp:s)mp[temp]+=1;        vector&lt;pii&gt;vec;        for(auto p:mp)&#123;            vec.push_back(p);        &#125;        sort(vec.begin(),vec.end(),cmp);        for(auto i:vec)&#123;            cout&lt;&lt;i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second&lt;&lt;endl;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\nK. [基礎演算法 I ] 排序與搜尋a130. 人員調動#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    int wait[N][N];memset(wait,0,sizeof(wait));        int m,ans = 0;cin&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(wait[b][a]&gt;0)&#123;            ans++;wait[b][a]--;        &#125;        else wait[a][b]++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na131. 大黑馬#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int k,n;int normal[N][N],lower[N][N],upper[N][N];bool win(int a,int b,int is_normal)&#123;    for(int i=0;i&lt;k+1;i++)&#123;        if(is_normal==0)&#123;            if(normal[a][i]&lt;=normal[b][k+i])return 0;        &#125;        else&#123;            if(upper[a][i]&lt;=lower[b][k+i])return 0;        &#125;    &#125;    return 1;&#125;int main()&#123;    cin&gt;&gt;k&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int s;cin&gt;&gt;s;        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;normal[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;upper[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;lower[s][j];    &#125;    for(int p=0;p&lt;=1;p++)&#123;        for(int i=n;i&gt;0;i--)&#123;    //從種子序較小的開始            bool f = 1;            for(int j=1;j&lt;=n;j++)&#123;                if(!win(i,j,p))&#123;                    f = 0;                    break;                &#125;            &#125;            if(f)&#123;                cout&lt;&lt;i&lt;&lt;&quot; &quot;;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\na132. 主機排程#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define max_ele(a) max_element(a,a+dh)using namespace std;int n,dh;void solve()&#123;    int s;cin&gt;&gt;s;    int arr[N]=&#123;0&#125;,brr[N]=&#123;0&#125;,crr[N]=&#123;0&#125;;    while(s--)&#123;        int a,b,c,d,e,f;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;        int start = (a-1)*24+b;        for(int j=0;j&lt;c;j++)&#123;            arr[(start+j)%dh]+=d;            brr[(start+j)%dh]+=e;            crr[(start+j)%dh]+=f;        &#125;    &#125;    cout&lt;&lt;*max_ele(arr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(brr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(crr)&lt;&lt;endl;    cin&gt;&gt;s;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;dh;    dh = dh*24;    while(n--)&#123;        solve();    &#125;&#125;\na152. 二分搜尋#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int t;cin&gt;&gt;t;        int pos = 0,ans = 0,find = 0,l = 0,r = n-1;    //[l,r]        while(l&lt;=r)&#123;        int mid = (l+r)/2;        ans++;        if(arr[mid]==t)&#123;            pos = mid;find = 1;break;        &#125;        else if(arr[mid]&gt;t)r = mid-1;        else l = mid+1;    &#125;    if(find)cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;&quot;not found &quot;&lt;&lt;ans&lt;&lt;endl;&#125;\na153. 二分法求解#include &lt;bits/stdc++.h&gt;int main()&#123;  std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(6)&lt;&lt;log(2)&lt;&lt;std::endl;&#125;\nL. [基礎演算法 I ] 窮舉法a088. 最大乘積#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 20#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    int c = 0;    while(cin&gt;&gt;n)&#123;        c++;        int dp[N][N];memset(dp,0,sizeof(dp));        int ans = 0;        FOR(i,n)&#123;            int temp;cin&gt;&gt;temp;            dp[i][i] = temp;            ans = max(ans,temp);        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                dp[i][j] = dp[i][j-1]*dp[j][j];                ans = max(dp[i][j],ans);            &#125;        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;c&lt;&lt;&quot;: The maximum product is &quot;&lt;&lt;max(ans,(ll)0)&lt;&lt;&quot;.&quot;&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\na133. 採蘑菇攻略問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    cin&gt;&gt;n;    int ans = 0,dp[N][N];    memset(dp,0,sizeof(dp));        FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        dp[i][i] = temp;        ans = max(ans,temp);    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            dp[i][j] = dp[i][j-1]+dp[j][j];            ans = max(ans,dp[i][j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\na134. 回文日期問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;vector&lt;int&gt;ans;bool leap(int temp)&#123;    return (((temp%4)==0 &amp;&amp;(temp%100)!=0)||(temp%400)==0);&#125;void check(string s)&#123;    string temp = s;    reverse(temp.begin(),temp.end());    if(temp==s)ans.push_back(stoi(s));&#125;void solve()&#123;    cin&gt;&gt;n;    ans.clear();    int month[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    month[2]+=((leap(n))?1:0);    for(int i=1;i&lt;=12;i++)&#123;        for(int j=1;j&lt;=month[i];j++)&#123;            check(to_string(n)+to_string(i)+to_string(j));            if(i&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+to_string(j));            if(j&lt;10)check(to_string(n)+to_string(i)+&quot;0&quot;+to_string(j));            if(i&lt;10 &amp;&amp; j&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+&quot;0&quot;+to_string(j));        &#125;    &#125;    sort(ans.begin(),ans.end());    cout&lt;&lt;ans.size();    for(auto i:ans)cout&lt;&lt;&quot; &quot;&lt;&lt;i;    cout&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na135. 巧克力擺盒#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,k;int r[9],box[9];;bool cmp(vector&lt;int&gt; r)&#123;    for(int i=0;i&lt;9;i+=3)&#123;        if(r.size()==3)&#123;            if((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1])&amp;&amp;(r[2]&amp;box[i+2]))&#123;                return true;            &#125;            //對於這一行的指定是有滿足的，回傳正確（下一個要求繼續再呼叫一次）        &#125;        else if(((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1]))||((r[0]&amp;box[i+1])&amp;&amp;(r[1]&amp;box[i+2])))&#123;            return true;        &#125;    &#125;    return false;&#125;vector&lt;int&gt; rule;vector&lt;vector&lt;int&gt;&gt; rule_list;void solve()&#123;    for(int i=0;i&lt;9;i++)&#123;        int temp=1;temp = temp&lt;&lt;i;        r[i] = temp;        box[i] = temp;    &#125;    map&lt;string,int&gt; mp = &#123;        &#123;&quot;PS&quot;,r[0]&#125;,        &#123;&quot;PC&quot;,r[1]&#125;,        &#123;&quot;PT&quot;,r[2]&#125;,        &#123;&quot;P?&quot;,r[0]|r[1]|r[2]&#125;,        &#123;&quot;BS&quot;,r[3]&#125;,        &#123;&quot;BC&quot;,r[4]&#125;,        &#123;&quot;BT&quot;,r[5]&#125;,        &#123;&quot;B?&quot;,r[3]|r[4]|r[5]&#125;,        &#123;&quot;YS&quot;,r[6]&#125;,        &#123;&quot;YC&quot;,r[7]&#125;,        &#123;&quot;YT&quot;,r[8]&#125;,        &#123;&quot;Y?&quot;,r[6]|r[7]|r[8]&#125;,        &#123;&quot;?S&quot;,r[0]|r[3]|r[6]&#125;,        &#123;&quot;?C&quot;,r[1]|r[4]|r[7]&#125;,        &#123;&quot;?T&quot;,r[2]|r[5]|r[8]&#125;,        &#123;&quot;??&quot;,511&#125;,    &#125;;    cin&gt;&gt;n;    while(n--)&#123;        cin&gt;&gt;k;        rule.resize(k);        for(int i=0;i&lt;k;i++)&#123;            char temp[3];cin&gt;&gt;temp[0]&gt;&gt;temp[1];            rule[i] = (mp[temp]);        &#125;        rule_list.push_back(rule);    &#125;    int ans = 0;    do&#123;        ans += all_of(rule_list.begin(),rule_list.end(),cmp);            &#125;while(next_permutation(box,box+9));        cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\na154. 除法#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;bool used[10],f;bool check(int t)&#123;    bool cur_used[10]=&#123;0&#125;;    if(t&lt;10000&amp;&amp;used[0]==1)return 0;    else if(t&lt;10000)cur_used[0] = 1;        while(t&gt;0)&#123;        int d = t%10;        if(cur_used[d])return 0;        else if(used[d])return 0;        cur_used[d] = 1;        t /= 10;    &#125;    return 1;&#125;void dfs(int first,int id)&#123;    if(id&gt;=5)&#123;        if(first%n!=0)return;        int second = first/n;        if(second&lt;1234)return;        if(check(second))&#123;            f = 1;            cout&lt;&lt;first&lt;&lt;&quot; / &quot;;            if(second&lt;10000)cout&lt;&lt;0;            cout&lt;&lt;second&lt;&lt;&quot; = &quot;&lt;&lt;n&lt;&lt;endl;            return;        &#125;    &#125;    for(int i=0;i&lt;10;i++)&#123;        if(used[i])continue;        used[i] = 1;        dfs(first*10+i,id+1);        used[i] = 0;    &#125;&#125;void solve()&#123;    while(cin&gt;&gt;n)&#123;        if(n==0)return;        memset(used,0,sizeof(used));        f=0;        dfs(0,0);        if(f==0)cout&lt;&lt;&quot;There are no solutions for &quot;&lt;&lt;n&lt;&lt;&quot;.&quot;&lt;&lt;endl;        cout&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS檢定"],"tags":["APCS","競賽筆記"]},{"title":"[題解]APCS購買力","url":"/apcs2101-1/","content":"110/01 實作題第一題 購買力\nAPCS的第一題都是應該要秒殺的，也順利拿到100分\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,d,cost = 0,total = 0;signed main()&#123;     ios;    cin&gt;&gt;n&gt;&gt;d;    int arr[3];    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2];        sort(arr, arr+3);        if(arr[2]-arr[0]&gt;=d)&#123;            total++;            cost +=((arr[0]+arr[1]+arr[2])/3);        &#125;    &#125;    cout&lt;&lt;total&lt;&lt;&quot; &quot;&lt;&lt;cost&lt;&lt;endl;&#125;\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS流量","url":"/apcs2101-2/","content":"110/01 實作題第二題 流量\n這一題的題序有點複雜，看了幾次之後才看懂。但重點是在考試的時候沒有想到要怎麼合併流量，所以只用了一維陣列計算最小值，因此只有拿到50分…這是完整版的程式碼，主要是透過創建一個陣列r[i][j]，表示從城市i出發到城市j的總流量，再利用陣列r計算費用。\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int N,M,K,s[50][50],r[50][50];signed main()&#123;    ios;    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;    for(int i=0;i&lt;N;i++)&#123;        for(int j=0;j&lt;M;j++)&#123;            cin&gt;&gt;s[i][j];        &#125;    &#125;    int ans = 1e8;        for(int k=0;k&lt;K;k++)&#123;        memset(r, 0, sizeof(r));                for(int q=0;q&lt;N;q++)&#123;            int p;//第i個伺服器架設在p城市            cin&gt;&gt;p;            for(int j=0;j&lt;M;j++)r[p][j]+=s[q][j];        &#125;        //如果第0個跟第1個伺服器都架設在1的位置，則將流量相加，得到陣列r        int sum = 0;        for(int q=0;q&lt;M;q++)&#123;//0&lt;p&lt;M            for(int j=0;j&lt;M;j++)&#123;                if(q==j)sum+=r[q][j];                else if(r[q][j]&lt;=1000)sum+=3*r[q][j];                else sum+=(r[q][j]-1000)*2+3000;            &#125;        &#125;        ans = min(ans,sum);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"APCS CLASS PART 1","url":"/apcs1/","content":"這是2021年暑期APCS課程的所有題目參考解答，共有34題。\nA. [基礎程式設計] 基礎C++程式設計複習a064/ 成績指標\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;void solve()&#123;    int n,arr[25];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    cout&lt;&lt;arr[0];    for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;arr[i];    cout&lt;&lt;endl;        if(arr[0]&gt;=60)cout&lt;&lt;&quot;best case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60)-1)&lt;&lt;endl;        if(arr[n-1]&lt;60)cout&lt;&lt;&quot;worst case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60))&lt;&lt;endl;    &#125;signed main()&#123;    int t;    t = 1;//    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na096/ 時間差計算#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    int a1,b1,c1,a2,b2,c2;    scanf(&quot;%d:%d:%d&quot;,&amp;a1,&amp;b1,&amp;c1);    scanf(&quot;%d:%d:%d&quot;,&amp;a2,&amp;b2,&amp;c2);    int a = a1*3600+b1*60+c1,b = a2*3600+b2*60+c2;        if(b-a&gt;=0)&#123;        int temp = b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;    else&#123;        int temp = 86400+b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;&#125;\na104/ 雪花片片#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;int n,product[100];void solve()&#123;    memset(product,0,sizeof(product));    product[0] = 1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;80;j++)&#123;            product[j]=product[j]*4;        &#125;        for(int j=0;j&lt;80;j++)&#123;            if(product[j]&gt;=10)&#123;                product[j+1] += product[j]/10;                product[j] %=10;            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    product[0]-=1;    int temp=0;    for(int i=80;i&gt;=0;i--)&#123;        product[i] += temp*10;        temp = product[i]%3;        product[i] /= 3;    &#125;        int start = 80;    for(int i=80;i&gt;=0;i--)        if(product[i]!=0)&#123;            start = i;            break;        &#125;    for(int i=start;i&gt;=0;i--)cout&lt;&lt;product[i];    cout&lt;&lt;endl;&#125;\nB. [函式] 公用函式、自定函式a114/ 找出最小的完全平方數#include &lt;bits/stdc++.h&gt;#define ll long long#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;void solve()&#123;    int k;cin&gt;&gt;k;    int a = ceil(sqrt(pow(10,(k-1))));    for(int i=a;;i++)&#123;        string s = to_string(i*i);        int len = s.size(),flag = 0;        for(int i=0;i&lt;len;i++)&#123;            if((s[i]-&#x27;0&#x27;)%2!=0)&#123;                flag = 1;                break;            &#125;        &#125;        if(flag==0)&#123;            cout&lt;&lt;i*i&lt;&lt;endl;            break;        &#125;    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na115/ 賓果遊戲#include &lt;bits/stdc++.h&gt;//#define int ll//#define ll long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int maze[10][10],cur[10][10],n;    for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            cin&gt;&gt;maze[i][j];            cur[i][j] = maze[i][j];        &#125;    &#125;    while(cin&gt;&gt;n &amp;&amp; n!= -1)&#123;        for(int i=0;i&lt;5;i++)&#123;            for(int j=0;j&lt;5;j++)&#123;                if(maze[i][j]==n)maze[i][j] = 0;            &#125;        &#125;    &#125;        int ind = 1,num = -1;        for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            if(maze[i][j]!=0)&#123;                maze[i][j] = 0;                int k,ans = 0;                for(k=0;k&lt;5;k++)if(maze[k][j]!=0)break;                if(k==5)ans+=1;                for(k=0;k&lt;5;k++)if(maze[i][k]!=0)break;                if(k==5)ans+=1;                                if(i==j)&#123;                    for(k=0;k&lt;5;k++)if(maze[k][k]!=0)break;                    if(k==5)ans+=1;                &#125;                if(i+j==4)&#123;                    int x = 4,y = 0;                    for(k=0;k&lt;5;k++)&#123;                        if(maze[x][y]!=0)break;                        else&#123;                            x--;y++;                        &#125;                    &#125;                    if(k==5)ans++;                &#125;                if(ans&gt;num)&#123;                    num = ans;                    ind = cur[i][j];                &#125;                else if(ans==num &amp;&amp; ind&gt;cur[i][j])ind = cur[i][j];                maze[i][j] = cur[i][j];            &#125;        &#125;    &#125;    cout&lt;&lt;ind&lt;&lt;endl;&#125;signed main()&#123;    ios;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\na116/ 一起回家的日子#include &lt;bits/stdc++.h&gt;//#define ll long long//#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;int gcd(int a,int b)&#123;    if(a==b)return a;        if(a&lt;b)swap(a,b);    while(b!=0)&#123;        int c = a%b;        a = b;        b = c;    &#125;    return a;&#125;bool leap(int a)&#123;    if((a%100!=0||a%400==0)&amp;&amp;(a%4==0))return 1;    else return 0;&#125;void solve()&#123;    int n,arr[100];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int ans = arr[0];    for(int i=1;i&lt;n;i++)ans=(ans*arr[i])/gcd(ans,arr[i]);        int y,m,d;    scanf(&quot;%d/%d/%d&quot;,&amp;y,&amp;m,&amp;d);        int month[15] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    d+=ans;        while(d&gt;month[m])&#123;        d-=month[m];        if(m==12)&#123;            y++;            m = 1;        &#125;        else&#123;            if(leap(y)&amp;&amp;m==2)&#123;                d--;            &#125;            m++;        &#125;    &#125;    printf(&quot;%04d/%02d/%02d\\n&quot;,y,m,d);&#125;signed main()&#123;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nC. [函式] 遞迴函式a117/ 三色河內塔#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void move(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    move(n-1,by,to,from);&#125;void honai(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    honai(n-2,by,from,to);&#125;signed main()&#123;    ios;    int n;cin&gt;&gt;n;    t = 0;    honai(n,&#x27;A&#x27;,&#x27;C&#x27;,&#x27;B&#x27;);    cout&lt;&lt;&quot;共需&quot;&lt;&lt;t&lt;&lt;&quot;個移動&quot;&lt;&lt;endl;&#125;\na118/ 指數2^k的四個自然數平方和之所有表示法#include &lt;bits/stdc++.h&gt;#define N 64000#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int num[5],sqr[N];int solution = 0,n;void init()&#123;    for(int i=0;i&lt;N;i++)sqr[i] = i*i;&#125;void pick(int remain,int id)&#123;    if(id==4)&#123;        int r = sqrt(remain);        if(sqr[r]==remain)&#123;            cout&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;&quot; &quot;&lt;&lt;num[3]&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;            solution++;        &#125;        return;    &#125;    int lower = max(1,num[id-1]),upper = sqrt(remain/(5-id));        for(int i=lower;i&lt;=upper;i++)&#123;        num[id]= i;        pick(remain-sqr[i],id+1);    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    pick(1&lt;&lt;n,1);    if(solution==0)cout&lt;&lt;0&lt;&lt;endl;&#125;\na157/ 費波那契數列#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\na158/ F91#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\nD. [基本資料型態] 指標、多維陣列a105. 爺爺種樹#include &lt;bits/stdc++.h&gt;#define N 505#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n,m,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;    bool arr[N][N];    memset(arr,0,sizeof(arr));        while(t--)&#123;        int r1,r2,c1,c2;cin&gt;&gt;r1&gt;&gt;c1&gt;&gt;r2&gt;&gt;c2;        int dr = r2-r1,dc = c2-c1;        if(dr&gt;0)dr = 1;else dr = -1;        if(dc&gt;0)dc = 1;else dc = -1;                if(r1==r2)&#123;            for(int i=c1;i!=c2;i+=dc)arr[r1][i] = 1;            arr[r1][c2] = 1;        &#125;        else if(c1==c2)&#123;            for(int i=r1;i!=r2;i+=dr)arr[i][c1] = 1;            arr[r2][c1] = 1;        &#125;        else&#123;            for(int i=r1,j=c1;i!=r2;i+=dr,j+=dc)&#123;                arr[i][j] = 1;                arr[r2][c2] = 1;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(arr[i][j])ans+=1;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na106. 賓果遊戲#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;char name[N],line[N][10];pair&lt;int,int&gt; mp[N][N];bool check(int people,int number)&#123;    int r = mp[people][number].first,c = mp[people][number].second;    line[people][r]+=1;    line[people][c+4]+=1;    if(line[people][r]==4)return 1;    if(line[people][c+4]==4)return 1;        if(r+c==3)&#123;        line[people][8]+=1;        if(line[people][8]==4)return 1;    &#125;    if(r==c)&#123;        line[people][9]+=1;        if(line[people][9]==4)return 1;    &#125;    return 0;&#125;signed main()&#123;    ios;    int n;    char cha;    cin&gt;&gt;cha&gt;&gt;n;    memset(line,0,sizeof(line));        for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;name[i];        for(int j=0;j&lt;16;j++)&#123;            int temp;cin&gt;&gt;temp;            mp[i][temp].first = j/4;            mp[i][temp].second = j%4;        &#125;    &#125;    int cnt = 16,flag = 0;    cin&gt;&gt;cha;    while(cnt--)&#123;        int temp;cin&gt;&gt;temp;        cout&lt;&lt;temp&lt;&lt;&quot; &quot;;        for(int i=0;i&lt;n;i++)&#123;            if(check(i,temp))&#123;                cout&lt;&lt;name[i]&lt;&lt;&quot; &quot;;                flag = 1;            &#125;        &#125;        if(flag)break;    &#125;&#125;\na107. 加密解密#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;string a = &quot;abcdefghijklmnoprstuvwxyz&quot;;string b = &quot;EXAMPLBCDFGHIJKNORSTUVWYZ&quot;;signed main()&#123;    ios;    int n;string s;    cin&gt;&gt;n;cin.ignore();    getline(cin,s);    reverse(s.begin(),s.end());    string origin = b ,key = a;    if(s[0]&gt;=&#x27;a&#x27;&amp;&amp; s[0]&lt;=&#x27;z&#x27;)swap(origin,key);        for(int i=0;i&lt;n;i+=2)&#123;        int p1 = origin.find(s[i]),p2 = origin.find(s[i+1]);        cout&lt;&lt;key[5*(p1/5)+(p2%5)]&lt;&lt;key[5*(p2/5)+(p1%5)];    &#125;    cout&lt;&lt;endl;&#125;\na147/ 促銷活動#include &lt;iostream&gt;using namespace std;void discount(double &amp;a,double &amp;b)&#123;    if(a==b)&#123;        b = 0.5*b;    &#125;&#125;int main()&#123;    double p1, p2;    cout &lt;&lt; &quot;Original price:&quot; &lt;&lt; endl;    cin &gt;&gt; p1 &gt;&gt; p2;    discount(p1,p2);    cout &lt;&lt; &quot;Price after discount:&quot; &lt;&lt; endl;    cout &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; endl;    return 0;&#125;\na159/ 錯誤更正#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        int row_sum[N],col_sum[N],arr[N][N];        memset(row_sum,0,sizeof(row_sum));        memset(col_sum,0,sizeof(col_sum));        memset(arr,0,sizeof(arr));                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                cin&gt;&gt;arr[i][j];                row_sum[i]+=arr[i][j];                col_sum[j]+=arr[i][j];            &#125;        &#125;        int rcnt = 0,ccnt = 0;        int rind = 0,cind = 0;                for(int i=1;i&lt;=n;i++)&#123;            if(row_sum[i]%2)&#123;                rcnt += 1;                rind = i;            &#125;            if(col_sum[i]%2)&#123;                ccnt += 1;                cind = i;            &#125;        &#125;        if(rcnt==0 &amp;&amp; ccnt==0)cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;        else if(rcnt==1 &amp;&amp; ccnt==1)cout&lt;&lt;&quot;Change bit (&quot;&lt;&lt;rind&lt;&lt;&quot;,&quot;&lt;&lt;cind&lt;&lt;&quot;)&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl;    &#125;&#125;\nE. [基本資料型態] 字串a065. 秘密差#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        int ans = 0,len = s.size(),p=1;        for(int i=0;i&lt;len;i++)&#123;            ans+=(s[i]-&#x27;0&#x27;)*p;            p *=-1;        &#125;        cout&lt;&lt;abs(ans)&lt;&lt;endl;    &#125;&#125;\na067. ROT13#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    string s;    getline(cin,s);    for(auto p:s)&#123;        if(isalpha(p))&#123;            if(isupper(p))                cout&lt;&lt;(char)((p-&#x27;A&#x27;+13)%26+&#x27;A&#x27;);            else                cout&lt;&lt;(char)((p-&#x27;a&#x27;+13)%26+&#x27;a&#x27;);        &#125;        else&#123;            cout&lt;&lt;p;        &#125;    &#125;&#125;\na108. 計算字串間隔距離#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//地點、動物名、數量int main()&#123;    string s;    char ch;    cin&gt;&gt;s&gt;&gt;ch;    ch = tolower(ch);    int len = s.size(),a1;    for(int i=0;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a1 = i;            break;        &#125;    &#125;    int a2;    for(int i=a1+1;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a2 = i;            cout&lt;&lt;a2-a1&lt;&lt;&quot; &quot;;            a1 = a2;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\na109. 跑長編碼與資料壓縮#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    int n,origin,after,times;    string s,t,binary[8]=&#123;&quot;000&quot;,&quot;001&quot;,&quot;010&quot;,&quot;011&quot;,&quot;100&quot;,&quot;101&quot;,&quot;110&quot;,&quot;111&quot;&#125;;    char ch;    cin&gt;&gt;n;    cin.ignore();    while(n--)&#123;        getline(cin,s);        t=&quot;&quot;;        origin = s.size();        after = 0;        ch = s[0];        times = 1;        int len = s.size();        for(int i=1;i&lt;=len;i++)&#123;            if(i!=len &amp;&amp; s[i]!=&#x27;0&#x27;&amp;&amp;s[i]!=&#x27;1&#x27;)&#123;                after = -1;                break;            &#125;            if(s[i]!=ch)&#123;                t+=ch;                t+=binary[times];                t+=&quot; &quot;;                times=1;                ch = s[i];                after+=4;            &#125;            else&#123;                times++;                if(times==7)&#123;                    t+=ch;                    t+=binary[7];                    t+=&quot; &quot;;                    times=1;                    after +=4;                    ch = s[i+1];                    i++;                &#125;            &#125;        &#125;        if(after==-1)cout&lt;&lt;after&lt;&lt;endl;        else cout&lt;&lt;t&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;(double)after*100/origin&lt;&lt;&quot;%&quot;&lt;&lt;endl;    &#125;&#125;\na110. 棒球遊戲#include &lt;bits/stdc++.h&gt;using namespace std;int num_of_out,d[3] = &#123;0&#125;;int transfer(string a)&#123;    if(a==&quot;SO&quot;||a==&quot;FO&quot;||a==&quot;GO&quot;)return 0;    else if(a==&quot;1B&quot;)return 1;    else if(a==&quot;2B&quot;)return 2;    else if(a==&quot;3B&quot;)return 3;    else return 4;&#125;int win(int c)&#123;    int s = 0;    if(c!=4)&#123;        for(int i=0;i&lt;c;i++)&#123;            if(d[2-i])s++;        &#125;        for(int i=0;i&lt;3-c;i++)&#123;            d[2-i] = d[2-c-i];        &#125;    &#125;    if(c==4)&#123;        for(int i=0;i&lt;3;i++)if(d[i])s++;        s++;    &#125;    else d[c-1] = 1;    for(int i=0;i&lt;c-1;i++)d[i] = 0;    return s;&#125;int main()&#123;    int data[9][5];    for(int i=0;i&lt;9;i++)&#123;        int temp;        cin&gt;&gt;temp;        for(int k=0;k&lt;temp;k++)&#123;            string a;            cin&gt;&gt;a;            data[i][k] = transfer(a);        &#125;    &#125;    cin&gt;&gt;num_of_out;    int now_out = 0,ans = 0;    for(int k=0;k&lt;5;k++)&#123;        for(int i=0;i&lt;9;i++)&#123;            if(now_out&gt;=num_of_out)break;            if(data[i][k])&#123;                ans+=win(data[i][k]);            &#125;            else&#123;                now_out++;                if(now_out%3==0)&#123;                    for(int i =0;i&lt;3;i++)d[i] = 0;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nF. [基本資料型態] 結構a111. 排隊#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    int t[1005][3],line=0,ans=0,cur=0;        cin&gt;&gt;t[0][0]&gt;&gt;t[0][1];    t[0][2] = t[0][0]+t[0][1];    for(int i=1;i&lt;n;i++)&#123;        cin&gt;&gt;t[i][0]&gt;&gt;t[i][1];        if(t[i][0]&lt;t[i-1][2])t[i][2] = t[i-1][2]+t[i][1];        else t[i][2] = t[i][0]+t[i][1];                if(t[i][0]&gt;=t[cur][2])&#123;            ans = max(ans,line);            while(t[i][0]&gt;=t[cur][2])&#123;                if(cur==i)break;                line--;                cur++;            &#125;        &#125;        if(t[i][0]&lt;t[cur][2])line++;    &#125;    ans = max(ans,line);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na112. 動物數量統計#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//地點、動物名、數量int main()&#123;    int n;cin&gt;&gt;n;    vector&lt;string&gt; p;    while(n--)&#123;        string animal,pos;        int qu,ind;        cin&gt;&gt;animal&gt;&gt;qu&gt;&gt;pos;        ind = find(p.begin(),p.end(),pos)-p.begin();        if(ind==p.size())p.push_back(pos);        mp[pos].push(&#123;animal,qu&#125;);    &#125;    for(auto i:p)&#123;        cout&lt;&lt;i&lt;&lt;&quot;:&quot;;        map&lt;string,int&gt; sta;        vector&lt;string&gt; almp;        while(!mp[i].empty())&#123;            string an = mp[i].front().first;            int qu = mp[i].front().second;            mp[i].pop();            int ind = find(almp.begin(),almp.end(),an)-almp.begin();            if(ind==almp.size())almp.push_back(an);            sta[an]+=qu;        &#125;        bool c = 0;        for(auto j:almp)&#123;            if(c)cout&lt;&lt;&quot;,&quot;;            cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;sta[j];            c = 1;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\na113. 99遊戲#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int,queue&lt;string&gt;&gt; mp;int main()&#123;    for(int i=0;i&lt;4;i++)&#123;        char ch;cin&gt;&gt;ch;        for(int j=0;j&lt;13;j++)&#123;            string s;cin&gt;&gt;s;            mp[ch-&#x27;A&#x27;].push(s);        &#125;    &#125;    int id = 0,dir=1,sum=0;    while(sum&lt;=99)&#123;        string card = mp[id].front();        if(card==&quot;A&quot;)sum=0;        else if(card==&quot;4&quot;)dir*=-1;        else if(card==&quot;5&quot;);        else if(card==&quot;10&quot;)&#123;            sum+=10;            if(sum&gt;99)sum-=20;        &#125;        else if(card==&quot;J&quot;);        else if(card==&quot;Q&quot;)&#123;            sum+=20;            if(sum&gt;99)sum-=40;        &#125;        else if(card==&quot;K&quot;)sum=99;        else&#123;            sum+=(card[0]-&#x27;0&#x27;);            if(sum&gt;99)&#123;                cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;mp[id].size()-1&lt;&lt;endl;                break;            &#125;        &#125;        mp[id].pop();        if(mp[id].empty())&#123;            cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;            break;        &#125;        id = (id+dir+4)%4;//        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\na150. 多邊形面積#include &lt;bits/stdc++.h&gt;using namespace std;struct point&#123;    double x;    double y;&#125;;int main()&#123;    int n;    cin&gt;&gt;n;    point p[n];        for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    double a = 0.0;    for(int i=0;i&lt;n;i++)&#123;        if(i==n-1)&#123;            a+=(p[i].x)*(p[0].y)-(p[0].x)*(p[i].y);        &#125;        else&#123;            a+=(p[i].x)*(p[i+1].y)-(p[i+1].x)*(p[i].y);        &#125;    &#125;    a = abs(a/2);    cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;&#125;\n","categories":["APCS檢定"],"tags":["APCS","競賽筆記"]},{"title":"[題解]APCS切割費用","url":"/apcs2101-3/","content":"110/01 實作題第三題 切割費用\n這一題雖然在考試中有想到利用二元樹的方法，於是開了一個陣列儲存樹的節點（前段時間寫了一些線段樹，所以用了這個方法！）但我沒有注意到這不是一棵完滿二元樹，不會平衡啊！把範例測資丟上去對了，結果半分都沒有拿到:cry:，以後必須注意！用std::set搭配 next(),prev() 指標，找出鄰近的切割點之差，就可以AC了！\n\n            在 set 中使用insert() 函式會回傳pair 在使用的時候要變成：auto pos = s.insert(arr[i]).first;\n          \n這是考試送出的0分程式碼\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,L,ans = 0;int seg[1000000] = &#123;0&#125;;void build(int val,int cur)&#123;    if(seg[cur]==0)&#123;        seg[cur] = val;        return;    &#125;    if(val&gt;seg[cur])build(val, 2*cur+2);    else build(val, 2*cur+1);&#125;//建立一個會爆掉的二元樹void func(int val,int cur)&#123;    int up = L,low = 0;    if(seg[cur]==val)&#123;        ans+=up-low;        return;    &#125;    while(seg[cur]!=val)&#123;        if(val&gt;seg[cur])&#123;            low = seg[cur];            cur = 2*cur+2;        &#125;        else&#123;            up = seg[cur];            cur = 2*cur+1;        &#125;    &#125;    ans+=up-low;&#125;signed main()&#123;    ios;        cin&gt;&gt;n&gt;&gt;L;    int arr[n];    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        arr[b-1] = a;    &#125;    for(int i=0;i&lt;n;i++)build(arr[i], 0);    for(int i=0;i&lt;n;i++)func(arr[i], 0);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n這是正解：\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,l,arr[200000];signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;l;    set&lt;int&gt; s = &#123;0,l&#125;;    for(int i=0;i&lt;n;i++)&#123;        int ind,pos;cin&gt;&gt;pos&gt;&gt;ind;        arr[ind-1] = pos;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        auto pos = s.insert(arr[i]).first;        ans+= *next(pos)- *prev(pos);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS飛黃騰達","url":"/apcs2101-4/","content":"110/01 實作題第四題 飛黃騰達\n這是一題我在考試中根本沒有碰的題目（能力不足），聽到別人是說這是一題經典的LIS，所以寒假就開始了解動態規劃的題目。這一題關鍵是先把x座標排列好（可以想成是LIS中的數列順序），然後依照y座標做LIS。\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios;    cin&gt;&gt;n;    pair&lt;int, int&gt; P[n];    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        P[i] = make_pair(x, y);    &#125;    sort(P, P+n);//利用pair排序，會先依照x排序，如果x相同，則照y排序    vector&lt;int&gt;ans;//儲存LIS    ans.push_back(P[0].second);    for(int i=1;i&lt;n;i++)&#123;        int now = P[i].second;        if(now&gt;=ans.back())ans.push_back(now);        else&#123;            int ind = upper_bound(ans.begin(),ans.end(),now)-ans.begin();            ans[ind] = now;        &#125;    &#125;    cout&lt;&lt;ans.size()&lt;&lt;endl;&#125;\n\n            這裡有一點跟LIS不一樣，它不需要嚴格遞增，因此在第20使用 &gt;= ，還有第22行使用upper_bound也是因為不需要嚴格遞增（如果要插入的值在LIS裡面就已經有了，兩者都可以保留，所以用upper_bound，取第一個大於它的數值更改掉。\n          \n\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS七言對聯","url":"/apcs2109-1/","content":"P1 七言對聯\n題目連結\n總共有ABC三種規則，就每一種都比對一次就可以了！\n時間複雜度： 共有 $n$ 組對聯，每一組都 $O(1)$ 檢查，時間 $O(n)$ 。（不過n最大也才50，不論什麼複雜度都可以吧）\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 50#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;bool a[N],b[N],f = 1;signed main()&#123;    Orz;    cin&gt;&gt;n;    while(n--)&#123;        rep(i,1,7)cin&gt;&gt;a[i];        rep(i,1,7)cin&gt;&gt;b[i];        f = 1;        if(a[2]==a[4]||a[2]!=a[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        else if(b[2]==b[4]||b[2]!=b[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        if(a[7]!=1 || b[7]!=0)&#123;                cout&lt;&lt;&quot;B&quot;;f = 0;        &#125;        if(a[2]==b[2]||a[4]==b[4]||a[6]==b[6])&#123;                cout&lt;&lt;&quot;C&quot;;f = 0;        &#125;        if(f)cout&lt;&lt;&quot;None&quot;&lt;&lt;endl;        else cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS魔王迷宮","url":"/apcs2109-2/","content":"P2 魔王迷宮\n題目連結\n這一題我好像太早寫了，題目還在整修階段，丟上去TLE，發現題目敘述又改了XD，從魔王踩到炸彈爆炸後，「炸彈不會消失」，到「炸彈會消失」，還有範測也有改變。\n這一題是去模擬每一個魔王移動的狀況，要特別注意每一輪的國王是同時移動的，沒有先後順序，也就是說一顆炸彈可以炸掉不只一位魔王，如果有多個魔王移動到同一個格子，則他們會一起被炸掉。\n時間複雜度： 有點難估計，因為很難確定每一個魔王的移動狀況次數，不過由於數字範圍不大，且 $k$ 只有到500，因此直接做複雜度是可行的。\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,k;bool maze[N][N],bomb[N][N];struct node&#123;    int x,y,s,t;    bool alive;&#125;mp[505];signed main()&#123;    Orz;    memset(maze,0,sizeof(maze));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    rep(i,0,k-1)&#123;        cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y;        cin&gt;&gt;mp[i].s&gt;&gt;mp[i].t;        mp[i].alive = 1;    &#125;        int now_alive = k;    while(now_alive)&#123;        memset(bomb,0,sizeof(bomb));        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            maze[i][j] = 1;        &#125;        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            int nx = i + mp[p].s;            int ny = j + mp[p].t;            if(nx &gt;= n || nx &lt; 0 || ny &gt;= m ||ny &lt; 0)&#123;                now_alive--;                mp[p].alive = 0;            &#125;            else if(maze[nx][ny])&#123;                now_alive--;                mp[p].alive = 0;                bomb[nx][ny] = 1;            &#125;            else&#123;                mp[p].x = nx;                mp[p].y = ny;            &#125;        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                if(bomb[i][j] == 1)                    maze[i][j] = 0;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            if(maze[i][j])ans++;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS幸運數字","url":"/apcs2109-3/","content":"P3 幸運數字\n題目連結\n以區間最小值作為區分點將數列分成兩半，可以利用線段樹找區間最小值，利用迴圈模擬每一次範圍縮小的情況。\n不過這一題比較特別，他的區間範圍一定會越來越小，且區間外的數字也就不需要使用到，因此可以將數列做一次排序，從頭開始找如果遇上區間外的數字則不理他，否則使用它當作區間的分隔點（這一定會是最小值，因為由小到大排序），將區間範圍縮小。\n至於挑選左右區間的區間和，則可以透過前綴和 $O(1)$ 算出答案。\n時間複雜度： 如果是一個遞增或遞減的序列，則每一次區間大小只會縮減1，此時複雜度為 $O(n)$，加上最一開始的排序是 $O(n\\log n)$，總共為 $O(n\\log n)$。\n排序作法#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii sorted[N];signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;sorted[i-1].x;        arr[i] = sorted[i-1].x;        sorted[i-1].y = i;        pref[i] = pref[i-1]+arr[i];    &#125;    sort(sorted,sorted+n);    int ind = 0,l = 1,r = n;    while(r&gt;l)&#123;        while(sorted[ind].y &gt; r || sorted[ind].y &lt; l)ind++;        int left = pref[sorted[ind].y-1]-pref[l-1];        int right = pref[r]-pref[sorted[ind].y];        if(left &gt; right)&#123;            r = sorted[ind].y-1;        &#125;        else&#123;            l = sorted[ind].y+1;        &#125;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;endl;&#125;\n線段樹作法如果用線段樹實作，尋找區間最小值，可以在 $O(\\log n)$ 的時間內詢問。在最差的情況下，一共會詢問 $n$ 次，因此總時間複雜度一樣是 $O(n\\log n)$。實作上也不複雜，建立線段樹以及區間詢問，區間修改和懶標之類的東西。可以比較一下時間：\n\n線段樹的表現稍微好一點，不過其實是相當接近的！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii seg[4*N];//建立線段樹[l,r)void build(int cur,int l,int r)&#123;    if(r &lt;= l)return;    if(r - l &lt;= 1)&#123;        seg[cur] = &#123;arr[l],l&#125;;        return;    &#125;    int mid = (l+r)/2;    build(2*cur,l,mid);    build(2*cur+1,mid,r);    if(seg[2*cur].x &lt; seg[2*cur+1].x)        seg[cur] = seg[2*cur];    else        seg[cur] = seg[2*cur+1];&#125;//詢問區間最小值，回傳pairpii query(int cur,int l,int r,int ql,int qr)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return &#123;INT_MAX,INT_MAX&#125;;    if(ql &lt;= l &amp;&amp; qr &gt;= r)return seg[cur];    int mid = (l+r)/2;    pii lft = query(2*cur,l,mid,ql,qr);    pii rgt = query(2*cur+1,mid,r,ql,qr);    if(lft.x &lt; rgt.x)return lft;    return rgt;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    build(1,1,n+1);    int l = 1,r = n+1;        while(r - l &gt; 1)&#123;        int ind = query(1,1,n+1,l,r).y;        int left = pref[ind-1] - pref[l-1];        int right = pref[r-1] - pref[ind];        if(left &gt; right)r = ind;        else l = ind + 1;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;&quot;\\n&quot;;&#125;\n歐恩作法\nBY thanksone\n\n有一種二元樹，我也不知道叫啥，根為全序列最小值，左節點為左邊序列最小值，右節點為右邊序列最小值。\n建法紀錄每個位置左、右邊離自己最近、比自己小的，爸爸就是兩個之中比較大的那一個。\n時間複雜度： 種樹加跑答案總共 $O(n)$\n#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define ff first#define ss secondusing namespace std;array&lt;int, 300004&gt; A, S, L, R;array&lt;pii, 300004&gt; tree;void plant(int n)&#123;    for(int i = 1; i &lt;= n; i++)&#123;        if(A[L[i]] &gt; A[R[i]]) tree[L[i]].ss = i;        else tree[R[i]].ff = i;    &#125;&#125;int solve(int l, int r, int m)&#123;    if(l == r) return A[l];    if(S[m - 1] - S[l - 1] &gt; S[r] - S[m]) return solve(l, m - 1, tree[m].ff);    else return solve(m + 1, r, tree[m].ss);&#125;signed main()&#123;    int n;    cin &gt;&gt; n;    stack&lt;pii&gt; s;    pii m = &#123;1e9, 0&#125;;    s.push(&#123;0, 0&#125;);    for(int i = 1; i &lt;= n; i++)&#123;        cin &gt;&gt; A[i];        if(A[i] &lt; m.ff) m = &#123;A[i], i&#125;;        S[i] = A[i] + S[i - 1];        while(A[i] &lt; s.top().ff)&#123;            R[s.top().ss] = i;            s.pop();        &#125;        L[i] = s.top().ss;        s.push(&#123;A[i], i&#125;);    &#125;    plant(n);    cout &lt;&lt; solve(1, n, m.ss);    return 0;&#125;\n如果把範測的笛卡爾樹具象化，大概長這樣：\n\n83 9 4 5 1 6 2 8\n\n\n大致步驟就是：\n\n用單調隊列建立函數 $L$ 以及 $R$，表示往左往右看第一個小於自己的數\n建立笛卡爾樹（$L[i],R[i]$ 挑大的作為父節點）\n從根節點開始走訪，左右節點就會分別是左右區間的最小值\n利用前綴和計算區間大小，決定要走左還是右子樹\n走訪到區間長度為 $1$ 時即答案！\n\n\n            總共有三個不同的作法，使用到排序、線段樹、笛卡兒樹的作法。其中，他們的間複雜度分別是 $O(n\\log n)$、$O(n\\log n)$、$O(n)$。排序作法：AC (0.1s, 9.5MB)線段樹作法：AC (84ms, 20.9MB)歐恩作法：AC (82ms, 15.6MB)在笛卡兒樹的作法中，對每一個數字尋找兩側第一個小於它的數字（這可以用單調隊列完成），之後把每一個數字的父親節點設為找到的兩端數字中較大的那一個。此作法的概念是，假設序列中第 $i$ 個數字找到兩側數字分別是 $l_i$ 以及 $r_i$，當他如果是區間最小時，區間必須在 $[l_i+1:r_i-1]$ 之中，否則它就不會是最小值了。至於為何是選擇 $max(A[l_i],A[r_i])$ 當做父節點？則是因為如果選擇較小的那一個，在縮小區間範圍後，無法確定另外一個是否在區間外，如果包含區間內，則 $A[i]$ 便不會是最小值，違反了定義。換言之，選擇了較大的那一個當作父節點，按照定義當走到這個父節點時，它是區間的最小值，將它排除之後，$A[i]$ 就會是下一個區間的最小值！\n          \n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"APCS題解：2021年1月","url":"/apcs2101/","content":"第一次考APCS，拿到觀念4級、實作3級，希望在下一次可以更進步！（我是大廢廢\n110/01 實作題第一題 購買力APCS的第一題都是應該要秒殺的，也順利拿到100分\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,d,cost = 0,total = 0;signed main()&#123;     ios;    cin&gt;&gt;n&gt;&gt;d;    int arr[3];    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2];        sort(arr, arr+3);        if(arr[2]-arr[0]&gt;=d)&#123;            total++;            cost +=((arr[0]+arr[1]+arr[2])/3);        &#125;    &#125;    cout&lt;&lt;total&lt;&lt;&quot; &quot;&lt;&lt;cost&lt;&lt;endl;&#125;\n110/01 實作題第二題 流量這一題的題序有點複雜，看了幾次之後才看懂。但重點是在考試的時候沒有想到要怎麼合併流量，所以只用了一維陣列計算最小值，因此只有拿到50分…這是完整版的程式碼，主要是透過創建一個陣列r[i][j]，表示從城市i出發到城市j的總流量，再利用陣列r計算費用。\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int N,M,K,s[50][50],r[50][50];signed main()&#123;    ios;    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;    for(int i=0;i&lt;N;i++)&#123;        for(int j=0;j&lt;M;j++)&#123;            cin&gt;&gt;s[i][j];        &#125;    &#125;    int ans = 1e8;        for(int k=0;k&lt;K;k++)&#123;        memset(r, 0, sizeof(r));                for(int q=0;q&lt;N;q++)&#123;            int p;//第i個伺服器架設在p城市            cin&gt;&gt;p;            for(int j=0;j&lt;M;j++)r[p][j]+=s[q][j];        &#125;        //如果第0個跟第1個伺服器都架設在1的位置，則將流量相加，得到陣列r        int sum = 0;        for(int q=0;q&lt;M;q++)&#123;//0&lt;p&lt;M            for(int j=0;j&lt;M;j++)&#123;                if(q==j)sum+=r[q][j];                else if(r[q][j]&lt;=1000)sum+=3*r[q][j];                else sum+=(r[q][j]-1000)*2+3000;            &#125;        &#125;        ans = min(ans,sum);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n110/01 實作題第三題 切割費用這一題雖然在考試中有想到利用二元樹的方法，於是開了一個陣列儲存樹的節點（前段時間寫了一些線段樹，所以用了這個方法！）但我沒有注意到這不是一棵完滿二元樹，不會平衡啊！把範例測資丟上去對了，結果半分都沒有拿到:cry:，以後必須注意！用std::set搭配 next(),prev() 指標，找出鄰近的切割點之差，就可以AC了！\n\n            在 set 中使用insert() 函式會回傳pair 在使用的時候要變成：auto pos = s.insert(arr[i]).first;\n          \n這是考試送出的0分程式碼\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,L,ans = 0;int seg[1000000] = &#123;0&#125;;void build(int val,int cur)&#123;    if(seg[cur]==0)&#123;        seg[cur] = val;        return;    &#125;    if(val&gt;seg[cur])build(val, 2*cur+2);    else build(val, 2*cur+1);&#125;//建立一個會爆掉的二元樹void func(int val,int cur)&#123;    int up = L,low = 0;    if(seg[cur]==val)&#123;        ans+=up-low;        return;    &#125;    while(seg[cur]!=val)&#123;        if(val&gt;seg[cur])&#123;            low = seg[cur];            cur = 2*cur+2;        &#125;        else&#123;            up = seg[cur];            cur = 2*cur+1;        &#125;    &#125;    ans+=up-low;&#125;signed main()&#123;    ios;        cin&gt;&gt;n&gt;&gt;L;    int arr[n];    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        arr[b-1] = a;    &#125;    for(int i=0;i&lt;n;i++)build(arr[i], 0);    for(int i=0;i&lt;n;i++)func(arr[i], 0);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n這是正解：\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,l,arr[200000];signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;l;    set&lt;int&gt; s = &#123;0,l&#125;;    for(int i=0;i&lt;n;i++)&#123;        int ind,pos;cin&gt;&gt;pos&gt;&gt;ind;        arr[ind-1] = pos;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        auto pos = s.insert(arr[i]).first;        ans+= *next(pos)- *prev(pos);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n110/01 實作題第四題 飛黃騰達這是一題我在考試中根本沒有碰的題目（能力不足），聽到別人是說這是一題經典的LIS，所以寒假就開始了解動態規劃的題目。這一題關鍵是先把x座標排列好（可以想成是LIS中的數列順序），然後依照y座標做LIS。\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios;    cin&gt;&gt;n;    pair&lt;int, int&gt; P[n];    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        P[i] = make_pair(x, y);    &#125;    sort(P, P+n);//利用pair排序，會先依照x排序，如果x相同，則照y排序    vector&lt;int&gt;ans;//儲存LIS    ans.push_back(P[0].second);    for(int i=1;i&lt;n;i++)&#123;        int now = P[i].second;        if(now&gt;=ans.back())ans.push_back(now);        else&#123;            int ind = upper_bound(ans.begin(),ans.end(),now)-ans.begin();            ans[ind] = now;        &#125;    &#125;    cout&lt;&lt;ans.size()&lt;&lt;endl;&#125;\n\n            這裡有一點跟LIS不一樣，它不需要嚴格遞增，因此在第20使用 &gt;= ，還有第22行使用upper_bound也是因為不需要嚴格遞增（如果要插入的值在LIS裡面就已經有了，兩者都可以保留，所以用upper_bound，取第一個大於它的數值更改掉。\n          \n\n心得第一次參加APCS拿到4,3的成績，雖然沒有很好（這一次還是比較簡單的題目！），但還是在預期之內。希望透果補足一些不足的地方，下一次會有更好的成績！\n\nIDE環境不熟悉 平常都是在mac上打程式，而所有的比賽都只有windows的codeblocks，有時候debug的內容不小被我關掉就叫不出來，耗費許多時間。 解決方法：下載codeblocks來好好熟悉一下\n題目練習不夠多在考試之前大多是聽別人講怎麼做，實際練習題目的量太少，所以在實際的競賽中就寫不出東西。解決方法：每週固定寫一個主題的題目，反覆練習讓自己對這個主題更熟悉+寫APCS考古題。\n懂得東西太少 本次第三題就是很好的例子，自己寫二元樹出一堆問題，不如用std內建的set還比較快！雖然一直都知道set的存在，但實際的競賽中就不知道怎麼用。 解決方法：資訊之芽好好學！\n實戰經驗不足 這應該是參加過的第三場正式的競賽（或檢定），以後就慢慢累積比賽的經驗 解決方法：參加線上程式競賽，練手感。\n打字速度太慢 打字速度慢就拖慢整體的寫扣時間，必須加強！ 解決方法：每天花10分鐘碰碰鍵盤，利用網路上打字練習加快打字速度。\n\n","categories":["APCS檢定"],"tags":["APCS","競賽筆記"]},{"title":"[題解]APCS美食博覽會","url":"/apcs2109-4/","content":"P4 美食博覽會\n題目連結\n對於序列中k個連續的區間，每一個區間滿足區間內的元素皆不重複，區間範圍可以重疊（不過重疊部分只會算一次），找出這k個連續區間所能覆蓋到的最大長度。\n感覺跟背包問題的概念有點像，n個物品可以對應到k個區間，重量則對應到這裡的序列中的數字。這題用DP解。\n定義定義 $dp[i][j]$ 為 $i$ 個試吃員，看了前 $j$ 個攤位，最多可以吃到幾個攤位。\n轉移式維護一個函數 $f[i]$ 表示如果試吃員吃了第 $i$ 個攤位的美食，他所能吃到最左端的攤位的索引值。也就是說，試吃員可以吃 $f[i]$ 到 $i$ 攤位的美食。\ndp[i][j] = max(dp[i][j-1],dp[i-1][f[j]-1]+j-f[j]+1)轉移式代表了要使用第 $i$ 的攤位作為右端點，或是不要使用（直接用前一個），取兩者的最大值。後面一串加減是計算區間大小\n邊界dp[i][j] = 0,\\text{for all 0≤i≤k,0≤j≤n}從轉移式可以看到他空間可以用滾動DP優化！\n\n            GREEDY的作法？如果每一次都選擇最大的區間，並將這個區間的值都改成0，做7次，得到答案，是正確的做法嗎？最大的區間不一定會被完全選到。以下測資：12 25 4 3 2 1 3 4 5 6 4 3 2如果是Greedy會選擇 $2 \\,1\\, 3\\, 4\\, 5\\, 6$ ，然後從兩邊挑一邊。答案是 $9$。但是用DP做會是 $5\\, 4\\, 3\\, 2\\, 1$ 加上 $5\\, 6\\, 4\\, 3\\, 2$，答案是 $10$。\n          \n時間複雜度： 兩層迴圈總共是 $O(kn)$\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,k,dp[2][N],lft[N],arr[N];int mp[N];signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;k;    memset(dp,0,sizeof(dp));    memset(lft,0,sizeof(lft));    memset(mp,0,sizeof(mp));    rep(i,1,n)cin&gt;&gt;arr[i];    int maxn = 0;    for(int i=1;i&lt;=n;i++)&#123;        if(mp[arr[i]]!=0)&#123;            lft[i] = mp[arr[i]]+1;            mp[arr[i]] = i;        &#125;        else&#123;            lft[i] = 1;            mp[arr[i]] = i;        &#125;        lft[i] = max(maxn,lft[i]);        maxn = max(maxn,lft[i]);    &#125;        for(int i=0;i&lt;k;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            dp[1][j] = max(dp[1][j-1],dp[0][lft[j]-1]+j-lft[j]+1);        &#125;        for(int j=1;j&lt;=n;j++)&#123;            dp[0][j] = dp[1][j];        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;endl;&#125;// 1 1 2 1 4 1 7 1 3 8// 1 1 2 2 4 4 7 7 7 8\nEXTRA 版本\nBY thanksone\n\n\n熟悉的題目，大的感人的k。如果依照上面$O(nk)$的做法肯定TLE。俗話說得好 : “好的DP定義是AC的一半”因此經過一系列通靈，我們得到了一個非常漂亮的定義\n定義 $dp[i] =$ 必須選第 $i$ 家，$($能吃最多的攤販數量，需要的人數$) (dp[i]$是一個$pair)$\n轉移式維護一個函數 $L[i]$ ，其實就是樓上的 $f[i]$，但是我比較想要叫他 $L$\ndp[i] = max_{j","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS修補圍籬","url":"/apcs2111-1/","content":"P1 修補圍籬\n題目連結\n題解如果在兩端就直接取旁邊的高度，否則取跟左右邊高度的最小值。\n時間複雜度$O(n)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define N 105#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,A[N];signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;A[i];    int ans = 0;    if(A[0] == 0)ans += A[1];    if(A[n-1] == 0)ans += A[n-2];    for(int i=1;i&lt;n-1;i++)&#123;        if(A[i] == 0)ans += min(A[i-1],A[i+1]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS動線安排","url":"/apcs2111-2/","content":"P2 動線安排(魔王題)\n題目連結\n題解把線分成橫的跟直的就可以好好處理交叉了!\n時間複雜度$O(h(n + m))$\nAC程式碼#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt = 0, ans = 0;array&lt;array&lt;int, 104&gt;, 104&gt; R, C, I;void add(int r, int c)&#123;    bool ok;    I[r][c] = 1;    cnt++;    if(C[r][c] || R[r][c]) cnt--;    C[r][c] = R[r][c] = 0;    ok = 0;     //直下情況    for(int i = r + 1; i &lt; n; i++)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r + 1; i &lt; n; i++)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //直上情況    for(int i = r - 1; i &gt;= 0; i--)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r - 1; i &gt;= 0; i--)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //橫右情況    for(int i = c + 1; i &lt; m; i++)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c + 1; i &lt; m; i++)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;    ok = 0;     //橫左情況    for(int i = c - 1; i &gt;= 0; i--)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c - 1; i &gt;= 0; i--)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;&#125;void pull(int r, int c)&#123;    I[r][c] = 0;    cnt--;    for(int i = r + 1; i &lt; n; i++)&#123;     //直下情況        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = r - 1; i &gt;= 0; i--)&#123;    //直上情況        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = c + 1; i &lt; m; i++)&#123;     //橫右情況        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;    for(int i = c - 1; i &gt;= 0; i--)&#123;    //橫左情況        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;&#125;signed main()&#123;    int h, r, c, t;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;    while(h--)&#123;        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t;        if(t)&#123;            pull(r, c);        &#125;else&#123;            add(r, c);        &#125;        ans = max(ans, cnt);    &#125;    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot; &lt;&lt; cnt;    return 0;&#125;\n\nBY thanksone\n\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"[題解]APCS真假子圖","url":"/apcs2111-4/","content":"P4 真假子圖\n題目連結\n二分搜尋+DFS作法題解一開始看到這題，應該很難通靈出二分搜這個作法（我覺得光把題目看懂就有點難度了）。這題有一個條件要特別注意：\n\n保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合\n這一題每一個觀察員並可看成不是獨立的（假如一個觀察員不產生矛盾，則他回傳的那一些邊都會被沿用），所以題目 $p$ 筆詢問可以聯集一起處理。\n\n將情報員當成點，合作關係當成邊，那麼合法的圖就會有兩個點集，點集中的點互不相鄰，也就是二分圖。\n二分搜第一個使得圖變得不二分的人，把它消失，最多重複3次就做完了。\n\n            為什麼可以二分搜？二分搜是用來找一串01字串的分界點，並且必須具有單調性才能二分搜。這一題之所以會有單調性是因為，當我查詢觀察員$P_i$的回傳資料是否正確時，會將前面 $1$ 到 $i-1$ 的觀察員回傳的所有邊納入考慮。假設有一個觀察員 $P_j(1\\le j &lt; i)$ 回傳的資料是錯誤的，這些邊會導致整張圖變成非二分圖，對於 $j$ 後面的所有點來說，都是非二分圖。這樣就有了以 $j$ 為分界點的單調性，即可二分搜。\n          \n二分圖判斷可以用 DFS 做，DFS 的時候把每個點塗上顏色，如果相鄰的點跟自己顏色一樣就表示這不是一張二分圖。\n時間複雜度$O((n + m + pk)\\log p)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define pb push_back#define mid (l + r) / 2using namespace std;struct e&#123;    int u, v;&#125;;int n;array&lt;bool, 10004&gt; WA;          //不可行的觀察員編號array&lt;int, 20004&gt; vis;          //DFS是否走訪、二分圖顏色array&lt;vector&lt;e&gt;, 10004&gt; E;      //每一個觀察員的回傳邊array&lt;vector&lt;int&gt;, 20004&gt; G;    //存進行DFS的圖bool dfs(int u, int t)&#123;         //用DFS塗色、判斷二分圖    if(vis[u]) return 1;    bool ans = 1;    vis[u] = t;    for(int v : G[u])&#123;        if(vis[v] == t) return 0;        ans &amp;= dfs(v, 3 - t);    &#125;    return ans;&#125;bool check(int p)&#123;               //檢查第p個觀察員回傳是否正確    bool ans = 1;    for(int i = 0; i &lt; n; i++)&#123;        G[i].clear();        vis[i] = 0;    &#125;    for(int i = 0; i &lt;= p; i++)&#123;        for(auto [u, v] : E[i])&#123; //將觀察員的邊推入G            G[u].pb(v);            G[v].pb(u);        &#125;    &#125;    for(int i = 0; i &lt; n; i++)&#123;        ans &amp;= dfs(i, 1);        //將每一個連通塊    &#125;    return ans;&#125;void BS(int l, int r)&#123;           //二分搜觀察員    if(check(r)) return;         //當邊的連集不會讓圖有問題，則回傳    while(l != r)&#123;        if(check(mid)) l = mid + 1;        else r = mid;    &#125;    WA[l] = 1;    E[l].clear();                //剔除一錯誤觀察員&#125;signed main()&#123;    int m, p, k, a, b;    cin &gt;&gt; n &gt;&gt; m;    while(m--)&#123;        cin &gt;&gt; a &gt;&gt; b;        E[0].pb(&#123;a, b&#125;);    &#125;    cin &gt;&gt; p &gt;&gt; k;    for(int i = 1; i &lt;= p; i++)&#123;        for(int j = 0; j &lt; k; j++)&#123;            cin &gt;&gt; a &gt;&gt; b;            E[i].pb(&#123;a, b&#125;);        &#125;    &#125;    for(int i = 0; i &lt; 3; i++)&#123;     //至多三個觀察員        BS(0, p);    &#125;    for(int i = 1; i &lt;= p; i++)&#123;        if(WA[i]) cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nBY thanksone\n\nDSU作法\nIdea From Kennyfs\n\n題解這一題的題目限制有說最多3個錯誤的情報員，因此我們可以用上面二分搜的方式做三次找到答案。如果題目不限制錯誤調查員的數量，也就是用二分搜時間會超時，但是用DSU可以在線性時間內完成！\nDSU的目的在處理集合問題，根據下面這個關鍵條件：\n\n保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合\n\n我們只要對每一筆詢問看會不會與組長手中的pair矛盾即可。如果每一次都做DFS，會發現時間複雜度是 $O(pn)$，必然超時。\nDSU的想法是，我們將組長手中的圖中上每一個連通塊都分別塗上兩種顏色（必為二分圖，因此將兩邊各塗上不同顏色）。接著，把每個顏色當作初始的並查集中的集合，將每一筆觀察員回傳的邊的兩端指向的集合合併起來，過程中如果發生邊的兩端同屬一個集合，表示這是一個錯誤的觀察員。做完每一個觀察員之後，把所有變更過的還原成初始狀態（組長手中的圖）即可。\n\n            舉例8 50 2 1 3 1 2 4 6 5 61 21 4 0 6整個過程就是下面這張GIF：步驟：利用DFS為組長手中的圖上色，每一個連通塊兩色（以編號1,2,3…）將每一個顏色當作並查集元素觀察員輸入的邊兩端 $(u,v)$非同色，表示不發生矛盾，則將u所在集合與v所在集合的對方（連通塊兩色的另一色）合併重複 步驟3 共k次，如果發生$(u,v)$為同一色，則觀察員錯誤。\n          \n時間複雜度$O(n + pk\\alpha)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 20005#define M 10005using namespace std;int n,m,p,k;int color[N],boss[N],num[N];bool WA[M],f;int other(int s)&#123;return (s%2)?s+1:s-1;&#125; //other為同一連通塊另外一種顏色vector&lt;int&gt; edge[N],change;void init()&#123;                            //初始化    memset(color,0,sizeof(color));    memset(WA,0,sizeof(WA));&#125;void dfs(int id,int col)&#123;           //對所有點上色    color[id] = col;    for(auto i:edge[id])&#123;        if(!color[i])dfs(i,other(col));    &#125;&#125;int find_boss(int id)&#123;              //尋找祖先、及路徑壓縮    if(boss[id] == id)return id;    change.push_back(id);    return boss[id] = find_boss(boss[id]);&#125;signed main()&#123;    IOS;    init();    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    int now = 1;    for(int i=0;i&lt;n;i++)&#123;           //對所有點上色        if(!color[i])&#123;            dfs(i,now);now += 2;        &#125;    &#125;    for(int i=1;i&lt;=now;i++)&#123;boss[i] = i;num[i] = 1;&#125;    cin&gt;&gt;p&gt;&gt;k;    for(int i=1;i&lt;=p;i++)&#123;        change.clear();                                  //儲存待更改的點集f = 0;        for(int j=0;j&lt;k;j++)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            if(f)continue;            x = color[x],y = color[y];                   //尋找邊兩端點的顏色所處的集合            int bx =  find_boss(x),by = find_boss(y);            int ox = find_boss(other(y)),oy = find_boss(other(x));            if(bx == by)&#123;WA[i] = 1;f = 1;continue;&#125;     //位於同一集合，此觀察員是錯的            //以下是啟發式合併（小的集合並到大的集合）            if(num[bx] &lt; num[ox])&#123;                boss[bx] = ox;num[ox] += num[bx];                change.push_back(bx);            &#125;            else&#123;                boss[ox] = bx;num[bx] += num[ox];                change.push_back(ox);            &#125;            if(num[by] &lt; num[oy])&#123;                boss[by] = oy;num[oy] += num[by];                change.push_back(by);            &#125;            else&#123;                boss[oy] = by;num[by] += num[oy];                change.push_back(oy);            &#125;        &#125;        for(auto i : change)&#123;boss[i] = i;num[i] = 1;&#125;   //觀察員的邊結束，看完後復原    &#125;    for(int i=1;i&lt;=p;i++)if(WA[i])cout&lt;&lt;i&lt;&lt;endl;        //輸出最後錯誤觀察員答案&#125;\n\nBY peienwu\n\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"APCS題解：2021年9月","url":"/apcs2109/","content":"這次沒有報名APCS，因為報名手續有點麻煩，還要在學證明和教師簽名等等，所以就沒有報…。總之，利用ZeroJudge的測資來寫寫看，但在ZJ上面會過不能保證真的去考APCS的測資就一定會過！\n\nP1 七言對聯題目連結\n總共有ABC三種規則，就每一種都比對一次就可以了！\n時間複雜度： 共有 $n$ 組對聯，每一組都 $O(1)$ 檢查，時間 $O(n)$ 。（不過n最大也才50，不論什麼複雜度都可以吧）\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 50#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;bool a[N],b[N],f = 1;signed main()&#123;    Orz;    cin&gt;&gt;n;    while(n--)&#123;        rep(i,1,7)cin&gt;&gt;a[i];        rep(i,1,7)cin&gt;&gt;b[i];        f = 1;        if(a[2]==a[4]||a[2]!=a[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        else if(b[2]==b[4]||b[2]!=b[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        if(a[7]!=1 || b[7]!=0)&#123;                cout&lt;&lt;&quot;B&quot;;f = 0;        &#125;        if(a[2]==b[2]||a[4]==b[4]||a[6]==b[6])&#123;                cout&lt;&lt;&quot;C&quot;;f = 0;        &#125;        if(f)cout&lt;&lt;&quot;None&quot;&lt;&lt;endl;        else cout&lt;&lt;endl;    &#125;&#125;\nP2 魔王迷宮題目連結\n這一題我好像太早寫了，題目還在整修階段，丟上去TLE，發現題目敘述又改了XD，從魔王踩到炸彈爆炸後，「炸彈不會消失」，到「炸彈會消失」，還有範測也有改變。\n這一題是去模擬每一個魔王移動的狀況，要特別注意每一輪的國王是同時移動的，沒有先後順序，也就是說一顆炸彈可以炸掉不只一位魔王，如果有多個魔王移動到同一個格子，則他們會一起被炸掉。\n時間複雜度： 有點難估計，因為很難確定每一個魔王的移動狀況次數，不過由於數字範圍不大，且 $k$ 只有到500，因此直接做複雜度是可行的。\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,k;bool maze[N][N],bomb[N][N];struct node&#123;    int x,y,s,t;    bool alive;&#125;mp[505];signed main()&#123;    Orz;    memset(maze,0,sizeof(maze));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    rep(i,0,k-1)&#123;        cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y;        cin&gt;&gt;mp[i].s&gt;&gt;mp[i].t;        mp[i].alive = 1;    &#125;        int now_alive = k;    while(now_alive)&#123;        memset(bomb,0,sizeof(bomb));        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            maze[i][j] = 1;        &#125;        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            int nx = i + mp[p].s;            int ny = j + mp[p].t;            if(nx &gt;= n || nx &lt; 0 || ny &gt;= m ||ny &lt; 0)&#123;                now_alive--;                mp[p].alive = 0;            &#125;            else if(maze[nx][ny])&#123;                now_alive--;                mp[p].alive = 0;                bomb[nx][ny] = 1;            &#125;            else&#123;                mp[p].x = nx;                mp[p].y = ny;            &#125;        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                if(bomb[i][j] == 1)                    maze[i][j] = 0;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            if(maze[i][j])ans++;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nP3 幸運數字題目連結\n以區間最小值作為區分點將數列分成兩半，可以利用線段樹找區間最小值，利用迴圈模擬每一次範圍縮小的情況。\n不過這一題比較特別，他的區間範圍一定會越來越小，且區間外的數字也就不需要使用到，因此可以將數列做一次排序，從頭開始找如果遇上區間外的數字則不理他，否則使用它當作區間的分隔點（這一定會是最小值，因為由小到大排序），將區間範圍縮小。\n至於挑選左右區間的區間和，則可以透過前綴和 $O(1)$ 算出答案。\n時間複雜度： 如果是一個遞增或遞減的序列，則每一次區間大小只會縮減1，此時複雜度為 $O(n)$，加上最一開始的排序是 $O(n\\log n)$，總共為 $O(n\\log n)$。\n排序作法#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii sorted[N];signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;sorted[i-1].x;        arr[i] = sorted[i-1].x;        sorted[i-1].y = i;        pref[i] = pref[i-1]+arr[i];    &#125;    sort(sorted,sorted+n);    int ind = 0,l = 1,r = n;    while(r&gt;l)&#123;        while(sorted[ind].y &gt; r || sorted[ind].y &lt; l)ind++;        int left = pref[sorted[ind].y-1]-pref[l-1];        int right = pref[r]-pref[sorted[ind].y];        if(left &gt; right)&#123;            r = sorted[ind].y-1;        &#125;        else&#123;            l = sorted[ind].y+1;        &#125;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;endl;&#125;\n線段樹作法如果用線段樹實作，尋找區間最小值，可以在 $O(\\log n)$ 的時間內詢問。在最差的情況下，一共會詢問 $n$ 次，因此總時間複雜度一樣是 $O(n\\log n)$。實作上也不複雜，建立線段樹以及區間詢問，區間修改和懶標之類的東西。可以比較一下時間：\n\n線段樹的表現稍微好一點，不過其實是相當接近的！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii seg[4*N];//建立線段樹[l,r)void build(int cur,int l,int r)&#123;    if(r &lt;= l)return;    if(r - l &lt;= 1)&#123;        seg[cur] = &#123;arr[l],l&#125;;        return;    &#125;    int mid = (l+r)/2;    build(2*cur,l,mid);    build(2*cur+1,mid,r);    if(seg[2*cur].x &lt; seg[2*cur+1].x)        seg[cur] = seg[2*cur];    else        seg[cur] = seg[2*cur+1];&#125;//詢問區間最小值，回傳pairpii query(int cur,int l,int r,int ql,int qr)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return &#123;INT_MAX,INT_MAX&#125;;    if(ql &lt;= l &amp;&amp; qr &gt;= r)return seg[cur];    int mid = (l+r)/2;    pii lft = query(2*cur,l,mid,ql,qr);    pii rgt = query(2*cur+1,mid,r,ql,qr);    if(lft.x &lt; rgt.x)return lft;    return rgt;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    build(1,1,n+1);    int l = 1,r = n+1;        while(r - l &gt; 1)&#123;        int ind = query(1,1,n+1,l,r).y;        int left = pref[ind-1] - pref[l-1];        int right = pref[r-1] - pref[ind];        if(left &gt; right)r = ind;        else l = ind + 1;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;&quot;\\n&quot;;&#125;\n歐恩作法\nBY thanksone\n\n有一種二元樹，我也不知道叫啥，根為全序列最小值，左節點為左邊序列最小值，右節點為右邊序列最小值。\n建法紀錄每個位置左、右邊離自己最近、比自己小的，爸爸就是兩個之中比較大的那一個。\n時間複雜度： 種樹加跑答案總共 $O(n)$\n#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define ff first#define ss secondusing namespace std;array&lt;int, 300004&gt; A, S, L, R;array&lt;pii, 300004&gt; tree;void plant(int n)&#123;    for(int i = 1; i &lt;= n; i++)&#123;        if(A[L[i]] &gt; A[R[i]]) tree[L[i]].ss = i;        else tree[R[i]].ff = i;    &#125;&#125;int solve(int l, int r, int m)&#123;    if(l == r) return A[l];    if(S[m - 1] - S[l - 1] &gt; S[r] - S[m]) return solve(l, m - 1, tree[m].ff);    else return solve(m + 1, r, tree[m].ss);&#125;signed main()&#123;    int n;    cin &gt;&gt; n;    stack&lt;pii&gt; s;    pii m = &#123;1e9, 0&#125;;    s.push(&#123;0, 0&#125;);    for(int i = 1; i &lt;= n; i++)&#123;        cin &gt;&gt; A[i];        if(A[i] &lt; m.ff) m = &#123;A[i], i&#125;;        S[i] = A[i] + S[i - 1];        while(A[i] &lt; s.top().ff)&#123;            R[s.top().ss] = i;            s.pop();        &#125;        L[i] = s.top().ss;        s.push(&#123;A[i], i&#125;);    &#125;    plant(n);    cout &lt;&lt; solve(1, n, m.ss);    return 0;&#125;\n如果把範測的笛卡爾樹具象化，大概長這樣：\n\n83 9 4 5 1 6 2 8\n\n\n大致步驟就是：\n\n用單調隊列建立函數 $L$ 以及 $R$，表示往左往右看第一個小於自己的數\n建立笛卡爾樹（$L[i],R[i]$ 挑大的作為父節點）\n從根節點開始走訪，左右節點就會分別是左右區間的最小值\n利用前綴和計算區間大小，決定要走左還是右子樹\n走訪到區間長度為 $1$ 時即答案！\n\n\n            總共有三個不同的作法，使用到排序、線段樹、笛卡兒樹的作法。其中，他們的間複雜度分別是 $O(n\\log n)$、$O(n\\log n)$、$O(n)$。排序作法：AC (0.1s, 9.5MB)線段樹作法：AC (84ms, 20.9MB)歐恩作法：AC (82ms, 15.6MB)在笛卡兒樹的作法中，對每一個數字尋找兩側第一個小於它的數字（這可以用單調隊列完成），之後把每一個數字的父親節點設為找到的兩端數字中較大的那一個。此作法的概念是，假設序列中第 $i$ 個數字找到兩側數字分別是 $l_i$ 以及 $r_i$，當他如果是區間最小時，區間必須在 $[l_i+1:r_i-1]$ 之中，否則它就不會是最小值了。至於為何是選擇 $max(A[l_i],A[r_i])$ 當做父節點？則是因為如果選擇較小的那一個，在縮小區間範圍後，無法確定另外一個是否在區間外，如果包含區間內，則 $A[i]$ 便不會是最小值，違反了定義。換言之，選擇了較大的那一個當作父節點，按照定義當走到這個父節點時，它是區間的最小值，將它排除之後，$A[i]$ 就會是下一個區間的最小值！\n          \nP4 美食博覽會題目連結\n對於序列中k個連續的區間，每一個區間滿足區間內的元素皆不重複，區間範圍可以重疊（不過重疊部分只會算一次），找出這k個連續區間所能覆蓋到的最大長度。\n感覺跟背包問題的概念有點像，n個物品可以對應到k個區間，重量則對應到這裡的序列中的數字。這題用DP解。\n定義定義 $dp[i][j]$ 為 $i$ 個試吃員，看了前 $j$ 個攤位，最多可以吃到幾個攤位。\n轉移式維護一個函數 $f[i]$ 表示如果試吃員吃了第 $i$ 個攤位的美食，他所能吃到最左端的攤位的索引值。也就是說，試吃員可以吃 $f[i]$ 到 $i$ 攤位的美食。\ndp[i][j] = max(dp[i][j-1],dp[i-1][f[j]-1]+j-f[j]+1)轉移式代表了要使用第 $i$ 的攤位作為右端點，或是不要使用（直接用前一個），取兩者的最大值。後面一串加減是計算區間大小\n邊界dp[i][j] = 0,\\text{for all 0≤i≤k,0≤j≤n}從轉移式可以看到他空間可以用滾動DP優化！\n\n            GREEDY的作法？如果每一次都選擇最大的區間，並將這個區間的值都改成0，做7次，得到答案，是正確的做法嗎？最大的區間不一定會被完全選到。以下測資：12 25 4 3 2 1 3 4 5 6 4 3 2如果是Greedy會選擇 $2 \\,1\\, 3\\, 4\\, 5\\, 6$ ，然後從兩邊挑一邊。答案是 $9$。但是用DP做會是 $5\\, 4\\, 3\\, 2\\, 1$ 加上 $5\\, 6\\, 4\\, 3\\, 2$，答案是 $10$。\n          \n時間複雜度： 兩層迴圈總共是 $O(kn)$\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,k,dp[2][N],lft[N],arr[N];int mp[N];signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;k;    memset(dp,0,sizeof(dp));    memset(lft,0,sizeof(lft));    memset(mp,0,sizeof(mp));    rep(i,1,n)cin&gt;&gt;arr[i];    int maxn = 0;    for(int i=1;i&lt;=n;i++)&#123;        if(mp[arr[i]]!=0)&#123;            lft[i] = mp[arr[i]]+1;            mp[arr[i]] = i;        &#125;        else&#123;            lft[i] = 1;            mp[arr[i]] = i;        &#125;        lft[i] = max(maxn,lft[i]);        maxn = max(maxn,lft[i]);    &#125;        for(int i=0;i&lt;k;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            dp[1][j] = max(dp[1][j-1],dp[0][lft[j]-1]+j-lft[j]+1);        &#125;        for(int j=1;j&lt;=n;j++)&#123;            dp[0][j] = dp[1][j];        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;endl;&#125;// 1 1 2 1 4 1 7 1 3 8// 1 1 2 2 4 4 7 7 7 8\nEXTRA 版本\nBY thanksone\n\n\n熟悉的題目，大的感人的k。如果依照上面$O(nk)$的做法肯定TLE。俗話說得好 : “好的DP定義是AC的一半”因此經過一系列通靈，我們得到了一個非常漂亮的定義\n定義 $dp[i] =$ 必須選第 $i$ 家，$($能吃最多的攤販數量，需要的人數$) (dp[i]$是一個$pair)$\n轉移式維護一個函數 $L[i]$ ，其實就是樓上的 $f[i]$，但是我比較想要叫他 $L$\ndp[i] = max_{j","categories":["APCS檢定"],"tags":["APCS","競賽筆記"]},{"title":"[題解]APCS生產線","url":"/apcs2111-3/","content":"P3 生產線\n題目連結\n差分作法題解用差分的想法加值，再用前綴還原，最後再排序。最後利用Greedy的想法，將每一項最小的工作量乘上最大的時間，總和即為答案。\n\n            差分差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：b_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：定義一個新的陣列 $b_i$ 表示每一項差分設 $b[l] =  b[l] + v,b[r+1] = b[r+1] - v$將差分的每一項加上前一項（做前綴和 $b[i] = b[i]+b[i-1]$），即為原數列第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了$O(1)$了！\n          \n時間複雜度差分：$O(m)$ 、排序 $O(n\\log n)$\n總時間複雜度：$O(n\\log n + m)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,A[N],B[N];signed main()&#123;    IOS;    memset(A,0,sizeof(A));    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        A[x] += w;        A[y+1] -= w;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];    for(int i=1;i&lt;=n;i++)A[i] = A[i] + A[i-1];    sort(A+1,A+n+1);    sort(B+1,B+n+1);    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans += A[i] * B[n-i+1];    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\n線段樹作法\n很奇怪，最近兩次的APCS第三題都有人想要砸資結，特別是線段樹，可能有些人特別偏愛線段樹吧！\n題解線段樹最原本的應該是區間詢問、單點修改，如果要區間修改的話就會用到懶標，所以實作上相對上比較複雜一點。這一題用線段樹的目的是區間加值，加值完過後的排序以及Greedy跟差分的作法是一樣的，用線段樹真的是多此兩舉（實作較複雜、較耗時）！\n當然，這一題比較特別只有最後一起做單點查詢，因此不用懶標，最侯直接計算一路去經過的答案也行！下面的程式碼就是把完全包含區間的節點加值，不用使用到懶標，最後一次查詢。\n時間複雜度區間加值 $O(m\\log n)$，n個點的詢問 $O(n\\log n)$，排序 $O(n\\log n)$\n總時間複雜度：$O((n+m)\\log n)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,t,A[N],B[N],ans = 0;struct node&#123;    int val = 0,sz;&#125;seg[4*N];void build(int id,int l,int r)&#123;    seg[id].sz = r - l;    if(r - l &lt;= 1)return;    int mid = (l + r) / 2;    build(id*2,l,mid);    build(id*2+1,mid,r);&#125;void modify(int id,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || r &lt;= ql || l &gt;= qr)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[id].val += val;        return;    &#125;    int mid = (l + r) / 2;    modify(id*2,l,mid,ql,qr,val);    modify(id*2+1,mid,r,ql,qr,val);&#125;void query(int id,int l,int r,int val)&#123;    if(r &lt;= l)return;    ans += seg[id].val;    if(r - l == 1)return;    int mid = (l + r) / 2;    if(val &lt; mid)return query(id*2,l,mid,val);    else return query(id*2+1,mid,r,val);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    build(1,1,n+1);    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        y++;        modify(1,1,n+1,x,y,w);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        ans = 0;query(1,1,n+1,i);        A[i] = ans;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];        sort(A+1,A + n + 1);    sort(B+1,B + n + 1);    int ans = 0;    for(int i=1;i&lt;=n;i++)ans += A[i] * B[n-i+1];    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS題解"],"tags":["題解","APCS檢定"]},{"title":"APCS CLASS PART 3","url":"/apcs3/","content":"APCS Class題目第三部分！\nM. [基礎資料結構 II 及基礎演算法 II ] 貪婪法a071. 排隊買飲料\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;&gt;&gt;pq;        cin&gt;&gt;n&gt;&gt;m;    int ans=0,time=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;time;        if(i&gt;m)&#123;            time+=pq.top();            pq.pop();        &#125;        pq.push(time);        ans = max(ans,time);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\na075. 醜數#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n;signed main()&#123;    Orz;    cin&gt;&gt;n;    vector&lt;int&gt; vec;    vec.push_back(1);    int id2 = 0,id3 = 0,id5 = 0;    //用前面的醜數推後面的，不會有其他質樹    for(int i=1;i&lt;n;i++)&#123;        int ugly = min(vec[id2]*2,min(vec[id3]*3,vec[id5]*5));        vec.push_back(ugly);        if(vec[i]==vec[id2]*2)id2+=1;        if(vec[i]==vec[id3]*3)id3+=1;        if(vec[i]==vec[id5]*5)id5+=1;    &#125;    cout&lt;&lt;vec[n-1]&lt;&lt;endl;&#125;\na091. Add All#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            pq.push(temp);        &#125;        int ans = 0;        while(pq.size()!=1)&#123;            int cur = pq.top();            pq.pop();            cur += pq.top();            pq.pop();            ans+=cur;            pq.push(cur);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\na139. 背包置物問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,k;vector&lt;int&gt; vec,p;signed main()&#123;    cin&gt;&gt;n;    vec.assign(1,-1);    cin.ignore();    string s;getline(cin,s);    stringstream ss(s);    int temp;    while(ss&gt;&gt;temp)vec.push_back(temp);    cin&gt;&gt;k;        int ans = 0,len = vec.size();    for(int i=1;i&lt;=len-1;i++)&#123;        if(find(p.begin(),p.end(),vec[i])!=p.end())continue;        else if(p.size()&lt;k)&#123;            p.push_back(vec[i]);            continue;        &#125;        int index = 0, dis = 0, max_dis=0;                for(int j=0;j&lt;p.size();j++)&#123;            dis = 0;            for(int q=i+1;q&lt;=len;q++)&#123;                if(vec[q]==p[j])break;                dis += 1;            &#125;            if(max_dis &lt; dis)&#123;                max_dis = dis;                index = j;            &#125;        &#125;//        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;index&lt;&lt;endl;        p[index] = vec[i];        ans += 1;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na141. 基地台#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 50005using namespace std;int n,k,arr[N];//確認直徑可否覆蓋全部（greedy）bool check(int sum)&#123;    int max_cover = arr[0]+sum;    int cnt=1;    for(int i=1;i&lt;n;i++)&#123;        if(max_cover &lt; arr[i])&#123;            max_cover = arr[i]+sum;            cnt++;        &#125;    &#125;    return (cnt&lt;=k);&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    int l = 1,r = ceil((arr[n-1]-arr[0])/k);    //區間[l,r]二分搜尋直徑    while(l&lt;r)&#123;        int mid = (l+r)/2;        if(check(mid))r = mid;        else l = mid+1;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nN. [基礎資料結構 II 及基礎演算法 II ] 分而治之與回溯法a089. 蘇丹王位繼承者#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,chess[N][N],Q[N],ans=0;bool check(int row,int col)&#123;    for(int i=1;i&lt;row;i++)&#123;        if(col == Q[i]||abs(row-i)==abs(col-Q[i]))return 0;    &#125;    return 1;&#125;void Queen(int row)&#123;    if(row&gt;8)&#123;        int sum = 0;        rep(i,1,8)sum += chess[i][Q[i]];        ans = max(ans,sum);        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(row,i))&#123;            Q[row] = i;            Queen(row+1);        &#125;    &#125;&#125;void solve()&#123;    memset(chess,0,sizeof(chess));    memset(Q,0,sizeof(Q));    ans = 0;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            cin&gt;&gt;chess[i][j];        &#125;    &#125;    Queen(1);    cout&lt;&lt;right&lt;&lt;setw(5)&lt;&lt;ans&lt;&lt;endl;    &#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na090. 質數環#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 20#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,prime[105],ans[N],cnt = 0;bool visit[N];void init()&#123;    rep(i,0,100)prime[i] = 1;    prime[1] = 0;    for(int i=2;i&lt;=100;i++)&#123;        if(prime[i]==0)continue;        for(int j=2*i;j&lt;=100;j+=i)&#123;            prime[j] = 0;        &#125;    &#125;&#125;void dfs(int id,int val)&#123;    ans[id] = val;    if(id&gt;=n-1)&#123;        if(!prime[val+1])return;        for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;        return;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        if(visit[i])continue;        if(prime[val+i]==0)continue;        visit[i] = 1;        dfs(id+1,i);        visit[i] = 0;    &#125;&#125;signed main()&#123;    Orz;    init();    while(cin&gt;&gt;n)&#123;        cnt+=1;        memset(ans,0,sizeof(ans));        memset(visit,0,sizeof(visit));        cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt&lt;&lt;&quot;:&quot;&lt;&lt;endl;        dfs(0,1);    &#125;&#125;\na142. 無刻度容器倒水問題#include &lt;bits/stdc++.h&gt;#define ll long long#define double long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int x,y,z;int a[N][N];bool visit[N][N];void solve()&#123;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;    memset(a,0x3f3f3f3f,sizeof(a));memset(visit,0,sizeof(visit));    a[0][0] = 0;    queue&lt;pii&gt;que;    que.push(&#123;0,0&#125;);    visit[0][0] = 1;        bool f = 0;    while(!que.empty())&#123;        pii cur = que.front();        que.pop();        int mmin = cur.x,mmax = cur.y;        int dx[6] = &#123;max(0,mmax-(y-mmin)),min(mmax+mmin,x),x,mmin,0,mmin&#125;;        int dy[6] = &#123;min(y,mmax+mmin),max(0,mmax-(x-mmin)),mmax,y,mmax,0&#125;;                for(int i=0;i&lt;6;i++)&#123;            int nx = dx[i],ny = dy[i];            if(nx==z||ny==z)&#123;                f = 1;                cout&lt;&lt;a[mmin][mmax]+1&lt;&lt;endl;                return;            &#125;            if(visit[nx][ny])continue;            a[nx][ny] = a[mmin][mmax]+1;            visit[nx][ny] = 1;            que.push(&#123;nx,ny&#125;);        &#125;    &#125;    if(!f)cout&lt;&lt;-1&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na165. 最近點對問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 10002#define INF 5e18#define FOR(i,n) for(int i=0;i&lt;n;i++)#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;#define pdd pair&lt;double,double&gt;using namespace std;int n;vector&lt;pii&gt; p,temp;void init()&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(4);    temp.clear();    p.assign(n,&#123;0,0&#125;);&#125;bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125;double dis(pii a,pii b)&#123;    double x1 = a.x-b.x,y1 = a.y-b.y;    return sqrt(x1 * x1 + y1 * y1);&#125;//區間[l,r]double solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l+r)/2,mid_pos = p[mid].x;;    double ans = min(solve(l,mid),solve(mid+1,r));        temp.assign((r-l+1),&#123;0,0&#125;);    merge(        p.begin() + l, p.begin() + mid + 1,        p.begin() + mid + 1, p.begin() + r + 1,        temp.begin(), cmp    );    rep(i, l, r)p[i] = temp[i-l];    temp.clear();    rep(i, l, r)&#123;        if(abs(p[i].x - mid_pos) &lt;= ans)            temp.push_back(p[i]);    &#125;    int len = temp.size();    rep(i, 0, len-1)&#123;        rep(j, i+1, len-1)&#123;            ans = min(ans, dis(temp[i],temp[j]));            if(abs(temp[i].y-temp[j].y) &gt; ans)                break;        &#125;    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        init();        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        double ans = solve(0,n-1);        if(ans &gt; 10000)cout&lt;&lt;&quot;INFINITY&quot;&lt;&lt;endl;        else cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nO. [基礎資料結構 II 及基礎演算法 II ] 動態規劃a143. 關鍵字搜尋模擬#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,num_key = 0;string key[N];vector&lt;pif&gt; ans;int com_string(string s1, string s2)&#123;    s1 = &quot;0&quot;+s1;s2 = &quot;0&quot;+s2;    int ans = 0,com[N][N];memset(com,0,sizeof(com));    int len1 = s1.size(),len2 = s2.size();    for(int i=1;i&lt;len1;i++)&#123;        for(int j=1;j&lt;len2;j++)&#123;            if(s1[i] == s2[j])&#123;                com[i][j] = com[i-1][j-1]+1;                ans = max(ans,com[i][j]);            &#125;        &#125;    &#125;    return ans;&#125;bool cmp(pif a,pif b)&#123;    if(a.y == b.y)return a.x &lt; b.x;    return a.y &gt; b.y;&#125;float max_num(string s)&#123;    float ans = 0.0;    for(int i=0;i&lt;num_key;i++)&#123;        ans = max(ans,(float)com_string(s,key[i])/key[i].size());    &#125;    return ans;&#125;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);    while(ss&gt;&gt;key[num_key++]);    cin&gt;&gt;n;cin.ignore();    while(n--)&#123;        int doc_num;        getline(cin,s);        stringstream ss2(s);        ss2&gt;&gt;doc_num;        float score = 0.0;        while(ss2 &gt;&gt; s)score += max_num(s);                score = round(score*100)/100;        ans.push_back(&#123;doc_num,score&#125;);    &#125;    sort(ans.begin(),ans.end(),cmp);    if(ans[0].y &lt;= 0)cout&lt;&lt;&quot;FALSE&quot;&lt;&lt;endl;    else for(auto i: ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;;&#125;\na144. 農作物採收問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 25#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,num[N][N],dp[N][N];void init()&#123;    memset(num,0,sizeof(num));    memset(dp,0,sizeof(dp));&#125;signed main()&#123;    init();    cin&gt;&gt;n;    rep(i,1,n)rep(j,1,n)cin&gt;&gt;num[i][j];        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];        &#125;    &#125;    int ans = 0;        //左上(a,b)右下(x,y)    rep(i,1,n)rep(j,1,n)rep(a,1,i)rep(b,1,j)    ans = max(ans,num[i][j]-num[a-1][j]-num[i][b-1]+num[a-1][b-1]);        cout&lt;&lt;ans&lt;&lt;endl;&#125;\na145. 搬家規畫問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);        int w[N],v[N],ind=0;    while(ss&gt;&gt;w[ind++]);    ind--;    for(int i=0;i&lt;ind;i++)cin&gt;&gt;v[i];    int c;cin&gt;&gt;c;    int dp[c+5];    memset(dp,0,sizeof(dp));    for(int i=0;i&lt;ind;i++)&#123;        for(int j=c;j&gt;=w[i];j--)&#123;            dp[j] = max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[c]&lt;&lt;endl;    &#125;\na155. 雙子星塔#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,dp[N][N],a[N],b[N],cnt = 0;signed main()&#123;        while(cin&gt;&gt;n&gt;&gt;m)&#123;        if(!n &amp;&amp; !m)break;        cnt+=1;        cout&lt;&lt;&quot;Twin Towers #&quot;&lt;&lt;cnt&lt;&lt;endl;        memset(dp,0,sizeof(dp));        rep(i,1,n)cin&gt;&gt;a[i];        rep(i,1,m)cin&gt;&gt;b[i];                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=m;j++)&#123;                if(a[i]==b[j])&#123;                    dp[i][j] = dp[i-1][j-1]+1;                &#125;                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;        cout&lt;&lt;&quot;Number of Tiles : &quot;;        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    &#125;&#125;\nP. [基礎資料結構 II 及基礎演算法 II ] 樹狀圖形結構演算法a136. 元件測試排程問題#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 30#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,ans[N];;bool edge[N][N],is_root[N];bool is_front(int u, int v)&#123;    if(edge[u][v])return true;    for(int i=0;i&lt;n;i++)&#123;        if(edge[u][i] &amp;&amp; is_front(i,v))            return true;    &#125;    return false;&#125;bool togological()&#123;    int deg[N],sum = 0,ind = 0;    memset(deg,0,sizeof(deg));    rep(i,0,n-1)&#123;        rep(j,0,n-1)&#123;            if(edge[i][j])deg[j] += 1;        &#125;    &#125;    queue&lt;int&gt; que;    rep(i,0,n-1)if(deg[i]==0)&#123;        if(sum == 1)return false;        sum += 1;        que.push(i);    &#125;    while(!que.empty())&#123;        int cur = que.front();sum = 0;        ans[ind++] = cur;        que.pop();        for(int i=0;i&lt;n;i++)&#123;            if(edge[cur][i])&#123;                deg[i]--;                if(deg[i] == 0)&#123;                    if(sum == 1)return false;                    sum += 1;                    que.push(i);                &#125;            &#125;        &#125;    &#125;    if(ind &lt; n)return false;    return true;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    bool flag = 1;    memset(edge,0,sizeof(edge));    fill(is_root,is_root+N,1);    for(int i=1;i&lt;=m;i++)&#123;        char a,b;cin&gt;&gt;a&gt;&gt;b;        int from = a-&#x27;A&#x27;,to = b-&#x27;A&#x27;;        is_root[to] = 0;        edge[from][to] = 1;        if(is_front(to,from))&#123;            flag = 0;            cout&lt;&lt;&quot;Order conflict after getting pair &quot;&lt;&lt;i&lt;&lt;endl;            break;        &#125;        else if(togological())&#123;            flag = 0;            cout&lt;&lt;&quot;Determine the testing sequence after getting pair &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;;            for(int i=0;i&lt;n;i++)cout&lt;&lt;(char)(ans[i]+&#x27;A&#x27;);            cout&lt;&lt;endl;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;No answer&quot;&lt;&lt;endl;&#125;\na137. 勇者冒險#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,0,sizeof(mp));    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return 0;            &#125;            if(mp[nx][ny] == 0)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;    return 0;&#125;\na138. 最小花費的航空之旅#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,k,visit[20];struct Ticket&#123;    int id,cost;    vector&lt;int&gt; next_city;    //陣列ticket[i]存以i為起點&#125;;vector&lt;Ticket&gt; ticket[30];          //ticket[i] 起點為i的聯票struct node&#123;    int cost,cur_pos,visit_pos;    vector&lt;int&gt; used_ticket;    //cur_pos現在所在位置、visit_pos在行程單上位置&#125;;struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;    //讓priority_queue可以pop出最小的cost的路徑&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;        vector&lt;int&gt; temp;        rep(j,1,num-1)&#123;            int k;cin&gt;&gt;k;            temp.push_back(k);        &#125;        ticket[s].push_back(&#123;i,cost,temp&#125;);    &#125;    cin&gt;&gt;k;    rep(i,1,k)cin&gt;&gt;visit[i];        for(auto i : ticket[visit[1]])&#123;         //行程第一個起點的聯票起點        int p = 1;        for(auto j : i.next_city)&#123;            if(p &lt; k &amp;&amp; j == visit[p+1])p++;            pq.push(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);//            cout&lt;&lt;&quot;一開始聯票：&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    &#125;    while(!pq.empty())&#123;        node cur = pq.top();        pq.pop();        if(cur.visit_pos == k)&#123;            cout&lt;&lt;&quot;Cost = &quot;&lt;&lt;cur.cost&lt;&lt;&quot;, Tickets used: &quot;                &lt;&lt;cur.used_ticket[0];            for(int i=1;i&lt;cur.used_ticket.size();i++)                cout&lt;&lt;&quot;, &quot;&lt;&lt;cur.used_ticket[i];            cout&lt;&lt;endl;            break;        &#125;        for(auto i : ticket[cur.cur_pos])&#123;            vector&lt;int&gt; vec(cur.used_ticket);            vec.push_back(i.id);                //將現在使用的第i聯票推入            int p = cur.visit_pos;            for(auto j : i.next_city)&#123;                if(p &lt; k &amp;&amp; j == visit[p+1])p++;                pq.push(&#123;cur.cost+i.cost,j,p,vec&#125;);            &#125;        &#125;    &#125;&#125;\nQ. [題目解析] APCS 程式開發環境、題目解析a140. 物品堆疊#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii p[N];bool cmp(pii a, pii b)&#123;    return a.x*b.y &lt; a.y*b.x;    //p[1~n]變成從上到下&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,0,n-1)cin&gt;&gt;p[i].x;    rep(i,0,n-1)cin&gt;&gt;p[i].y;    sort(p,p+n,cmp);    int weight = 0,ans = 0;    for(int i=0;i&lt;n-1;i++)&#123;        weight += p[i].x;        ans += weight*p[i+1].y;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na160. 線段覆蓋長度#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii a[N];signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;        sort(a,a+n);                int sum = a[0].y - a[0].x,R = a[0].y;        for(int i=1;i&lt;n;i++)&#123;            if(a[i].y &gt; R)&#123;                sum += (a[i].y-a[i].x)-(R-a[i].x)*((R-a[i].x)&gt;0);                R = a[i].y;            &#125;        &#125;        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS檢定"],"tags":["APCS","競賽筆記"]},{"title":"APCS題解：2021年11月","url":"/apcs2111/","content":"P1 修補圍籬題目連結\n題解如果在兩端就直接取旁邊的高度，否則取跟左右邊高度的最小值。\n\n時間複雜度$O(n)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define N 105#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,A[N];signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;A[i];    int ans = 0;    if(A[0] == 0)ans += A[1];    if(A[n-1] == 0)ans += A[n-2];    for(int i=1;i&lt;n-1;i++)&#123;        if(A[i] == 0)ans += min(A[i-1],A[i+1]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\nP2 動線安排(魔王題)題目連結\n題解把線分成橫的跟直的就可以好好處理交叉了!\n時間複雜度$O(h(n + m))$\nAC程式碼#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt = 0, ans = 0;array&lt;array&lt;int, 104&gt;, 104&gt; R, C, I;void add(int r, int c)&#123;    bool ok;    I[r][c] = 1;    cnt++;    if(C[r][c] || R[r][c]) cnt--;    C[r][c] = R[r][c] = 0;    ok = 0;     //直下情況    for(int i = r + 1; i &lt; n; i++)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r + 1; i &lt; n; i++)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //直上情況    for(int i = r - 1; i &gt;= 0; i--)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r - 1; i &gt;= 0; i--)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //橫右情況    for(int i = c + 1; i &lt; m; i++)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c + 1; i &lt; m; i++)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;    ok = 0;     //橫左情況    for(int i = c - 1; i &gt;= 0; i--)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c - 1; i &gt;= 0; i--)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;&#125;void pull(int r, int c)&#123;    I[r][c] = 0;    cnt--;    for(int i = r + 1; i &lt; n; i++)&#123;     //直下情況        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = r - 1; i &gt;= 0; i--)&#123;    //直上情況        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = c + 1; i &lt; m; i++)&#123;     //橫右情況        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;    for(int i = c - 1; i &gt;= 0; i--)&#123;    //橫左情況        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;&#125;signed main()&#123;    int h, r, c, t;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;    while(h--)&#123;        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t;        if(t)&#123;            pull(r, c);        &#125;else&#123;            add(r, c);        &#125;        ans = max(ans, cnt);    &#125;    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot; &lt;&lt; cnt;    return 0;&#125;\n\nBY thanksone\n\nP3 生產線題目連結\n差分作法題解用差分的想法加值，再用前綴還原，最後再排序。最後利用Greedy的想法，將每一項最小的工作量乘上最大的時間，總和即為答案。\n\n            差分差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：b_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：定義一個新的陣列 $b_i$ 表示每一項差分設 $b[l] =  b[l] + v,b[r+1] = b[r+1] - v$將差分的每一項加上前一項（做前綴和 $b[i] = b[i]+b[i-1]$），即為原數列第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了$O(1)$了！\n          \n時間複雜度差分：$O(m)$ 、排序 $O(n\\log n)$\n總時間複雜度：$O(n\\log n + m)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,A[N],B[N];signed main()&#123;    IOS;    memset(A,0,sizeof(A));    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        A[x] += w;        A[y+1] -= w;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];    for(int i=1;i&lt;=n;i++)A[i] = A[i] + A[i-1];    sort(A+1,A+n+1);    sort(B+1,B+n+1);    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans += A[i] * B[n-i+1];    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\n線段樹作法\n很奇怪，最近兩次的APCS第三題都有人想要砸資結，特別是線段樹，可能有些人特別偏愛線段樹吧！\n題解線段樹最原本的應該是區間詢問、單點修改，如果要區間修改的話就會用到懶標，所以實作上相對上比較複雜一點。這一題用線段樹的目的是區間加值，加值完過後的排序以及Greedy跟差分的作法是一樣的，用線段樹真的是多此兩舉（實作較複雜、較耗時）！\n當然，這一題比較特別只有最後一起做單點查詢，因此不用懶標，最侯直接計算一路去經過的答案也行！下面的程式碼就是把完全包含區間的節點加值，不用使用到懶標，最後一次查詢。\n時間複雜度區間加值 $O(m\\log n)$，n個點的詢問 $O(n\\log n)$，排序 $O(n\\log n)$\n總時間複雜度：$O((n+m)\\log n)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,t,A[N],B[N],ans = 0;struct node&#123;    int val = 0,sz;&#125;seg[4*N];void build(int id,int l,int r)&#123;    seg[id].sz = r - l;    if(r - l &lt;= 1)return;    int mid = (l + r) / 2;    build(id*2,l,mid);    build(id*2+1,mid,r);&#125;void modify(int id,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || r &lt;= ql || l &gt;= qr)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[id].val += val;        return;    &#125;    int mid = (l + r) / 2;    modify(id*2,l,mid,ql,qr,val);    modify(id*2+1,mid,r,ql,qr,val);&#125;void query(int id,int l,int r,int val)&#123;    if(r &lt;= l)return;    ans += seg[id].val;    if(r - l == 1)return;    int mid = (l + r) / 2;    if(val &lt; mid)return query(id*2,l,mid,val);    else return query(id*2+1,mid,r,val);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    build(1,1,n+1);    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        y++;        modify(1,1,n+1,x,y,w);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        ans = 0;query(1,1,n+1,i);        A[i] = ans;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];        sort(A+1,A + n + 1);    sort(B+1,B + n + 1);    int ans = 0;    for(int i=1;i&lt;=n;i++)ans += A[i] * B[n-i+1];    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nP4 真假子圖題目連結\n二分搜尋+DFS作法題解一開始看到這題，應該很難通靈出二分搜這個作法（我覺得光把題目看懂就有點難度了）。這題有一個條件要特別注意：\n\n保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合\n這一題每一個觀察員並可看成不是獨立的（假如一個觀察員不產生矛盾，則他回傳的那一些邊都會被沿用），所以題目 $p$ 筆詢問可以聯集一起處理。\n\n將情報員當成點，合作關係當成邊，那麼合法的圖就會有兩個點集，點集中的點互不相鄰，也就是二分圖。\n二分搜第一個使得圖變得不二分的人，把它消失，最多重複3次就做完了。\n\n            為什麼可以二分搜？二分搜是用來找一串01字串的分界點，並且必須具有單調性才能二分搜。這一題之所以會有單調性是因為，當我查詢觀察員$P_i$的回傳資料是否正確時，會將前面 $1$ 到 $i-1$ 的觀察員回傳的所有邊納入考慮。假設有一個觀察員 $P_j(1\\le j &lt; i)$ 回傳的資料是錯誤的，這些邊會導致整張圖變成非二分圖，對於 $j$ 後面的所有點來說，都是非二分圖。這樣就有了以 $j$ 為分界點的單調性，即可二分搜。\n          \n二分圖判斷可以用 DFS 做，DFS 的時候把每個點塗上顏色，如果相鄰的點跟自己顏色一樣就表示這不是一張二分圖。\n時間複雜度$O((n + m + pk)\\log p)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define pb push_back#define mid (l + r) / 2using namespace std;struct e&#123;    int u, v;&#125;;int n;array&lt;bool, 10004&gt; WA;          //不可行的觀察員編號array&lt;int, 20004&gt; vis;          //DFS是否走訪、二分圖顏色array&lt;vector&lt;e&gt;, 10004&gt; E;      //每一個觀察員的回傳邊array&lt;vector&lt;int&gt;, 20004&gt; G;    //存進行DFS的圖bool dfs(int u, int t)&#123;         //用DFS塗色、判斷二分圖    if(vis[u]) return 1;    bool ans = 1;    vis[u] = t;    for(int v : G[u])&#123;        if(vis[v] == t) return 0;        ans &amp;= dfs(v, 3 - t);    &#125;    return ans;&#125;bool check(int p)&#123;               //檢查第p個觀察員回傳是否正確    bool ans = 1;    for(int i = 0; i &lt; n; i++)&#123;        G[i].clear();        vis[i] = 0;    &#125;    for(int i = 0; i &lt;= p; i++)&#123;        for(auto [u, v] : E[i])&#123; //將觀察員的邊推入G            G[u].pb(v);            G[v].pb(u);        &#125;    &#125;    for(int i = 0; i &lt; n; i++)&#123;        ans &amp;= dfs(i, 1);        //將每一個連通塊    &#125;    return ans;&#125;void BS(int l, int r)&#123;           //二分搜觀察員    if(check(r)) return;         //當邊的連集不會讓圖有問題，則回傳    while(l != r)&#123;        if(check(mid)) l = mid + 1;        else r = mid;    &#125;    WA[l] = 1;    E[l].clear();                //剔除一錯誤觀察員&#125;signed main()&#123;    int m, p, k, a, b;    cin &gt;&gt; n &gt;&gt; m;    while(m--)&#123;        cin &gt;&gt; a &gt;&gt; b;        E[0].pb(&#123;a, b&#125;);    &#125;    cin &gt;&gt; p &gt;&gt; k;    for(int i = 1; i &lt;= p; i++)&#123;        for(int j = 0; j &lt; k; j++)&#123;            cin &gt;&gt; a &gt;&gt; b;            E[i].pb(&#123;a, b&#125;);        &#125;    &#125;    for(int i = 0; i &lt; 3; i++)&#123;     //至多三個觀察員        BS(0, p);    &#125;    for(int i = 1; i &lt;= p; i++)&#123;        if(WA[i]) cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nBY thanksone\n\nDSU作法\nIdea From Kennyfs\n\n題解這一題的題目限制有說最多3個錯誤的情報員，因此我們可以用上面二分搜的方式做三次找到答案。如果題目不限制錯誤調查員的數量，也就是用二分搜時間會超時，但是用DSU可以在線性時間內完成！\nDSU的目的在處理集合問題，根據下面這個關鍵條件：\n\n保證若調查員的 k 個 pair 的結果和組長存留的 m 個 pair 不會產生矛盾, 則保證調查員的資料一定和原本 A, B 分組吻合\n\n我們只要對每一筆詢問看會不會與組長手中的pair矛盾即可。如果每一次都做DFS，會發現時間複雜度是 $O(pn)$，必然超時。\nDSU的想法是，我們將組長手中的圖中上每一個連通塊都分別塗上兩種顏色（必為二分圖，因此將兩邊各塗上不同顏色）。接著，把每個顏色當作初始的並查集中的集合，將每一筆觀察員回傳的邊的兩端指向的集合合併起來，過程中如果發生邊的兩端同屬一個集合，表示這是一個錯誤的觀察員。做完每一個觀察員之後，把所有變更過的還原成初始狀態（組長手中的圖）即可。\n\n            舉例8 50 2 1 3 1 2 4 6 5 61 21 4 0 6整個過程就是下面這張GIF：步驟：利用DFS為組長手中的圖上色，每一個連通塊兩色（以編號1,2,3…）將每一個顏色當作並查集元素觀察員輸入的邊兩端 $(u,v)$非同色，表示不發生矛盾，則將u所在集合與v所在集合的對方（連通塊兩色的另一色）合併重複 步驟3 共k次，如果發生$(u,v)$為同一色，則觀察員錯誤。\n          \n時間複雜度$O(n + pk\\alpha)$\nAC程式碼#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 20005#define M 10005using namespace std;int n,m,p,k;int color[N],boss[N],num[N];bool WA[M],f;int other(int s)&#123;return (s%2)?s+1:s-1;&#125; //other為同一連通塊另外一種顏色vector&lt;int&gt; edge[N],change;void init()&#123;                            //初始化    memset(color,0,sizeof(color));    memset(WA,0,sizeof(WA));&#125;void dfs(int id,int col)&#123;           //對所有點上色    color[id] = col;    for(auto i:edge[id])&#123;        if(!color[i])dfs(i,other(col));    &#125;&#125;int find_boss(int id)&#123;              //尋找祖先、及路徑壓縮    if(boss[id] == id)return id;    change.push_back(id);    return boss[id] = find_boss(boss[id]);&#125;signed main()&#123;    IOS;    init();    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    int now = 1;    for(int i=0;i&lt;n;i++)&#123;           //對所有點上色        if(!color[i])&#123;            dfs(i,now);now += 2;        &#125;    &#125;    for(int i=1;i&lt;=now;i++)&#123;boss[i] = i;num[i] = 1;&#125;    cin&gt;&gt;p&gt;&gt;k;    for(int i=1;i&lt;=p;i++)&#123;        change.clear();                                  //儲存待更改的點集f = 0;        for(int j=0;j&lt;k;j++)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            if(f)continue;            x = color[x],y = color[y];                   //尋找邊兩端點的顏色所處的集合            int bx =  find_boss(x),by = find_boss(y);            int ox = find_boss(other(y)),oy = find_boss(other(x));            if(bx == by)&#123;WA[i] = 1;f = 1;continue;&#125;     //位於同一集合，此觀察員是錯的            //以下是啟發式合併（小的集合並到大的集合）            if(num[bx] &lt; num[ox])&#123;                boss[bx] = ox;num[ox] += num[bx];                change.push_back(bx);            &#125;            else&#123;                boss[ox] = bx;num[bx] += num[ox];                change.push_back(ox);            &#125;            if(num[by] &lt; num[oy])&#123;                boss[by] = oy;num[oy] += num[by];                change.push_back(by);            &#125;            else&#123;                boss[oy] = by;num[by] += num[oy];                change.push_back(oy);            &#125;        &#125;        for(auto i : change)&#123;boss[i] = i;num[i] = 1;&#125;   //觀察員的邊結束，看完後復原    &#125;    for(int i=1;i&lt;=p;i++)if(WA[i])cout&lt;&lt;i&lt;&lt;endl;        //輸出最後錯誤觀察員答案&#125;\n\nBY peienwu\n\n","categories":["APCS檢定"],"tags":["APCS","競賽筆記"]},{"title":"生日問題（Birthday Paradox）","url":"/birthday/","content":"有同學問我生日問題的機率感覺蠻好玩的，決定好好研究一番。生日悖論其實不是一個悖論，只是有點違背直覺而已，並非數學中定義的悖論！這一篇會用蒙地卡羅模擬來進行與理論的比較\n問題敘述題目：一個房間要多少人，則兩個人的生日相同的機率要大於50%？\n答案是23人。如果想要看1到100人有同一天的機率可以點這裡！\n機率與人數的關係兩種理解方式對於生日問題可能會有兩種理解方式：\n\n題意：「23人之中兩兩之間存在生日相同」 對於原本題目要闡述的意義可以列出以下數學式：\\begin{split}p(n)&=1-p'(n) \\\\&= 1-(1\\times\\frac{364}{365}\\times\\frac{363}{365}\\times\\cdots\\frac{365-(n-1)}{365})\\end{split}\n錯誤理解：「其他22人與你的生日相同的機率」 這樣的理解會造成算出來的機率大為減少（用全部扣掉皆不相同）：q(n) = 1-(\\frac{364}{365})^n\n\n有了以上兩個關係式，就可以進行圖表的繪製。x軸表示人數，y軸表示機率，可以看出來兩種理解方式會造成機率有很大的差別！\n上圖繪製程式碼：\nimport numpy as npimport matplotlib.pyplot as pltplt.title(&quot;Possibility to Number of people&quot;, fontsize=20) #圖表標題plt.xlabel(&quot;Number of people&quot;, fontsize=16) #x軸標題plt.ylabel(&quot;Possibility&quot;, fontsize=16) #y軸標題d = 1p = 1x = []y1 = []y2 = []for i in range(1,365):    y1.append(1-p)    p = p*d    d = d-(1/365)for i in range(365,400):    y1.append(1)d2 = 364/365for i in range(1,400):    x.append(i)    y2.append(1-d2)    d2 = d2*(364/365)plt.plot(x,y1,&#x27;red&#x27;,label=&#x27;p(n)&#x27;)plt.plot(x,y2,&#x27;blue&#x27;,label=&#x27;q(n)&#x27;)plt.legend(loc = &#x27;upper left&#x27;)plt.show() #顯示繪製的圖形\n這張圖表還可以告訴我們，任兩個人生日相同的機率很高，但相對的，即使有400個人，要有人跟你的生日相同的機率比6成高一點而已，告訴我們「全部的日期至少有一人生日」的機率其實不高！\n其他人與你的生日相同的機率如果在看更仔細一點，對於「其他人與你的生日相同的機率」作圖會呈現下方的圖形\n因為生日是隨機的，因此在很大量數據測試下，我們可以期望共有365人的時候會出現第一個與自己生日相同日期的人！實際以亂數模擬，所得到的期望值次數與理論是相符的！\n#include &lt;bits/stdc++.h&gt;using namespace std;bool birthday[400];int main()&#123;    srand((unsigned)time(NULL));    int sum = 0,t = 5000000,times = t;    while(times--)&#123;        memset(birthday,0,sizeof(birthday));        int target = rand()%365,ind=0;        for(int i=0;;i++)&#123;            ind = rand()%365;            if(target==ind)&#123;                sum+=i+1;                break;            &#125;            else birthday[ind] = 1;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(4);    cout&lt;&lt;&quot;平均於第：&quot;&lt;&lt;(double)sum/t&lt;&lt;&quot;次&quot;&lt;&lt;endl&lt;&lt;&quot;會出現第一個與自己生日相同的人&quot;&lt;&lt;endl;&#125;\n至少k個人生日相同機率對於至少k人生日相同的機率要大於50%，需要的人數如下表：用程式驗證看看：\n\n\n\n\nk\n共N人\n機率\n\n\n\n\n2\n23\n0.506949\n\n\n3\n88\n0.511169\n\n\n4\n187\n0.502883\n\n\n5\n313\n0.501057\n\n\n6\n460\n0.502686\n\n\n7\n623\n0.503298\n\n\n8\n798\n0.500304\n\n\n9\n985\n0.501191\n\n\n10\n1181\n0.500178\n\n\n\n\n根據這一篇提供的公式，在$k≤20$的情況下$n\\cong47(k-1.5)^{\\frac{3}{2}}$，這是這篇作者把k還是很小的時候進行近似，但實際的公式我還不是很了解:cry:\n#include &lt;bits/stdc++.h&gt;using namespace std;int birthday[400],power[1000];int main()&#123;    srand((unsigned)time(NULL));    int sum = 0,t = 10000000,times = t;    int arr[10] = &#123;23,88,187,313,460,623,798,985,1181&#125;;    for(int j=0;j&lt;9;j++)&#123;        times = t;sum = 0;        while(times--)&#123;            memset(birthday,0,sizeof(birthday));            for(int i=0;i&lt;arr[j];i++)&#123;                int ind = rand()%365;                birthday[ind]+=1;                if(birthday[ind]&gt;=j+2)&#123;                    sum+=1;                    break;                &#125;            &#125;        &#125;        cout&lt;&lt;fixed&lt;&lt;setprecision(7);        cout&lt;&lt;(double)sum/t&lt;&lt;endl;    &#125;&#125;\n機率證明公式推討生日問題可以理解成：至少兩人生日相同的機率 這個問題，而否定這個問題即為：「沒有人生日相同的機率」。因為這兩個事件的聯集即為樣本空間，可以用扣的方式得到答案！\n對於房間裡有n人的情況，定義 $p(n)$ 為「至少兩人生日相同的機率」、$p’(n)$ 為「沒有人生日相同的機率」，在不考慮特殊強況（閏年等），並假設生日會平均分佈的狀況下：\n\\begin{split}p(n)&=1-p'(n) \\\\&= 1-(1\\times\\frac{364}{365}\\times\\frac{363}{365}\\times\\cdots\\frac{365-(n-1)}{365})\\\\\\\\&=1-\\frac{365!}{365^n\\cdot(365-n)!}\\end{split}簡單解釋一下，對於每一個加入房間的人都有$365$種可能，因此分母皆為$365$；對於第 $i$ 個加入的人要避開前 $i-1$ 個人的生日，因此分子為$365-(i-1)$。經過整理可以得到這個有階乘又有次方的很難看的一個公式！\n這時候我們可以引入泰勒公式：\n\\begin{split}e^x&=\\sum_{k=0}^\\infty\\frac{x^k}{k!}=1+\\frac{x^1}{1!}+\\frac{x^2}{2!}+\\frac{x^3}{3!}\\cdots\\end{split}為什麼要引入這個公式？是因為我們想要構造出上面機率計算中的每一項 $1-\\frac{x}{365}$ ，因為泰勒公式是一個無窮級數，我們可以適度的做一些取捨，例如只取第一項與第二項（在下去都是小數點4,5位以上了)，得到以下：\ne^x\\cong1+x\\to e^{-\\frac{x}{365}}\\cong1-\\frac{x}{365}接著就可以把每一項替換成多項式的型態：\n\\begin{split}p'(n)&=1\\times\\frac{364}{365}\\times\\frac{363}{365}\\times\\cdots\\frac{365-n+1}{365}\\\\&\\cong1\\times e^{-\\frac{1}{365}}\\times e^{-\\frac{2}{365}}\\times\\cdots\\times e^{-\\frac{n-1}{365}}\\\\&=e^{-\\frac{1+2+\\cdots+(n-1)}{365}}\\\\&=e^{-\\frac{n(n-1)/2}{365}}\\\\&=e^{-\\frac{n^2-n}{730}}\\end{split}接著就可以算出正確的機率了！\n\\begin{split}p(n) &= 1-p'(n)\\\\&\\cong1-e^{-\\frac{n^2-n}{730}}\\end{split}實際機率我利用程式實際運算求出機率，並跟公式解做比較如下：發現到誤差會隨著人數增加而有變大的趨勢，不過都是在小數點後三位的事情，誤差不到1%，所以公式解其實是可以用的！其實可以觀察到一個現象，對於$p’(n)$的理論解都會比實際值高，因為多加了幾項被我們省略掉的數字，因此計算出來的公式解會比實際機率低一些！\n生日攻擊生日攻擊就是利用生日問題的特性在 $\\sqrt{H}$ 的時間暴力破解找出碰撞。Google破解SHA1實現碰撞攻擊，如果有人可以讓兩個不同的檔案得出相同雜湊值，讓攻擊者可能偷偷把惡意的程式碼放進檔案，但得出來的雜湊值跟原本的檔案一樣，使人在沒有防備的情況下誤以為危險檔案安全，這可以達到生日攻擊（也就是找到碰撞）\n雜湊演算法最近有學雜湊相關東西，那剛好生日問題其實跟雜湊很有關係，因為生日可以被當作雜雜湊空間大小，空間越大雖然消耗記憶體較大但發生碰撞的機會會越小。換作是雜湊演算法中，我們想要討論的就是開的空間大小與發生碰撞的嘗試次數的關係。\n首先計算生日問題人數的期望值，也就是在加入第幾個人之後，會發生有兩人生日同一天的情況，以下為模擬的情形：透過公式的計算，可以得到不同人數對應到的機率，假設共i人的情況下機率為f(i)，則f(i)-f(i-1)為加入第i人時恰好有人生日相同的機率，就可以根據期望值的公式算出期望在共有幾人時發生碰撞。以下是計算結果：兩者的誤差極小，可以推論出在平均約在加入第24.617個人的時候會發生碰撞！\n我們已經計算出對於n人的情況下任兩人生日相同的機率，這時候可以推廣到不只是365天，也就代表在雜湊空間大小為d的時候發生碰撞的機率如下：\n\\begin{split}p(n) &= 1-p'(n)\\\\p(n,d)&\\cong1-e^{-\\frac{n^2-n}{2d}}\\end{split}因此我寫了一個實際模擬的程式跟這個公式模擬的結果做比較，根據空間大小分別為365與1000做討論，結果如下：\n由模擬的結果可以看出，若一年有1000天（假設而已！）則在38個人的團體中任兩人生日同天的機率已經超過50%，跟直覺相差挺大的！\n給定機率預測最多數量在上面的做法是人數計算機率，可以換一個方式，給定碰撞機率求最多的人數為多少。可以從上面的公式來推，以下n,H分別代表數量與空間大小：\n\\begin{split}p(n,H)&\\cong1-e^{-\\frac{n^2-n}{2H}}\\cong1-e^{-\\frac{n^2}{2H}}\\\\&\\to e^{-\\frac{n^2}{2H}}=1-p\\\\&\\to e^{\\frac{n^2}{2H}}\\frac{1}{1-p}\\\\&\\to\\frac{n^2}{2H}=\\ln\\frac{1}{1-p}\\\\&\\to n(p,H)\\cong \\sqrt{2H\\ln\\frac{1}{1-p}}\\end{split}因為我們把$n^2-n$當成$n^2$，所以在小範圍估計的時候會有比較大的誤差，不過當n很大的時候，量級就會是$n^2$，因此可以忽略一次方的$n$\n首次碰撞的期望值次數在上面有做一次期望值的估計，不過過程蠻麻煩的，要先算出每一個數量機率的差，再乘上數量並加總。這邊有一個公式是提供在範圍很大時的一個估計公式：\nQ(H)\\cong\\sqrt{\\frac{\\pi}{2}H}這導出一個重要的結論：對於n位密碼共有$2^n$種可能組合，確僅僅需要期望$2^{\\frac{n}{2}}$次嘗試就可以遇到碰撞！以下嘗試H=800000筆與H=1500000筆數據，會有一點誤差，可能的原因是測試的樣本數不夠(100萬次)\n\n程式碼實作的概念就是開一個$O(n)$的陣列紀錄，如果遇到之前出現過的就記錄下來\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;bool hash_map[2000006];int main()&#123;    ios;    srand((unsigned)time(NULL));    int N,M;cin&gt;&gt;N&gt;&gt;M; //N筆輸入,空間大小M    int t = 1000000;    int times = t,sum = 0;    while(times--)&#123;        memset(hash_map,0,sizeof(hash_map));        for(int i=0;i&lt;N;i++)&#123;            int temp = rand()%M;            if(hash_map[temp]==0)hash_map[temp] = 1;            else&#123;                sum+=i;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    cout&lt;&lt;&quot;對於輸入筆數共有：&quot;&lt;&lt;N&lt;&lt;&quot;、空間大小為：&quot;&lt;&lt;M&lt;&lt;endl&lt;&lt;&quot;第一次發生碰撞次數平均值為：&quot;&lt;&lt;(double)sum/t&lt;&lt;endl;    cout&lt;&lt;&quot;理論預測次數：&quot;&lt;&lt;sqrt(M_PI_2*M)&lt;&lt;endl;    // cout&lt;&lt;&quot;理論預測：&quot;&lt;&lt;1-exp(-(N*(N-1)/(double)(2*M)))&lt;&lt;endl;&#125;\nCheryl’s birthday這一題跟生日問題沒啥關係，但既然都提到「生日」，就來看一題有趣的\n\n艾伯特和柏納剛認識雪莉兒，想要知道雪莉兒的生日，雪莉兒列出了十個可能的日期：5月15日、5月16日、5月19日、6月17日6月18日、7月14日、7月16日、8月14日8月15日、8月17日接著雪莉兒分別告訴艾伯特及柏納她生日的月及日，以下是艾伯特和柏納的回應\n艾伯特：我不知道雪莉兒的生日是哪一天，但我知道柏納也不知道柏納：一開始我不知道雪莉兒的生日，但現在我知道了艾伯特：那我也知道雪莉兒的生日了請問雪莉兒的生日是那一天？\n[註：艾伯特的第一句話他確定柏納100%不知道生日是哪一天]\n\n解答點此：\n\n第一句話中，柏納若要知道明確的生日日期，唯一的可能是生日日期的日在十個可能日期中只出現過一次，也就是18日和19日。但艾伯特說他知道柏納也不知道生日是哪一天，因此可以可以排除5月和6月的所有日期（如果是5月或6月有一定的機會艾伯特無法確定柏納不知道是哪一天）\n\n根據第一句話柏納可以推測月份是7月或8月，而他已經知道生日是哪一天，表示他知道的日是在7月或8月中只出現過一次的日，因此可以排除7月及8月可能生日中都有出現的14日，柏納知道的日可能是15日、16日或17日。\n\n目前還有可能的生日是7月16日、8月15日及8月17日，而艾伯特在聽完第二句話就可以知道生日是哪一天，表示他知道的月份在7月16日、8月15日及8月17日中只出現一次。因此他知道的月份是7月，生日是7月16日。\n\n\n答案是7月16日。\n\n這一題跟生日問題其實沒什麼關係，就當作是一個「生日」有關的有趣邏輯推理的題目吧！\n結論整理以上提到的公式吧\n已知人數推算機率\\begin{split}p(n)&=1-\\frac{365!}{365^n\\cdot(365-n)!}\\end{split}\\begin{split}p(n) \\cong1-e^{-\\frac{n^2-n}{730}}\\end{split}已知機率預測數量（也就是人數）\\begin{split}n(p,H)\\cong \\sqrt{2H\\ln\\frac{1}{1-p}}\\end{split}首次碰撞的期望值Q(H)\\cong\\sqrt{\\frac{\\pi}{2}H}沒想到生日問題可以衍伸出如此多、如此繁雜的數學公式，不僅僅是數學領域，在資安上面也扮演了一個非常重要的角色，也就是雜湊空間為H的時，根據公式我們可以期望在$\\sqrt{H}$的嘗試內找到碰撞，也就是所謂的Birthday Attack！\n附錄一些數學證明：\n\n參考資料密碼學系列之：生日攻擊維基百科：生日問題Diaconis and Mosteller 1989 - methods for studying coincidences\n","categories":["數學筆記"],"tags":["數學","2021暑期筆記","機率"]},{"title":"伯特蘭悖論（Bertrand Paradox）","url":"/bertrand/","content":"簡介Bertrand Paradox是Bertrand他在他的一本書中提到關於機率論的悖論，他以「在圓上產生隨機的弦」來說明當沒有嚴謹的定義好產生隨機的「方法」，就有可能產生許多合理但結果卻完全不同的答案。\n悖論如下：給定一個平面上的圓，內接一個邊長為 $T$ 的正三角形。接著隨機產生園內的一條弦，想問這條弦的長度大於 $T$ 的機率有多大？以下三個方法會分別產生出三個不同的結果，影片、圖片部分是用manim以及matplotlib繪製而成的。\n產生弦的不同方法方法1：隨機端點這是最直覺產生弦的方法，隨機選擇圓上的兩個點連成一條弦。如下圖，不失一般性假設其中一個點是$A$，則另外一個點可能落在$A1,A2,A3$的弦上。若要產生大於三角形邊長的弦，則必須落在$A3$上，其機率為$\\frac{1}{3}$。\n\n以下影片為模擬隨機產生弦的狀況，弦長度大於 $T$ 機率約為$0.33$左右。\n\n\n\n將產生的弦描繪出來如下圖：\n方法2：隨機半徑此作法是隨機產生一條半徑，假設其與圓周交於$A$，接著隨機在半徑上找一點，做出過此點且與半徑垂直的弦。我們可以發現，當點的位置下圖綠色線段上時，弦的長度大於 $T$，在黃色線段時則小於 $T$。\n黃色與綠色線段長度相等，因此產生大於 $T$ 的弦長機率為$\\frac{1}{2}$，約莫$0.5$左右。\n\n\n@@ 方法3：隨機中點\n將產生的弦描繪出來如下圖：\n\n方法3：隨機中點此作法是在園中隨機產生一個點，以此點為中點產生一條弦。以下圖來說，假設此點在小圓內，則弦長會大於 $T$，在小圓外則小於 $T$，若恰好落在小圓圓週上，則弦長等於 $T$。\n由於小圓的半徑是大圓半徑的一半（可以假設大圓半徑$R$，$T = \\sqrt3R$，小圓圓心落在三角形重心上證明），小圓大圓面積比為$1:4$，因此長度大於 $T$ 的弦機率為$\\frac{1}{4}$。\n\n透過模擬得到機率約為$0.25$左右，當樣本數越高，機率會越精準。\n\n\n將產生的弦描繪出來如下圖，跟前面兩個比起來，通過圓中心附近的弦數量較少：\n\n三者比較利用matplotlib畫出每條弦的中點並留下軌跡，可以得到下面的圖形，隨機端點與隨機半徑產生的圖形比較相近，集中在圓的中心，而隨機中點的分佈則十分平均。\n方法1：隨機端點\n方法2：隨機半徑\n方法3：隨機中點\n在沒有給定額外資訊的情況下，並沒有哪一種方法才是所謂正確解答，不存在唯一的選擇方法，那麼也就不存在一個唯一的解答。\n參考資料此篇文章的目的在熟悉manim製作動畫以及matplotlib的操作，內容皆為已知喔。\nGithub: Code and Photos\nBertrand’s Paradox (with 3blue1brown) - Numberphile\nWiki: Bertrand paradox)\n","categories":["數學筆記"],"tags":["數學","機率"]},{"title":"使用Hexo搭配GitHub架設個人部落格","url":"/blog/","content":"本網頁就是利用github page架設的部落格，使用Hexo搭配Next主題。暑假常常寫題，都幾乎紀錄在Hackmd上，如果能有屬於自己的部落格、用自己的網址，感覺超酷！來自己架設一個試試看！\n網域種類架設網站有好多種方法，有時候是看題解看到了很多的網站XD，上網查了資料以及很多人的部落格，發現寫coding部落格的人的網站大多分成以下四類：\n\nBlogger\nHexo\nGitHub Pages\nWordPress.org\n\n\n每一種部落格都有優勢與劣勢，就看使用者覺得哪一個平台使用起來比較方便！在經過多方嘗試之下，最後我是選擇了使用 Hexo 搭配 Github 來架設我的網站，以下來分析一下我個人在架設的過程中，以一個新手的角度看各個平台使用上的優缺點！\n\n\n\n\n網站比較\n優點\n缺點\n\n\n\n\nBlogger\n1. 介面清楚，操作方便2. 一鍵預覽及發布，快速查看文章成果3. 免費！\n1. 不支援MarkDown語法2. 對數學式、程式碼支援不便利\n\n\nHexo\n1. 支援MarkDown語法2. Mac終端機操作方便3. 免費！\n1. 純程式碼呈現，較不直覺2. 修改過程中如果程式碼出錯，造成整個網站掛掉\n\n\nGitHub Pages\n1. 支援MarkDown語法2. 進行版本控制3. 免費！\n1. 單純使用的話操作、修改不方便2. Git操作有一定難度\n\n\nWordPress com\n1. 跟Blogger相近，操作簡單易上手2. 快速查看文章長相\n1. 不支援Markdown2. 免費版限制多、模板不漂亮\n\n\nWordPress org\n太貴不考慮\n上網查必須要先付費才能開始架設費用好像一年3000以上\n\n\n\n\n經過多方嘗試（花了我好多天），出產了一堆失敗品，最後還是用 Hexo 搭配 GitHub 來架設一個算滿意的網站（至少看起來不錯XD）。以下是我的失敗品網站：\n\nBlogger\nWorldPress\nGithub的我已經刪掉了\n\nHexo 安裝之前遇上很多軟體對Mac都不友善，不過Hexo卻是對Mac的用戶比較友善的工具。只要在終端機輸入以下命令就可以安裝Hexo：\nnpm install -g hexo-cli\n詳細的安裝步驟可以參考官方網站，或是網路上的教學影片就可以一步一步的把網站建立起來！\n在這過程中，我發現影片上有使用到VS Code，於是我就把它也載下來了。用起來感覺VS Code 對專案製作很有幫助，可以同步的在各個檔案之間進行修改，蠻實用的一個IDE！\nGitHub同步將 Hexo 裡面的檔案推送到 Git Hub 裡面的一個Repository中，利用它來將網頁的內容進行發布。在每一次本地修改完成之後，如果本地測試可行，就可以將檔案推送到Github中，在Github將網站進行發布。我使用來架設部落格的Repository在此。\ngit add .                //加入git commit -m &quot;xxx&quot;      //提交git push                 //推入git push -f              //強制推入（聽說很危險）\n在提交的後面的字串表示當前版本的一個提示，例如我做了什麼修改就可以顯示在上面，讓別人知道這份檔案被更改的情況。下圖就是在每一次推入時附加的修改資訊，讓我自己可以看到檔案被更改以及提交的狀況!\n\nGit真是博大精深，版本控制真的有難度，我只會簡單的修改以及推入（之後找時間可以學一下）。\n外掛安裝做到這一個步驟已經花了我快三小時，出現的是類似以下的畫面：\n\n這是 Hexo 預設的樣板，感覺還不錯，不過我的目標是使用另外外掛的模板，看起來比較漂亮XD。於是我就找了Next主題的外掛來安裝，這個模板就感覺舒服很多。這個模板使用的大陸部落格很多，也有一些其他的競程部落格使用了這個主題！\n\nHexo NexT 美化上網查關鍵字其實有很多美化的資訊可以參考，不論是字體或版面配置都有很多種選項可以選擇。最一開始是設計版面的部分，將網站總共分五個子類別，分別是首頁、檔案、類別、標籤以及關於，這五個經典的配置。接下來就是個人資訊的設定，加入自己的圖片以及說明：\n以及在網頁瀏覽標籤上方設定icon：\n當然最重要的就是文章內容，因為是使用Markdown語法，剛好有幾篇筆記就丟上去看看。當然還有很多的優化以及美化，如果有什麼需要改進的地方要跟我說喔！\nDisqus 留言板功能在每一篇文章下方加入留言板功能，感覺還蠻酷的！\n\nGoogle Analytics 追蹤分析這是酷東西，使用google 帳號生成一組代碼之後，把一些它提供的程式碼埋到網站中，它可以即時的統計網站的瀏覽狀況，以及觸及、感興趣的主題等等。假設未來瀏覽的人次比較多的時候（可能根本沒人會看XDD），還可以用它來分析哪一種文章最受人歡迎、哪一種文章最冷門之類的！\n\n購買個人網址昨天終於買到了自己名字的網址了！新的網址名稱是：peienwu.com！在Godaddy 上用NT570元買了一年這個網址的使用權限，買完之後到CloudFlare設定好Dns之類的，讓這個網址可以指向一個IP位址（這其中的原理有點複雜）。\n設定完之後，發現他一直出現錯誤訊息，點開網址也是不可使用的，差點昏倒ww。晚上處理不了了，隔天一早起床就開始著手處理中這個問題，把檔案刪刪改改，終於成功讓GitHub跳出以下訊息：\n\n很討厭的，他沒有https，也就是鎖頭，在這種情況下，瀏覽器就會自動設置為不安全的網站，接下來早上的時間都拿去處理這個問題。在設定一些SSH以及https的安全性設定之後，終於，在訪問網站時拿到了鎖頭的認證！\n\n留言板更新最近重新登入後發現文章底部都是一堆Disqus的廣告，真的有夠討厭，如果要消除廣告的方法只剩下付費，好討厭！於是我決定換一個評論系統，叫做Valine 的系統，他的優點是支援Emoji 😉、MarkDown 全语法支持，而且沒有廣告！大概的留言就像以下這樣：\n支援Markdown的留言真的很酷！\n至於留言管理的部分，則是用LeanCloud 來實現，可以刪留言之類的XD\n抱怨一下今天在用Icloud 的時候，不小心把電腦上所有的檔案全部刪掉了，哭啊，這真是嚴重的事情ＱＱＱ，用到快掛了！當然，我電腦上的所有東西都不見了，也包括這一個部落格的本地程式碼，我用了 google drive 的備份，可惜那很難下載，所以我就用了github原本的備份的東西。\n這真是不幸中的大幸，還好github的備份直接下載就可以直接用，不用特別再設定一些奇怪的東西，但所有的 hexo 指令都不見了，git的指令也都不見了，必須要重新設定。\n這邊有一個小東西，就是下面這一行警告，就是要你把push設定成你要push的地方，不然只打一個push他並不會知道要push去哪裏，所以設定一下repo的位置就好了。\n\ngit push —set-upstream origin master\n\n當然還有一堆bug ，只好慢慢爬文嘍，當你看到這一段文字，也就代表我成功找到解決辦法了！\n我又來更新了這幾天網站一直404 not found 超煩，於是我叫出之前的教學影片，重新看了之後，發現我的分支名稱弄錯了，不是用master而是用gh-pages，搞了好多天QQ\n架設心得部落格以後會常常更新，最近也會陸續把之前的文章放到部落格上面。整個網站從誕生到現在的結果已經花了15個小時，其中在Debug的時間應該佔了大多數！\n遇到了幾個麻煩的問題，首先碰到的是本地的資料無法上傳到Github，終端機冒出來的是：Please make sure you have the correct access rights and the repository exists.。這個錯誤超級煩，爬了一堆文結果他要在GitHub上面設定ssh金鑰之類的東西，才能獲取從本地更新的權限。結果網路上的文章說我要開啟一個名叫”.ssh”的資料夾，可是我翻遍了我的電腦也找不到這一個資料夾！後來我是利用終端機，輸入路徑位置硬是把那一個資料夾打開，它是一個透明的資料夾，還是第一次遇到！\n接著是終端機跑出一堆error，那時候真的差點崩潰，花了超久架設的東西，竟然跑出這麼多的錯誤！難道全部的東西都付之一炬了嗎？翻了每一個被變更過的資料夾，才發現到在user_name的地方踩了雷，把他變回原本的設定就好了，真是不幸中的大幸，幸好我還能把東西救回來！\n最後，終於能用https的前綴連到我的網站：https://peienwu.com 。如果要打www開頭也是可以連得上，直接打 peienwu.com 也可以順利連上！測試修改\n","categories":["其他"],"tags":["個人部落格","網站架設"]},{"title":"Educational Codeforces Round 103 (Rated for Div. 2)","url":"/cf1/","content":"\nRating change:1137-&gt;1197(+60)\nProblem solved: 1\n\n\nProblem 1題序：點此\n            You are given two integers 𝑛 and 𝑘.You should create an array of 𝑛 positive integers 𝑎1,𝑎2,…,𝑎𝑛 such that the sum (𝑎1+𝑎2+⋯+𝑎𝑛) is divisible by 𝑘 and maximum element in 𝑎 is minimum possible.What is the minimum possible maximum element in 𝑎?InputThe first line contains a single integer 𝑡 (1≤𝑡≤1000) — the number of test cases.The first and only line of each test case contains two integers 𝑛 and 𝑘 (1≤𝑛≤10^9^; 1≤𝑘≤10^9^).OutputFor each test case, print one integer — the minimum possible maximum element in array 𝑎 such that the sum (𝑎1+⋯+𝑎𝑛) is divisible by 𝑘.\n          \n解題想法一開始看到測資範圍：10^9^，就想到O(n)的時間複雜度是不可行的（有好多人在賽後因為這樣被hack）。一開始的想法是分段討論：n = k, n &gt; k, n &lt; k\n#include &lt;bits/stdc++.h&gt;using namespace std;int t; signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;cin&gt;&gt;n&gt;&gt;k;        if(n==k)&#123;            cout&lt;&lt;1&lt;&lt;endl;            continue;        &#125;        if(n&gt;k)&#123;            if(n%k==0)cout&lt;&lt;1&lt;&lt;endl;            else cout&lt;&lt;2&lt;&lt;endl;        &#125;        else&#123;            int temp = k/n;            if(k%n==0)cout&lt;&lt;temp&lt;&lt;endl;            else cout&lt;&lt;temp+1&lt;&lt;endl;        &#125;    &#125;&#125;\n看過別人程式碼後，發現其實也可以這樣改：\n#include&lt;iostream&gt;using namespace std;int main() &#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;cin&gt;&gt;n&gt;&gt;k;        k = k*(int)((n+k-1)/k);//大於等於n的k的最小倍數        if(k%n==0) cout&lt;&lt;k/n&lt;&lt;&#x27;\\n&#x27;;        else cout&lt;&lt;k/n+1&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\n而官方解法則是完全的數學，把式子寫出來之後，直接O(1)的複雜度算出答案\n            Let’s denote 𝑠 as the sum of array 𝑎. From one side, since 𝑠 should be divisible by 𝑘 then we can say $𝑠=𝑐𝑓⋅𝑘$ From other side, since all 𝑎𝑖 are positive, then $𝑠≥𝑛$.It’s quite obvious that the smaller $𝑠$ — the smaller maximum $𝑎𝑖$ so we need to find the smallest $𝑐𝑓$ that $𝑐𝑓⋅𝑘≥𝑛$. Then𝑐𝑓=⌈\\frac{𝑛}{𝑘}⌉=⌊\\frac{𝑛+𝑘−1}{𝑘}⌋Now we now that $𝑠=𝑐𝑓⋅𝑘$ and we need to represent it as 𝑎1+⋯+𝑎𝑛 with maximum 𝑎𝑖 minimized. It’s easy to prove by contradiction that maximum𝑎𝑖≥⌈\\frac{𝑠}{𝑛}⌉.Moreover we can always construct such array 𝑎 that its sum is equal to 𝑠 and the maximum element is equal to $⌈\\frac{𝑠}{𝑛}⌉$As a result, the answer is⌈\\frac{𝑠}{𝑛}⌉=⌊\\frac{𝑐𝑓⋅𝑘+𝑛−1}{𝑛}⌋, 𝑐𝑓=⌊\\frac{𝑛+𝑘−1}{𝑘}⌋.\n          以下為官解：\n#include&lt;bits/stdc++.h&gt;using namespace std;int t;int main()&#123;  cin &gt;&gt; t;  while(t--) &#123;    long long n, k;    cin &gt;&gt; n &gt;&gt; k;    long long cf = (n + k - 1) / k;    k *= cf;        cout &lt;&lt; (k + n - 1) / n &lt;&lt; endl;  &#125;  return 0;&#125;\n解題紀錄\n            這一題共花了17分鐘才寫出來可能是對題目的反應不夠快，沒有第一時間就想出解法但第一題就應該是要很簡單的呀！第一題是拚速度，速度快就可以排名比較前面(我看有許多人不到5分鐘就寫完了！)\n          \nProblem 2題序：點此\n            題目敘述給定兩個整數n,k，與n個整數p~0~,p~1~,…𝑝~𝑛−1~  (1≤𝑝~𝑖~≤10^9^),其中p~0~代表物品的原始價格，𝑝~𝑖~則代表在第 𝑖-個月的價格變化。k代表每個月的通脹係數不得超過 𝑘％，因此必須對𝑝~𝑖~增加一些值，使所有𝑝~𝑖~為整數且每個月的通脹係數不超過 𝑘％。試求最小的𝑝~𝑖~增加值為何？範例測資&gt;輸入：24 120100 1 202 2023 1001 1 1輸出：990\n          \n解題想法依照題意，開一個長度為n的陣列，由第一天的上升價格開始，依序計算看會不會超過k%的膨脹係數。\n            Let sum = p$0$+p$_1$+$\\cdots$+p${i-1}$x 為 p$_{i}$要加的整數則：\\frac{p_i}{sum+x} \\le \\frac{k}{100}經過通分後：x = \\lceil\\frac{100\\times p_i-sum\\times k}{k}\\rceil\\ge0\n          \n因此可以寫出以下程式碼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int t,arr[105]; signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,k,base,sum =0,ans = 0;        cin&gt;&gt;n&gt;&gt;k&gt;&gt;base;        sum=base;        for(int i=0;i&lt;n-1;i++)cin&gt;&gt;arr[i];        for(int i=0;i&lt;n-1;i++)&#123;            if(100*arr[i]&gt;k*sum)&#123;                int temp = ceil((arr[i]*100-sum*k)/(double)k);                ans+=temp;                sum+=temp;            &#125;            sum+=arr[i];        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n\n            int temp = ceil((arr[i]*100-sum*k)/(double)k);這一段程式碼可以改成：int temp = (arr[i]*100-sum*k+k-1)/k;也可以達到取上高斯的效果後者時間快上許多\n          \n解題紀錄當初在寫的時候忘記要在減完後除以k，因此吃了三次WA所以以後知道，在寫題目之前，最好都先把數學式寫得清楚在解題的時候才不會犯下這種錯！另外，我現在才知道，取下高斯就是除法的double轉int就可以了上高斯的話，除了用 ceil() 函式，還可以用上面那個方式來達到同樣的效果。這一次rating change 剛好差了3就到1200，真是可惜，還要再打一場才可以升去\n\n            這一場主要學到的重點應該是怎麼樣把取上高斯轉換為下高斯（不用ceil()取）!\n          \n","categories":["C++基礎主題","CF"],"tags":["CF","競賽"]},{"title":"2021.2.5 Codeforces Round","url":"/cf2/","content":"\nRating change:1197-&gt;1201(+4)\nProblem solved: 2\n\n終於上綠了！！這次只有加四（加的分數越來越少，表示要更強才能加更多分），統計一下總共打了六場才升到 rating 1200。\n\nProblem 1題序：點此\n解題想法看完題目花了我大概五分鐘（太慢！），理解題意後發現蠻簡單的，只要分別統計 U,D,R,L 的數量即可，判斷  U,D,R,L的數量足不足夠到指定的目標。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int t; int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        string s;        int x,y;cin&gt;&gt;x&gt;&gt;y;        cin&gt;&gt;s;                int arr[4] = &#123;0&#125;;        long int len = s.length();        for(int i=0;i&lt;len;i++)&#123;            if(s[i]==&#x27;U&#x27;)arr[0]++;            else if(s[i]==&#x27;D&#x27;)arr[1]++;            else if(s[i]==&#x27;R&#x27;)arr[2]++;            else if(s[i]==&#x27;L&#x27;)arr[3]++;        &#125;        if(x&gt;=0 &amp;&amp; x&lt;=arr[2] &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=arr[0])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else if(x&gt;=0 &amp;&amp; x&lt;=arr[2] &amp;&amp; y&lt;=0 &amp;&amp; abs(y)&lt;=arr[1])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else if(x&lt;=0 &amp;&amp; abs(x)&lt;=arr[3]&amp;&amp; y&gt;=0 &amp;&amp; y&lt;=arr[0])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else if(x&lt;=0 &amp;&amp; abs(x)&lt;=arr[3]&amp;&amp; y&lt;=0 &amp;&amp; abs(y)&lt;=arr[1])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;&#125;\n結果我還是吃了wa，因為沒有 &lt;= 寫成 &lt;，改完之後（改太快沒有注意到）結果CE，每一次上傳都要自己先編譯過啊，才不會犯這種低級錯誤！\n解題紀錄這一題用了30分鐘才寫出來，同學用了大概17分鐘就解出來了。這大概是我第一次體會到 coding 的速度跟不上腦袋想的速度（力不從心），明明已經想到要怎麼解，卻寫得很慢。所以看題目的時間＋手速很慢＝得分很少。寫程式的速度需要時間慢慢培養，首先要做的就是加快打字的速度！除此之外，還要避免犯下低級錯誤，務必要在上傳之前先檢查一下!\nProblem 2題序：點此\n解題想法直覺想到就是模擬第1顆球到k-1顆球，就可以推得第k顆球的位置\n#include &lt;iostream&gt;using namespace std;int t; int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;cin&gt;&gt;n&gt;&gt;k;        int arr[n];        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];                while(--k)&#123;            int ind = 0;            while(arr[ind]&gt;=arr[ind+1] &amp;&amp; ind&lt;n-1)ind++;            if(ind!=n-1)arr[ind]++;            else break;        &#125;        int i=0;        while(arr[i]&gt;=arr[i+1] &amp;&amp; i&lt;n-1)i++;        if(i!=n-1)cout&lt;&lt;i+1&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;    &#125;&#125;\n解題紀錄寫到一半看到k的的大小 10^9^，還以為O(n)的複雜度會tle，不過我寫完丟上去測，過了！（我還跟同學說這個問題，結果他就去想有沒有其他O(n)以下的解法，後來他就沒有寫出來）不過花了28分鐘寫出來之後，看了範圍限制想了想，有一個關鍵的條件：\n1≤𝑛≤100, 1≤ℎ𝑖≤100the sum of 𝑛 over all test cases does not exceed 100.也就代表卡在中間的球數不會超過$(𝑛−1)⋅(100−1)$個，也就是說，最多從第$(𝑛−1)⋅(100−1)+1$ 個開始，接下來每一顆球都會一路望下滑，不會卡在中間，這時候迴圈就可以break了。看來 10^9^只是拿來嚇人的，正常模擬是不會tle的（某同學丟了3次還是wa）。\n心得這是目前的rating，昨天+4 之後終於變成綠色了！這個是目標\n            希望接下來可以順利參加資訊之芽，好好讓自已變強，學一些dp還有其他的演算法，把學長的講義看完然後學起來，在高二的時候可以打比賽！\n          \n","categories":["C++基礎主題","CF"],"tags":["CF","競賽"]},{"title":"社團參與：機器人研習社學習歷程","url":"/club1/","content":"設計思考（Design Thinking）活動概述利用寒假的空檔跟社團的同學們到仁愛的社會創新實驗中心進行一天的設計思考課程\n活動內容主要是學習Design Thinking 的精髓以及步驟，以高中生的角度針對 108新課綱 的議題進行設計思考，透過體、煉、創、塑、試這五個階段，分析使用者的需求，最後進行產品的分享\n主要目的是希望藉由這個活動，讓我們站在使用者的立場去思考什麼問題是需要被解決的，從客戶的立場思考一件商品的如何設計出人們滿意的使用體驗\n學習內容設計思考的老師在給定題目範圍之後，要我們為了108課綱的高中生，提供一個有吸引力的產品或服務，以取得創業的資金\n\n於是參考設計思考的以下步驟：\nEmpathize，同理思考第一個步驟是「體」，也就是站在我們立場，在108課綱中遇到的種種問題，例如學習歷程的製作、自主學習的內容、服務學習進行的方式等\n在這一個步驟，我們利用曼陀羅思考法將想法寫下來，把「客戶」、也就是高中生的煩惱在九宮格中呈現出來\nDefine，需求定義接下來是需求定義，在這一步驟中我們彙整出個組員的九宮格的內容，把他寫在便條紙上，並討論有哪一些想法是可以使用的，淘汰不符合消費者需求的想法，同時歸納出幾個我們認為重要的需求\nIdeate，創意發想接下來就是將留下來的便利貼分門別類貼在海報上，在過程中因為經過大家意見的討論與統整，會產生出新的想法，經過與組員的討論，也一併將其在海報上呈現\n我們分別針對老師、學生兩個角度對新制實施的想法，並在便利貼上貼紅色的圓標籤表示贊同一個想法，越多紅標籤就代表這個想法有越多人贊同\nPrototype，模型設計再來是Prototype 的設計，將想法彙整在海報上後，透過小組的討論後，我們的產品是架設一個支援家長、老師、學生三方可以密切溝通的網站，訴求有一下三點：\n\n教師與學生可以做到即時的溝通，讓教師可以清楚掌握學生學習進度\n家長可以利用這個平台，即時掌握學生的學習狀況，減少家長的負擔\n學生使用這個平台更方便的取得家長與老師的意見，進行學習的調整\n\n於是，我們將這一個構想（網站）以畫圖的方式呈現在紙上，並與他組的同學分享我們的產品，並請他們提出改善的建議\nTest，模擬測試最後的步驟是模擬測試，我們上台發表的方式向同學與老師們分享我們架設網站的想法，雖然在最後的綜合評分中我們並沒有拿到最高票，但能實際參與整個過程讓我收穫很多\n心得在設計思考的活動中，實際參與了一個從同理思考、需求定義、創意發想、到模型設計與模擬測試的整個過程。\n首先是創意發想的部分，原本以為自己已經將所有可行的想法列出來了，但在看到別人的九宮格之後發現原本看一件事情可以有這麼多的面向！這告訴我，與他人的溝通討論除了可以獲得更多的想法之外，還能重新審視自己的思考是不是有出現盲點\n接下來的的意見分享也讓我學到很多，在有了一個初步的想法後，邀請別組的同學來聽聽我們的構想，在過程中我擔任介紹產品的角色（也就是推銷員），要如何清楚、完整、有條理的介紹我們的產品，並推薦別人使用我們的產品是一件蠻困難的事！\n最後是下面這張圖的小遊戲，兩邊拿到相同的樂高零件，一邊的人要透過講話的方式教導另一邊的同學拼出正確形狀的模型。過程看似很簡單，但其實要做到完全正確卻十分的困難，往往會差一個角不一樣而失敗，告訴我們一般只用口頭的溝通常常會產山誤解與矛盾，要透過不同的方式（如實際演示）精準的傳達我們希望表達的訊息！\n\n校外參訪活動參加比賽與製造比賽機器與購買零件都要花錢，因此我們藉由參訪校外與機器人製造相關的公司，一方面募款、一方面也讓我們見識見識在平常這些公司在做些什麼\n時碩科技利用一次自主學習時間的下午參訪了時碩科技公司。會參訪時碩是因為建中有一位大學長在那邊擔任工程師，他向我們介紹了時碩科技主要專攻的精密汽車零件與航空精密機械，並展示了他們整個工廠的生產線\n工廠參觀跟著大學長的腳步參觀了時碩工業的工廠，從汽車零件到航空精密機械都在他們的生產範圍內，並介紹工廠的設備與相關運作模式\n讓我最訝異的是整個工廠放眼望去不見半個人影，全部都是機器運作的聲音，與螢幕標示著整個工廠的機器是否正常運行，讓控制室內的人可以隨時掌握工廠運作的狀況\n下方櫃子內放的是時碩在製造的汽車零件，有下方的圖片則是製造零件的機器。參訪過程中，大學長不斷提到標準化的規格是多麽重要，因為他們是製造汽車與航空相關的零件，要是出什麼差錯可是攸關人命的！\n董事長演講時碩工業的董事長黃亞興向我們介紹了整個時碩工業的歷史，從當初的創立到現在是如何一步步克服難關達到現在的成就。學到最多的應該是他的人生觀，儘管一路上困難重重，面對時代變遷的轉型問題，他是如何堅持的走下去，追求在領域上的頂尖水平。\n\n心得時碩工業是一家市值超過30億台幣的公司，能參觀這樣的一家公司並由董事長親自演講，告訴我們在面對困難與挫折堅持下去態度，結合他自身的經驗告訴我們在一個領域達到頂尖的重要性，讓我印象深刻！\n華碩募款活動這個活動比較特別，是華碩的兩個職員到社團的辦公室聽我們的介紹進行募款的活動。這次是由我和另外一位同學負責介紹建中機研，從社團的創立的歷史以及我們在做些什麼來介紹。\n由於擔任報告的角色，我們在發表前進行多次的試講以及調整，希望以最佳的狀態下呈現，讓我學習到許多報告的技巧。事後歸納出以下可以改進的地方：\n\n準備不夠周全，在報告的時候會不自覺看向投影片\n視線與身體面對的方向面向側邊，應朝向目標觀眾\n自信不足，造成卡詞的狀況\n\n下次可以透過更完整的演練增加自信，並將投影片的內容背誦下來使報告更加流暢！\n\n台灣微軟這次的行程很特別，我們到了信義區台灣微軟的總部參觀微軟的總部。這跟之前參觀時碩有很大的不同，一個是做硬體、一個是做軟體。\n介紹台灣微軟這邊講者有提到一個令我蠻驚訝的現象，就是儘管像微軟這樣一間大公司，也還是會面對時代變遷必須轉型的問題，否則有可能會被市場淘汰。\n講者舉了微軟的市值作為例子，在過去幾十年，微軟的股價一直沒有突破性的增長，直到最近幾年才有突破性的增加。分析原因是因為大公司在進行轉型的過程中遇到龐大的阻力，不過綜合結果來看，微軟的轉型是蠻成功的，可以從不斷上漲的市值得知。\n微軟還有提供許多實習的機會，未來有機會一定要爭取看看！\n參觀微軟辦公室最令我感興趣的是微軟最新推出的hololens，它是一款混合實境的產品，下圖為hololens 示範操作的過程，實際體驗會發現他是一個很新穎的產品，可以運用在學習、工廠、醫療、娛樂等領域。\n下圖則是微軟推出的AI識相，它可以拍照並算命，蠻新奇的！\n心得這是第一次參訪微軟這種國際的大公司，整個過程都是由兩位台灣微軟的實習生與一位正職帶著我們參觀。他們分享了自己的歷程，是如何進入到微軟上班（其中一位高中時是資奧的選手）與工作的日常，其中一位是Bing map的工程師，聽他的介紹感覺在微軟上班是一件蠻特別且有趣的工作！\n文林國小之志工服務\n活動新聞稿在寒假時間到文林國小進行兩天機器人冬令營的活動，我是主要擔任Scratch 的教學，利用2.5個小時的時間帶他們設計一個踢足球的程式。\n過程中遇到蠻多困難的，最大的問題其實是他們程式設計程度落差非常大，有些小朋友已經可以說是精通Scratch，有些則是連最基礎的都不會，讓教學有執行上到困難。\n藉由在課前設計一個 Kahoot的小測驗 ，讓我們可以掌握每一個小朋友的程度，對於能力比較強的就讓他超前學習，而Scratch 能力比較欠缺的則是安排隊輔特別指導。利用這個方式我們盡量讓每一位同學都可以跟上，並且學到東西。\n下圖是講解執行的程式，在講解過後，多數的小朋友都可以做出自己的足球小遊戲，讓我獲得許多成就感！\n整個活動讓我對教學這方面學到很多，在講解過程中必須隨機應變觀察台下的反應做出調整，適時的停下來放慢速度，才不會造成學生都聽不懂的狀況！\n交流活動下圖是跟南科實中FRC6998交流的大合照，這是第一次與南科實中進行交流的活動。在過程中，分享了彼此在做機器人競賽的相關經驗，同時分享在進行競賽中使用的技術以及機械的設計等等。\n\n下圖是與高雄中正高工7525機研進行交流照片\n南科模擬賽這是今年第一次參加比賽，總共兩天一夜的比賽讓我見識到FRC競賽的整個過程。\n第一天第一天搭乘下午的高鐵到台南的飯店，在晚餐結束之後，要進行賽前的團隊會議，我們詳細的討論比賽的分工（我是負責工作區的設置與Scouting）、與進行操作安全相關的考試（確保不會有受傷等意外發生）下圖是進行操作安全的測驗\n第二天這一天來到南科實中的比賽現場，整天下來的比賽節奏十分緊湊，我是負責Scouting 也就是分析別的隊伍表現的狀況，進行比賽策略的研擬。\n\n心得經過一年下來，透過自主學習與社團課的時間，除了學習機械、程式相關技術方面的知識，還學到了許多不一樣的能力，例如上台報告、教學的能力等。在與不同學校的隊伍交流與校外參訪的活動中，擴展了我的視野，可以親自看到業界的人平常在做些什麼，以及有什麼資源是可以去爭取的！\n參考資料圖片來源：南科機器人粉專\n使用連結：台北市教育局公告\n","categories":["自主學習"],"tags":["學習歷程","自主學習"]},{"title":"社團參與：機器人研習社自主學習","url":"/club2/","content":"自主學習課程內容這一學期的自主學習主要有三個重點：\n\nSolid work 電腦繪圖\nAnsys 有限元素分析模擬\n基礎力學理論課程\n自製MeArm機械手臂\n\n原本規劃要分組做機械手臂，但因為疫情的關係導致計畫沒辦法實行所以把原本做手臂的時間拿來做Ansys與Solid Work的教學\n這一學期的力學課程主要是讓我們可以建立一些力學理論的觀念，在FRC機器人競賽中可以發揮理論上面的優勢，透過物理的觀念與公式計算並分析在製作機器人中遇到的問題，並根據理論給出合理的解決方式。\n\n2021.3.10 三角函數與微積分入門這個禮拜除了基礎的座標種類的複習，還學到一些三角函數的知識。雖然第一次接觸到，也感受到三角函數的困難，不過整體學起來還不錯\n還有一個蠻吃力的主題是微積分，雖然只是基礎的分別介紹積分與微分的原理與相關應用，在上課的時候還是有聽沒有懂，回家再次複習後才較能理解微積分大致的概念\n在寒假機器的Labview程式設計中有使用到PID控制，利用比例、積分、微分的三個變量讓機器可以精準的移動給定的距離。看到機器因為使用PID控制而前後小幅度的抖動，就可以見到在比例與積分這兩塊發揮的作用\n上課筆記：\n\n2021.3.17 靜力學這一週的內容是靜力學，課程難度稍微較上週輕鬆靜力平衡與轉動平衡是之前就學過的概念，不過再加上三角函數進去分析，整個難度就瞬間提高！上課中提到的例題就要利用到三角函數將力分解，並就x方向與y方向的力作討論\n上課筆記：\n2021.4.28 材料物理特性今天的上課主題有別於前兩次的課程，因為機器過幾週後要出去比賽的關係，助教決定要來上一堂材料學的相關課程（因為機器太容易不知道為什麼某些結構就斷掉了）這週的內容主要介紹材料物理性質（剛性、強度）、降幅點（彈性極限）、脆性延性材料（受力與應變關係圖），內容豐富且蠻有趣的！\n上課筆記：\n2021.6.2 材料力學比完賽後發現我們隊的機器太容易損壞了！在賽中的回合幾乎都會有零件失效或出狀況，因此延續上一週的主題，助教給我們補充很多關於材料的理論與力學的分析\n難度頗高，我懷疑助教是直接把大學教材搬過來教我們，從基本力的介紹：正向力(Normal Force)、剪力(Shear Force)、彎矩(Bending Moment)，到應力的種類：正應力(Normal Stress)、剪應力(Shear Stress)，最困難的公式推導與一堆新的名詞：楊氏係數、剪切模量、頸縮等\n經過一週的消化，才稍稍理解這其中的內容\n上課筆記：\nSolid Work 3D繪圖軟體這學期的Solid work繪圖主要分成三部分：\n\n基礎圖學（工程圖學、手繪圖規範）\n範例元件繪製\n期末Solid work繪圖測驗\n\n個人認為最困難的應該是工程圖學，助教花了很多時間教我們圖學中的箭頭、尺度、標註位置、單位、圓與弧度的標示方式等等，東西又多又繁雜雖然聽過一次，我相信除非有再複習，否則一定很快就會忘記:cry:\n關於期末繪圖測驗的部分，要求繪製出一個符合以下題目要求的規格，並在上面繪製出螺絲孔，要求如下：\n依照題目的要求做好尺寸的標記（題目要求）：\n這是符合題目要求的最終成果：\nANSYS有限元素分析這應該是課程中最有趣的單元了！可以透過電腦分析，模擬出物體在受力與力矩時的應變量，利用這個分析助教想告訴我們說可以藉由這個軟體分析機器才受外力（碰撞）的時候，哪一個部件應該會最先發生變形甚至破裂，提早防範\n總共有幾個步驟需要完成：\n前置處理、建模可以先透過ANSYS 將想要模擬的物件建模，方便等一下的求解並將建模完成的物體匯入Workbench 進行後續的模擬與分析\n切網格這一步驟可說是重點步驟，透過切網格的方式，來模擬真實世界中的元素，因此網格如果切的越細，模擬會變得更精準，但同時所需要花費運算的時間也就越長切網格有一個重點就是盡量切成正方形（或是矩形），避免切出不規則形狀的網格!\n這樣切網格就不是一個很好的作法，網格應該要更加縝密\n這就是一個不錯的網格，不過切成舉行矩形應該會更好\n固定物件並增加力矩將物件的兩端固定住，並在其中一邊施加力矩(Y分量：$-1000Nm$)\n求解(Solve)最後就可以根據設定的參數看模擬的結果在其中一端施加力矩，可以發現兩端的應變量是最大的，向另外一端遞減\n應變量：\n最大主應力：可以發現在洞口的地方的值是最大的，也就顯示在物體受到外力的時候，通常在有鑽洞的地方所受到的負擔是最大的\n模擬GIF\n心得這學期學習到很多，不管是理論方面的知識，或是電腦繪圖與現象模擬的技巧都頗有收獲。最讓我印象深刻的是有限元素的分析，雖然在載這個軟體花費了相當多的時間(檔案超大)，在建模與設定參數也遇上了些許困難，不過能順利求解也讓人相當開心！\n參考資料\n助教上課講義\nSolid work教學網站\nAnsys 教學投影片)\n\n","categories":["自主學習"],"tags":["學習歷程","自主學習"]},{"title":"牛牛牧場問題","url":"/convex-hull/","content":"題序從前從前有一個人名叫thanksone，他與他的兩個哥哥thankstwo以及thanksthree以及他的弟弟thankszero一起開了一家「牛牛牧場」，用來養牛以及一些奇怪的東西。\n有一天，他發現他的牛牛少了很多隻，不知道是跑去了哪裡，他很難過，因此他想要建造一個圍籬，讓所有牛牛都跑不出去。於是他拜託他的兩個哥哥thankstwo以及thanksthree去市集買了$n$個用來架設圍籬的木樁，並要求他們把這些木樁架設在他指定的位置。\n接著，他拜託他的弟弟thankszero也去買了條超長的圍籬，並要求thankszero利用這條超長圍籬將$n$個木樁都圍起來，才能讓牛牛有盡量大的活動空間。thankszero的數學比起他的哥哥thanksone還要糟，因此他需要拜託你幫忙計算一下當他圍好圍籬之後，有多少個木樁會剛好落在這條圍籬上。除此之外，他還希望你能給他所有在圍籬上的木樁的位置，讓他知道固定圍籬的木樁的位置。\n最後，thanksone看到了你驚人的計算能力，於是他要求你計算出圍籬所圍出來的面積有多大，讓他能知道他的牛牛有多少的活動空間。\n\nINPUT第一行有一個正整數$n(3≤n≤2⋅10^5)$，表示有$n$個木樁在莊園上接下來有$n$行，每行有兩個整數 $x$ 及 $y$（$−10^9≤x,y≤10^9$），以一個空白隔開，用以代表一個木樁在座標軸上的位置。\n保證輸入的每一點都不會重複。\nOUTPUT第一行請輸出一個整數$k$：圍欄上木樁的個數（包含圍欄邊上的木樁）接下來輸出$k$行，每一行為圍欄上木樁的座標，由$x$座標由小到大輸出，如果$x$座標相同則按照$y$座標大小輸出。注意每一個木樁最多只能被輸出一次。最後一行輸出圍欄所圍出的面積大小，資料四捨五入取到整數位。\nSUBTASK40分：$n ≤100$\n60分：沒有特別限制\n範例測資1input72 22 01 12 42 34 21 3\noutput51 11 32 02 44 27\n範例測資2input41 23 22 25 2\noutput41 22 23 25 20\n從範例測資1可以發現，thanksone可以將下圖木樁$B,F,D,G,C$圍起來，能獲得最大的牛牛牧場面積：\n範例測資2可以看到，thanksone圍出來的牛牛牧場面積為 $0$：\n題目連結OJDL\n題解這一題就是凸包裸題，輸出所有包含在凸包上的點（頂點跟邊都要）。\nsubtask 1保證所形成的凸包面積不為0，所以做完凸包之後將邊上的點都輸出出來，之後再計算凸包面積就好。\nsubtask 2做完凸包可能會有點重複的問題，所以將所有點排序之後，記得去重，好好處理就可以AC了。\nAC code#include &lt;bits/stdc++.h&gt;#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt const &amp;b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt const &amp;b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt const &amp;b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt const &amp;b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt const &amp;b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt const &amp;b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt const &amp;b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;struct comp&#123;    bool operator()(pt const &amp;a,pt const &amp;b)const&#123;        if(a.x == b.x)return a.y &lt; b.y;        return a.x &lt; b.x;    &#125;&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;set&lt;pt,comp&gt; s;int n,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt; 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;signed main()&#123;    cin&gt;&gt;n;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)area += (hull[i]^hull[i+1]);    for(auto i : hull)s.insert(i);    cout&lt;&lt;s.size()&lt;&lt;endl;    for(auto i : s)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;endl;    cout&lt;&lt;((area%2)?(area/2)+1:(area/2))&lt;&lt;endl;&#125;\n","categories":["C++進階主題","計算幾何"],"tags":["演算法","動態規劃"]},{"title":"[題解]CSES 1068 Weird Algorithm","url":"/cses1-1/","content":"Weird Algorithm\n題目連結\n#include &lt;bits/stdc++.h&gt;using namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    while(n != 1)&#123;        cout&lt;&lt;n&lt;&lt;&quot; &quot;;        if(n % 2 == 1)n = 3 * n + 1;        else n = n/2;    &#125;    cout&lt;&lt;1&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1618 Trailing Zeros","url":"/cses1-10/","content":"Trailing Zeros\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int f = 5,ans = 0;    for(int i=0;i&lt;12;i++)&#123;        ans += n / f;        f *= 5;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1754 Coin Piles","url":"/cses1-11/","content":"Coin Piles\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int a,b;cin&gt;&gt;a&gt;&gt;b;    if(a &gt; b)swap(a,b);    if(b - a &gt; a)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    a = a % 3;b = b % 3;    if(a &gt; b)swap(a,b);    if(a == 1 &amp;&amp; b == 2)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else if(a == 0 &amp;&amp; b == 0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1755 Palindrome Reorder","url":"/cses1-12/","content":"Palindrome Reorder\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n; signed main()&#123;    string str,ans;cin&gt;&gt;str;    n = str.size();    int num[N],cnt = 0,cha = -1;memset(num,0,sizeof(num));    for(int i = 0;i &lt; n;i++)&#123;        num[str[i] - &#x27;A&#x27;] += 1;    &#125;    for(int i=0;i&lt;26;i++)&#123;        if(num[i] &amp; 1)&#123;            cnt++;cha = i;        &#125;    &#125;    ans.resize(n);    if(cnt &gt; 1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt == 1 &amp;&amp; !(n&amp;1))cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt &lt; 1 &amp;&amp; n&amp;1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else&#123;        if(n &amp; 1)&#123;            ans[n/2] = &#x27;A&#x27;+cha;            num[cha]--;        &#125;        int l = 0,r = n-1;        for(int i=0;i&lt;26;i++)&#123;            while(num[i])&#123;                ans[l++] = i + &#x27;A&#x27;;                ans[r--] = i + &#x27;A&#x27;;                num[i] -= 2;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2205 Gray Code","url":"/cses1-13/","content":"Gray Code\n題目連結\n#include &lt;bits/stdc++.h&gt;#define pb push_back#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;vector&lt;string&gt; str; void solve()&#123;    str.pb(&quot;0&quot;);str.pb(&quot;1&quot;);    for(int i=0;i&lt;n-1;i++)&#123;        vector&lt;string&gt; temp1 = str,temp2 = str;        reverse(temp2.begin(),temp2.end());        str.clear();        int len = temp1.size();        for(int i=0;i&lt;len;i++)temp1[i] = &quot;0&quot; + temp1[i];        for(int i=0;i&lt;len;i++)temp2[i] = &quot;1&quot; + temp2[i];        str.insert(str.begin(),temp1.begin(),temp1.end());        str.insert(str.end(),temp2.begin(),temp2.end());    &#125;    for(auto i : str)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2165 Tower of Hanoi","url":"/cses1-14/","content":"Tower of Hanoi\n題目連結\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;void solve(int from,int to,int by,int n)&#123;    if(n &lt; 1)return;    solve(from,by,to,n-1);    cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot;\\n&quot;;    solve(by,to,from,n-1);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    cout&lt;&lt; (1&lt;&lt;n)-1 &lt;&lt;&quot;\\n&quot;;    solve(1,3,2,n);    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1622 Creating Strings","url":"/cses1-15/","content":"Creating Strings\n題目連結\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size(),num[30];    memset(num,0,sizeof(num));    for(int i=0;i&lt;len;i++)&#123;        num[s[i] - &#x27;a&#x27;] += 1;    &#125;    string str;    for(int i = 0;i &lt; 26;i++)&#123;        while(num[i])&#123;            str += (char)(i + &#x27;a&#x27;);            num[i]--;        &#125;    &#125;    vector&lt;string&gt; ans;    do&#123;        ans.push_back(str);    &#125;while(next_permutation(str.begin(),str.end()));        cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1623 Apple Division","url":"/cses1-16/","content":"Apple Division\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m = 0,arr[21];void dp()&#123;    int ans = LONG_LONG_MAX;    for(int i=0;i&lt;1&lt;&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;n;j++)&#123;            if(1&lt;&lt;j &amp; i)sum += arr[j];        &#125;        ans = min(ans,abs(m - sum - sum));    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];        m += arr[i];    &#125;    dp();&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1624 Chessboard and Queens","url":"/cses1-17/","content":"Chessboard and Queens\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;bool maze[10][10],vis[10][10];int ans = 0;bool check(int x,int y)&#123;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            if(vis[i][j])&#123;                if(abs(i - x) == abs(j - y))return false;                if(i == x || j == y)return false;            &#125;        &#125;    &#125;    return true;&#125;void dfs(int cur)&#123;    if(cur &gt; 8)&#123;        ans++;        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(cur,i) &amp;&amp; maze[cur][i])&#123;            vis[cur][i] = 1;            dfs(cur+1);            vis[cur][i] = 0;        &#125;    &#125;&#125;signed main()&#123;    IOS;    memset(maze,0,sizeof(maze));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=8;i++)&#123;        string s;getline(cin,s);        for(int j=1;j&lt;=8;j++)&#123;            if(s[j-1] == &#x27;.&#x27;)maze[i][j] = 1;        &#125;    &#125;    dfs(1);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2431  Digit Queries","url":"/cses1-18/","content":"Digit Queries\n題目連結\n#include &lt;bits/stdc++.h&gt;#define N 20#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,pref[N],p[20];void init()&#123;    p[0] = 1;    for(int i=1;i&lt;19;i++)&#123;        p[i] = p[i-1] * 10;    &#125;    pref[1] = 9;    for(int i=2;i&lt;18;i++)&#123;        pref[i] = p[i-1] * 9 * i;    &#125;&#125;void solve()&#123;    int ind = 1;    while(n &gt; pref[ind])n -= pref[ind++];    n--;                    //0-BASE    int x = n / ind;        //0-BASE    int y = n % ind;        //0-BASE    int ans = p[ind-1] + x;    string temp = to_string(ans);    cout&lt;&lt;temp[y]&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    init();    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        solve();    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1625 Grid Paths","url":"/cses1-19/","content":"Grid Paths\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;string str;int dx[4] = &#123;1,0,-1,0&#125;,dy[4] = &#123;0,1,0,-1&#125;;bool vis[9][9];int ans = 0; void solve(int x,int y,int s)&#123;    if(x &lt; 1 || x &gt; 7 || y &lt; 1 || y &gt; 7 || vis[x][y])return;    if(x == 1 &amp;&amp; y == 7 &amp;&amp; s &lt; 48)return;    if(vis[x-1][y] &amp;&amp; vis[x+1][y] &amp;&amp; !vis[x][y+1] &amp;&amp; !vis[x][y-1])return;    if(!vis[x-1][y] &amp;&amp; !vis[x+1][y] &amp;&amp; vis[x][y+1] &amp;&amp; vis[x][y-1])return;    if(s == 48)&#123;        ans++;        return;    &#125;    vis[x][y] = 1;    int ans = 0;    if(str[s] == &#x27;L&#x27;)solve(x - 1, y, s + 1);    if(str[s] == &#x27;R&#x27;)solve(x + 1, y, s + 1);    if(str[s] == &#x27;U&#x27;)solve(x, y - 1, s + 1);    if(str[s] == &#x27;D&#x27;)solve(x, y + 1, s + 1);    if(str[s] == &#x27;?&#x27;)&#123;        for(int i = 0;i &lt; 4;i++)&#123;            int nx = x + dx[i],ny = y + dy[i];            solve(nx,ny,s+1);        &#125;    &#125;    vis[x][y] = 0;&#125; signed main()&#123;    IOS;    cin&gt;&gt;str;    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=7;i++)&#123;        vis[i][0] = 1;        vis[8][i] = 1;        vis[i][8] = 1;        vis[0][i] = 1;    &#125;    solve(1,1,0);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1083 Missing Number","url":"/cses1-2/","content":"Missing Number\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    int sum = n*(n+1)/2;    for(int i=0;i&lt;n-1;i++)&#123;        int temp;cin&gt;&gt;temp;        sum -= temp;    &#125;    cout&lt;&lt;sum&lt;&lt;endl;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1069 Repetitions","url":"/cses1-3/","content":"Repetitions\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std; signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size();    int ans = 1,cur = 1;    for(int i = 1;i &lt; len;i++)&#123;        if(s[i] == s[i-1])cur++;        else cur = 1;        ans = max(ans,cur);    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1094 Increasing Array","url":"/cses1-4/","content":"Increasing Array\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[N]; signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int ans = 0;    for(int i=1;i&lt;n;i++)&#123;        if(arr[i] &lt; arr[i-1])&#123;            ans += arr[i-1] - arr[i];            arr[i] = arr[i-1];        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1070 Permutations","url":"/cses1-5/","content":"Permutations\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    bool vis[N];memset(vis,0,sizeof(vis));    if(n == 2 || n == 3)cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;    else if(n == 4)cout&lt;&lt;&quot;2 4 1 3 &quot;;    else&#123;        for(int i=1;i&lt;=n;i+=2)&#123;            cout&lt;&lt;i&lt;&lt;&quot; &quot;;            vis[i] = 1;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(vis[i] == 0)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1071 Number Spiral","url":"/cses1-6/","content":"Number Spiral\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    while(n--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        int ly = max(x,y)-1,st = ly*ly;        if(!(ly % 2))&#123;            if(y &lt; ly+1)cout&lt;&lt;st+y&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-x)&lt;&lt;endl;        &#125;        else&#123;            if(x &lt; ly+1)cout&lt;&lt;st+x&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-y)&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1072 Two Knights","url":"/cses1-7/","content":"Two Knights\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 10005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,dp[N]; void build()&#123;    memset(dp,0,sizeof(dp));    for(int i=2;i&lt;=10000;i++)&#123;        int sum = (i*i)*(i*i-1)/2 - 4*(i-1)*(i-2);        dp[i] = sum;    &#125;&#125; signed main()&#123;    IOS;    build();    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;dp[i]&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1092 Two Sets","url":"/cses1-8/","content":"Two Sets\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n;void solve()&#123;    int total = n*(n+1)/2,sum = 0,cnt = 0;    bool vis[N];memset(vis,0,sizeof(vis));    if(total &amp; 1)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    for(int i=n;i&gt;=1;i--)&#123;        int next = sum + i;        if(next &lt;= total/2)&#123;            sum += i;            cnt++;            vis[i] = 1;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;&lt;&lt;n - cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 1617 Bit Strings","url":"/cses1-9/","content":"Bit Strings\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int ans = 1;    for(int i=0;i&lt;n;i++)&#123;        ans *= 2;        ans = ans % mod;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"CSES:Introductory Problems","url":"/cses1/","content":"CSES 解題紀錄。\nMy AccountThanksone帳號CSES Plan\nIntroductory ProblemsWeird Algorithm題目連結\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    while(n != 1)&#123;        cout&lt;&lt;n&lt;&lt;&quot; &quot;;        if(n % 2 == 1)n = 3 * n + 1;        else n = n/2;    &#125;    cout&lt;&lt;1&lt;&lt;&quot;\\n&quot;;&#125;\nMissing Number題目連結\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    int sum = n*(n+1)/2;    for(int i=0;i&lt;n-1;i++)&#123;        int temp;cin&gt;&gt;temp;        sum -= temp;    &#125;    cout&lt;&lt;sum&lt;&lt;endl;&#125;\nRepetitions題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std; signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size();    int ans = 1,cur = 1;    for(int i = 1;i &lt; len;i++)&#123;        if(s[i] == s[i-1])cur++;        else cur = 1;        ans = max(ans,cur);    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\nIncreasing Array題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[N]; signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int ans = 0;    for(int i=1;i&lt;n;i++)&#123;        if(arr[i] &lt; arr[i-1])&#123;            ans += arr[i-1] - arr[i];            arr[i] = arr[i-1];        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\nPermutations題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    bool vis[N];memset(vis,0,sizeof(vis));    if(n == 2 || n == 3)cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;    else if(n == 4)cout&lt;&lt;&quot;2 4 1 3 &quot;;    else&#123;        for(int i=1;i&lt;=n;i+=2)&#123;            cout&lt;&lt;i&lt;&lt;&quot; &quot;;            vis[i] = 1;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(vis[i] == 0)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\nNumber Spiral題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    while(n--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        int ly = max(x,y)-1,st = ly*ly;        if(!(ly % 2))&#123;            if(y &lt; ly+1)cout&lt;&lt;st+y&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-x)&lt;&lt;endl;        &#125;        else&#123;            if(x &lt; ly+1)cout&lt;&lt;st+x&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-y)&lt;&lt;endl;        &#125;    &#125;&#125;\nTwo Knights題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 10005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,dp[N]; void build()&#123;    memset(dp,0,sizeof(dp));    for(int i=2;i&lt;=10000;i++)&#123;        int sum = (i*i)*(i*i-1)/2 - 4*(i-1)*(i-2);        dp[i] = sum;    &#125;&#125; signed main()&#123;    IOS;    build();    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;dp[i]&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nTwo Sets題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n;void solve()&#123;    int total = n*(n+1)/2,sum = 0,cnt = 0;    bool vis[N];memset(vis,0,sizeof(vis));    if(total &amp; 1)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    for(int i=n;i&gt;=1;i--)&#123;        int next = sum + i;        if(next &lt;= total/2)&#123;            sum += i;            cnt++;            vis[i] = 1;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;&lt;&lt;n - cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\nBit Strings題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int ans = 1;    for(int i=0;i&lt;n;i++)&#123;        ans *= 2;        ans = ans % mod;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\nTrailing Zeros題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int f = 5,ans = 0;    for(int i=0;i&lt;12;i++)&#123;        ans += n / f;        f *= 5;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\nCoin Piles題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int a,b;cin&gt;&gt;a&gt;&gt;b;    if(a &gt; b)swap(a,b);    if(b - a &gt; a)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    a = a % 3;b = b % 3;    if(a &gt; b)swap(a,b);    if(a == 1 &amp;&amp; b == 2)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else if(a == 0 &amp;&amp; b == 0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;\nPalindrome Reorder題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n; signed main()&#123;    string str,ans;cin&gt;&gt;str;    n = str.size();    int num[N],cnt = 0,cha = -1;memset(num,0,sizeof(num));    for(int i = 0;i &lt; n;i++)&#123;        num[str[i] - &#x27;A&#x27;] += 1;    &#125;    for(int i=0;i&lt;26;i++)&#123;        if(num[i] &amp; 1)&#123;            cnt++;cha = i;        &#125;    &#125;    ans.resize(n);    if(cnt &gt; 1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt == 1 &amp;&amp; !(n&amp;1))cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt &lt; 1 &amp;&amp; n&amp;1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else&#123;        if(n &amp; 1)&#123;            ans[n/2] = &#x27;A&#x27;+cha;            num[cha]--;        &#125;        int l = 0,r = n-1;        for(int i=0;i&lt;26;i++)&#123;            while(num[i])&#123;                ans[l++] = i + &#x27;A&#x27;;                ans[r--] = i + &#x27;A&#x27;;                num[i] -= 2;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nGray Code題目連結\n#include &lt;bits/stdc++.h&gt;#define pb push_back#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;vector&lt;string&gt; str; void solve()&#123;    str.pb(&quot;0&quot;);str.pb(&quot;1&quot;);    for(int i=0;i&lt;n-1;i++)&#123;        vector&lt;string&gt; temp1 = str,temp2 = str;        reverse(temp2.begin(),temp2.end());        str.clear();        int len = temp1.size();        for(int i=0;i&lt;len;i++)temp1[i] = &quot;0&quot; + temp1[i];        for(int i=0;i&lt;len;i++)temp2[i] = &quot;1&quot; + temp2[i];        str.insert(str.begin(),temp1.begin(),temp1.end());        str.insert(str.end(),temp2.begin(),temp2.end());    &#125;    for(auto i : str)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    solve();    return 0;&#125;\nTower of Hanoi題目連結\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;void solve(int from,int to,int by,int n)&#123;    if(n &lt; 1)return;    solve(from,by,to,n-1);    cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot;\\n&quot;;    solve(by,to,from,n-1);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    cout&lt;&lt; (1&lt;&lt;n)-1 &lt;&lt;&quot;\\n&quot;;    solve(1,3,2,n);    return 0;&#125;\nCreating Strings題目連結\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size(),num[30];    memset(num,0,sizeof(num));    for(int i=0;i&lt;len;i++)&#123;        num[s[i] - &#x27;a&#x27;] += 1;    &#125;    string str;    for(int i = 0;i &lt; 26;i++)&#123;        while(num[i])&#123;            str += (char)(i + &#x27;a&#x27;);            num[i]--;        &#125;    &#125;    vector&lt;string&gt; ans;    do&#123;        ans.push_back(str);    &#125;while(next_permutation(str.begin(),str.end()));        cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;    return 0;&#125;\nApple Division題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m = 0,arr[21];void dp()&#123;    int ans = LONG_LONG_MAX;    for(int i=0;i&lt;1&lt;&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;n;j++)&#123;            if(1&lt;&lt;j &amp; i)sum += arr[j];        &#125;        ans = min(ans,abs(m - sum - sum));    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];        m += arr[i];    &#125;    dp();&#125;\nChessboard and Queens題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;bool maze[10][10],vis[10][10];int ans = 0;bool check(int x,int y)&#123;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            if(vis[i][j])&#123;                if(abs(i - x) == abs(j - y))return false;                if(i == x || j == y)return false;            &#125;        &#125;    &#125;    return true;&#125;void dfs(int cur)&#123;    if(cur &gt; 8)&#123;        ans++;        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(cur,i) &amp;&amp; maze[cur][i])&#123;            vis[cur][i] = 1;            dfs(cur+1);            vis[cur][i] = 0;        &#125;    &#125;&#125;signed main()&#123;    IOS;    memset(maze,0,sizeof(maze));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=8;i++)&#123;        string s;getline(cin,s);        for(int j=1;j&lt;=8;j++)&#123;            if(s[j-1] == &#x27;.&#x27;)maze[i][j] = 1;        &#125;    &#125;    dfs(1);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\nDigit Queries題目連結\n#include &lt;bits/stdc++.h&gt;#define N 20#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,pref[N],p[20];void init()&#123;    p[0] = 1;    for(int i=1;i&lt;19;i++)&#123;        p[i] = p[i-1] * 10;    &#125;    pref[1] = 9;    for(int i=2;i&lt;18;i++)&#123;        pref[i] = p[i-1] * 9 * i;    &#125;&#125;void solve()&#123;    int ind = 1;    while(n &gt; pref[ind])n -= pref[ind++];    n--;                    //0-BASE    int x = n / ind;        //0-BASE    int y = n % ind;        //0-BASE    int ans = p[ind-1] + x;    string temp = to_string(ans);    cout&lt;&lt;temp[y]&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    init();    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        solve();    &#125;&#125;\nGrid Paths題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;string str;int dx[4] = &#123;1,0,-1,0&#125;,dy[4] = &#123;0,1,0,-1&#125;;bool vis[9][9];int ans = 0; void solve(int x,int y,int s)&#123;    if(x &lt; 1 || x &gt; 7 || y &lt; 1 || y &gt; 7 || vis[x][y])return;    if(x == 1 &amp;&amp; y == 7 &amp;&amp; s &lt; 48)return;    if(vis[x-1][y] &amp;&amp; vis[x+1][y] &amp;&amp; !vis[x][y+1] &amp;&amp; !vis[x][y-1])return;    if(!vis[x-1][y] &amp;&amp; !vis[x+1][y] &amp;&amp; vis[x][y+1] &amp;&amp; vis[x][y-1])return;    if(s == 48)&#123;        ans++;        return;    &#125;    vis[x][y] = 1;    int ans = 0;    if(str[s] == &#x27;L&#x27;)solve(x - 1, y, s + 1);    if(str[s] == &#x27;R&#x27;)solve(x + 1, y, s + 1);    if(str[s] == &#x27;U&#x27;)solve(x, y - 1, s + 1);    if(str[s] == &#x27;D&#x27;)solve(x, y + 1, s + 1);    if(str[s] == &#x27;?&#x27;)&#123;        for(int i = 0;i &lt; 4;i++)&#123;            int nx = x + dx[i],ny = y + dy[i];            solve(nx,ny,s+1);        &#125;    &#125;    vis[x][y] = 0;&#125; signed main()&#123;    IOS;    cin&gt;&gt;str;    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=7;i++)&#123;        vis[i][0] = 1;        vis[8][i] = 1;        vis[i][8] = 1;        vis[0][i] = 1;    &#125;    solve(1,1,0);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES"],"tags":["CSES"]},{"title":"[題解]CSES 2189 Point Location Test","url":"/cses7-1/","content":"Point Location Test\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        int x1,y1,x2,y2,x3,y3;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;        pt l = &#123;x2 - x1,y2 - y1&#125;, o = &#123;x3 - x1,y3 - y1&#125;;                if((l ^ o) == 0)cout&lt;&lt;&quot;TOUCH&quot;&lt;&lt;&quot;\\n&quot;;        else if((l ^ o) &gt; 0)cout&lt;&lt;&quot;LEFT&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;RIGHT&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2190 Line Segment Intersection","url":"/cses7-2/","content":"Line Segment Intersection\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;bool onseg(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return cross == 0 &amp;&amp; dot &lt;= 0;    //dot == 0 when o is a or b&#125;int dir(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(pt a,pt b,pt c,pt d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if((dir(a,b,c) * dir(a,b,d)) == -1       &amp;&amp; (dir(c,d,a) * dir(c,d,b)) == -1)        return true;    return false;&#125;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        pt pot[4];        for(int i=0;i&lt;4;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;        if(inter(pot[0],pot[1],pot[2],pot[3]))cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2191 Polygon Area","url":"/cses7-3/","content":"Polygon Area\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;pot[N];int solve()&#123;    int ans = 0;    for(int i=0;i&lt;n;i++)ans += (pot[i] ^ pot[i+1]);    return ans;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;    pot[n] = pot[0];    cout&lt;&lt;abs(solve())&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2192 Point in Polygon","url":"/cses7-4/","content":"Point in Polygon\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define INF 1000000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];bool onseg(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return (cross == 0) &amp;&amp; (dot &lt;= 0);&#125;int dir(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(point a,point b,point c,point d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if(dir(a,b,c) * dir(a,b,d) &lt; 0 &amp;&amp; dir(c,d,a) * dir(c,d,b) &lt; 0)        return true;    return false;&#125;int solve(point cur)&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)&#123;        if(onseg(pt[i],pt[i+1],cur) == 1)return -1;        if(inter(pt[i],pt[i+1],cur,point&#123;INF,cur.y&#125;))sum++;        point temp = pt[i].y &gt; pt[i+1].y ? pt[i] : pt[i+1];        if(temp.y == cur.y &amp;&amp; temp.x &gt; cur.x)sum--;    &#125;    return sum;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    for(int i=0;i&lt;m;i++)&#123;        point temp;cin&gt;&gt;temp.x&gt;&gt;temp.y;        int ans = solve(temp);        if(ans == -1)cout&lt;&lt;&quot;BOUNDARY&quot;&lt;&lt;&quot;\\n&quot;;        else if(ans &amp; 1)cout&lt;&lt;&quot;INSIDE&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;OUTSIDE&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2193 Polygon Lattice Points","url":"/cses7-5/","content":"Polygon Lattice Points\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 100005#define INF 1000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];int solve()&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)sum += pt[i] ^ pt[i+1];    return abs(sum);&#125;int gcd(int a,int b)&#123;    if(b == 0)return a;    return gcd(b,a%b);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    int cnt = 0,ans = 0;    for(int i=0;i&lt;n;i++)        cnt += gcd(abs(pt[i].x-pt[i+1].x),abs(pt[i].y-pt[i+1].y));    ans = (solve() + 2 - cnt)/2;    cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2194 Minimum Euclidean Distance","url":"/cses7-6/","content":"Minimum Euclidean Distance\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;vector &lt;pii&gt; pt; int dis(pii a,pii b)&#123;    int x = a.x - b.x,y = a.y - b.y;    return x * x + y * y;&#125; bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125; vector &lt;pii&gt; temp;//區間[l,r]int solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l + r) / 2,mid_x = pt[mid].x;    int ans = min(solve(l,mid),solve(mid+1,r));        temp.assign(r - l + 1,&#123;0 , 0&#125;);    merge(          pt.begin() + l,pt.begin() + mid + 1,          pt.begin() + mid + 1,pt.begin() + r + 1,          temp.begin(), cmp    );    for(int i=l;i&lt;=r;i++)pt[i] = temp[i-l];    temp.clear();    for(int i=l;i&lt;=r;i++)&#123;        if(abs(pt[i].x - mid_x)*abs(pt[i].x - mid_x) &lt;= ans)temp.push_back(pt[i]);    &#125;    int len = temp.size();    for(int i = 0;i &lt; len;i++)&#123;        for(int j = i+1;j &lt; len;j++)&#123;            ans = min(ans,dis(temp[i],temp[j]));            if(abs(temp[i].y - temp[j].y)*abs(temp[i].y - temp[j].y) &gt; ans)break;        &#125;    &#125;    return ans;&#125; signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    sort(pt.begin(),pt.end());    cout&lt;&lt;solve(0,n-1)&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"[題解]CSES 2195 Convex Hull","url":"/cses7-7/","content":"Convex Hull\n題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;;vector&lt;point&gt; pt;bool cmp(point a,point b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool dir(point a,point b,point c)&#123;    point A = a - c,B = b - c;    return (A ^ B) &gt;= 0;&#125;vector&lt;point&gt; convex()&#123;    vector&lt;point&gt; h;    sort(all(pt),cmp);    for(auto i : pt)&#123;        while(h.size() &gt; 1 &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int down = h.size();    h.pop_back();    reverse(all(pt));    for(auto i : pt)&#123;        while(h.size() &gt; down &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    h.pop_back();    return h;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    vector&lt;point&gt; ans = convex();    cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES題解"],"tags":["題解","CSES"]},{"title":"CSES:Geometry","url":"/cses7/","content":"GeometryPoint Location Test題目連結#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        int x1,y1,x2,y2,x3,y3;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;        pt l = &#123;x2 - x1,y2 - y1&#125;, o = &#123;x3 - x1,y3 - y1&#125;;                if((l ^ o) == 0)cout&lt;&lt;&quot;TOUCH&quot;&lt;&lt;&quot;\\n&quot;;        else if((l ^ o) &gt; 0)cout&lt;&lt;&quot;LEFT&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;RIGHT&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nLine Segment Intersection題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;bool onseg(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return cross == 0 &amp;&amp; dot &lt;= 0;    //dot == 0 when o is a or b&#125;int dir(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(pt a,pt b,pt c,pt d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if((dir(a,b,c) * dir(a,b,d)) == -1       &amp;&amp; (dir(c,d,a) * dir(c,d,b)) == -1)        return true;    return false;&#125;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        pt pot[4];        for(int i=0;i&lt;4;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;        if(inter(pot[0],pot[1],pot[2],pot[3]))cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nPolygon Area題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;pot[N];int solve()&#123;    int ans = 0;    for(int i=0;i&lt;n;i++)ans += (pot[i] ^ pot[i+1]);    return ans;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;    pot[n] = pot[0];    cout&lt;&lt;abs(solve())&lt;&lt;&quot;\\n&quot;;&#125;\nPoint in Polygon題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define INF 1000000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];bool onseg(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return (cross == 0) &amp;&amp; (dot &lt;= 0);&#125;int dir(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(point a,point b,point c,point d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if(dir(a,b,c) * dir(a,b,d) &lt; 0 &amp;&amp; dir(c,d,a) * dir(c,d,b) &lt; 0)        return true;    return false;&#125;int solve(point cur)&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)&#123;        if(onseg(pt[i],pt[i+1],cur) == 1)return -1;        if(inter(pt[i],pt[i+1],cur,point&#123;INF,cur.y&#125;))sum++;        point temp = pt[i].y &gt; pt[i+1].y ? pt[i] : pt[i+1];        if(temp.y == cur.y &amp;&amp; temp.x &gt; cur.x)sum--;    &#125;    return sum;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    for(int i=0;i&lt;m;i++)&#123;        point temp;cin&gt;&gt;temp.x&gt;&gt;temp.y;        int ans = solve(temp);        if(ans == -1)cout&lt;&lt;&quot;BOUNDARY&quot;&lt;&lt;&quot;\\n&quot;;        else if(ans &amp; 1)cout&lt;&lt;&quot;INSIDE&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;OUTSIDE&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nPolygon Lattice Points題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 100005#define INF 1000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];int solve()&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)sum += pt[i] ^ pt[i+1];    return abs(sum);&#125;int gcd(int a,int b)&#123;    if(b == 0)return a;    return gcd(b,a%b);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    int cnt = 0,ans = 0;    for(int i=0;i&lt;n;i++)        cnt += gcd(abs(pt[i].x-pt[i+1].x),abs(pt[i].y-pt[i+1].y));    ans = (solve() + 2 - cnt)/2;    cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;&#125;\nMinimum Euclidean Distance題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;vector &lt;pii&gt; pt; int dis(pii a,pii b)&#123;    int x = a.x - b.x,y = a.y - b.y;    return x * x + y * y;&#125; bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125; vector &lt;pii&gt; temp;//區間[l,r]int solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l + r) / 2,mid_x = pt[mid].x;    int ans = min(solve(l,mid),solve(mid+1,r));        temp.assign(r - l + 1,&#123;0 , 0&#125;);    merge(          pt.begin() + l,pt.begin() + mid + 1,          pt.begin() + mid + 1,pt.begin() + r + 1,          temp.begin(), cmp    );    for(int i=l;i&lt;=r;i++)pt[i] = temp[i-l];    temp.clear();    for(int i=l;i&lt;=r;i++)&#123;        if(abs(pt[i].x - mid_x)*abs(pt[i].x - mid_x) &lt;= ans)temp.push_back(pt[i]);    &#125;    int len = temp.size();    for(int i = 0;i &lt; len;i++)&#123;        for(int j = i+1;j &lt; len;j++)&#123;            ans = min(ans,dis(temp[i],temp[j]));            if(abs(temp[i].y - temp[j].y)*abs(temp[i].y - temp[j].y) &gt; ans)break;        &#125;    &#125;    return ans;&#125; signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    sort(pt.begin(),pt.end());    cout&lt;&lt;solve(0,n-1)&lt;&lt;&quot;\\n&quot;;&#125;\nConvex Hull題目連結\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;;vector&lt;point&gt; pt;bool cmp(point a,point b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool dir(point a,point b,point c)&#123;    point A = a - c,B = b - c;    return (A ^ B) &gt;= 0;&#125;vector&lt;point&gt; convex()&#123;    vector&lt;point&gt; h;    sort(all(pt),cmp);    for(auto i : pt)&#123;        while(h.size() &gt; 1 &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int down = h.size();    h.pop_back();    reverse(all(pt));    for(auto i : pt)&#123;        while(h.size() &gt; down &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    h.pop_back();    return h;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    vector&lt;point&gt; ans = convex();    cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES"],"tags":["CSES"]},{"title":"二維都卜勒效應模擬實驗計畫","url":"/doppler/","content":"實驗器材\n麥克風一支\n蜂鳴器一枚\n圓形轉盤(建中實驗室)\n筆電一台(裝好聲音處理軟體，並確保可以連上麥克風)\n\n\n理論部分整理一些會用到的物理公式、名詞等。在小論文中，我們總共做了角度對頻率的關係圖，以及頻率對時間的關係圖，我們在實驗中主要會用到的是頻率對時間的關係圖，其實最重要的還是頻率的最大值與最小值。\n實驗做完以後，會結合我們小論文最後一部分:理論與模擬的比較這一個部分，結合實驗，做出更詳盡，有說服力的論述。\n都卜勒效應公式因為是做時間對上頻率的關係圖，因此我們要用的就是一般一維的都卜勒效應公式。先定義 $f’$ 為觀察者(靜止)所觀測到的頻率，$f$ 為蜂鳴器發射出來的頻率，$v$ 為聲音的波速，$v_s$ 為蜂鳴器相對於介質的移動速度。以下公式：\nf' = \\frac{v}{v+v_s}\\cdot f注意到 $v_s$ 要代入的是切線速度(到時候會用角速度換算而來)  \n角速度與切線速度\n角速度 $\\omega$ 代表的是一秒內能夠轉動的弧度多少，其單位為 $\\frac{rad}{s}$ ，要注意的是弧度沒有單位!從定義可以推導出以下公式：\n\\omega = \\frac{\\Delta \\theta}{\\Delta t}而根據弧度的定義，我們知道 $\\theta = \\frac{S}{r}$ ，如果要求出切線速度 $v$ ，我們可以列出以下式子：\nv = \\frac{d \\, S}{d \\,t}換句話說就是對距離作微分得到時間。其中 $S = r\\cdot\\theta$，代入之後得到：\nv = \\frac{r\\times \\Delta\\theta}{\\Delta t} = r\\cdot \\omega有了切線速度之後，就可以直接代入都卜勒效應公式中蜂鳴器 $v_s$ 算出頻率了!\n不確定度不確定度可以分成 A 類不確定度以及 B 類不確定度，以 $u_A,u_B$ 表示。其中 A 類不確定度的公式：\n\nB 類則是用儀器的最小刻度乘上$\\frac{1}{2\\sqrt{3}}$，到時候看看麥克風的規格再來算一下。而有了這兩個不確定度之後，就要算組合不確定度：\nu = \\sqrt{u_A^2+u_B^2}算不確定度都是取有效位數兩位，最佳估計值對齊不確定度的位數。寫成結果 X = 最佳估計值 ± 不確定度的形式。\n實驗流程\n設定轉盤轉速、蜂鳴器旋轉半徑(可以固定與觀察者的距離，因為這個距離對頻率不會有影響)\n轉動旋轉圓盤，用麥克風接收頻率，並輸入軟體之後畫出f-t圖(先找出蜂鳴器在哪一個頻率區間的聲音是最大聲的)\n找出每一組數據中頻率的最大值以及最小值，並與理論作比較\n\n預期呈現方式(實驗表格)這個表格是角速度對上蜂鳴器的旋轉半徑(公分)的圖，表格裡面的數字則是切線速度(公分/秒，可能還要做一些單位的換算之後代入公式)：\n\n\n\n\nw-r\n2.5\n5\n7.5\n10\n\n\n\n\n1π\n2.5π\n5π\n7.5π\n10π\n\n\n2π\n5π\n10π\n15π\n20π\n\n\n3π\n7.5π\n15π\n22.5π\n30π\n\n\n4π\n4π\n20π\n30π\n40π\n\n\n\n\n這是理論算出來的結果：\n會有兩個表格分別是理論的頻率最大、最小值，以及實驗表格要填入觀察的結果(用Audacity分析)，形式大概就是長成上表這樣。\n\n最後，我們打算固定轉動的速度(角速度)，畫出頻率對上半徑的圖形(x座標為半徑、y座標為頻率)，用兩條直線表示理論和實際測量的結果。\n程式部分程式碼連結\n將之前的程式碼的數字改成符合真實狀況之後，圖畫出來的效果很糟，因為之前都是以公尺為單位，當處理到以公分為單位的細微變化時，就會跑出很糟糕的圖形。因此，我們將之前的程式碼的時間變化dt改成 $10^{-8}$，使每一次的波的位移量盡量小，才能讓結果更精準。\n這是有bug一開始的醜陋圖形：\n\n加上了一點時間延遲的處理之後，若帶入上面的數據，與公式推出來的結果誤差會在正負 $0.005$ 之間，算時蠻精準的，例如下圖：\n\n這個是用 $10^{-7}$ 為間隔的圖形，在最大最小值跟理論有些小的差距。因此，在求最大最小值的時候，會以 $10^{-8}$ 為間隔，缺點是跑得很慢就是了，因此採用直接把初始位置設在發生頻率極值附近，比較能快速觀察。\n\n誤差約為 $3.5\\times 10^{-4}\\%$ 左右。\nPraat使用\n            使用其他音頻分析軟體剛剛下載了Sonic Visualizer 測試看看，果然可以分析每一個時間點中，各個頻率的強度為何。我先用手機播放400HZ以及4000HZ的聲音。下圖就是400HZ的波段，可以看到在對應的頻率強度最強，其他應該就是背景雜音的部分。這是4000HZ的圖形，但他好像沒辦法完全做到時頻圖。不知道這個功能可不可以使用，下面的圖形中，縱軸表示的是頻率，橫軸是時間，也就是時頻圖，用不同顏色來區分聲音的大小。可以看到前半部分黃色線是明顯的400HZ，而後面有一段由好多個點構成的線段（不太明顯，可能是聲音不夠大的結果）則是4000HZ。如果要分析這些的話，那除了聲音要夠大之外，頻率變化要明顯才能看得出差別。\n          \n上網查了一下發現 Audacity 好像無法畫出時頻圖(研究很久都沒有結果)，所以找到了 Praat 這個應用程式，而經過一翻研究後的確可以畫出頻譜圖。\n我們自己錄了一小段用手機播放出來的音頻，分析後的結果大概如下圖：\n音檔分析結果：\n經過實驗測試，未來將以麥克風收音後傳入 Audacity，匯出成音檔後傳進 Praat 後進行分析。\n目前困境\n[ ] 嘗試使用 Arduino 的蜂鳴器，太小聲，必須買大聲一點的蜂鳴器(出貨中)。\n\n[ ] 跟據理論預測，頻率變化的量不太明顯，必須使用頻率較高的蜂鳴器才能讓頻率最大值最小值的差距放大，或變得更顯著。不過還是會擔心說頻率的變化會不明顯，只能等實際做做看實驗才知道。目前打算用一個4000HZ的蜂鳴器進行實驗，希望在頻率表現上可以更加明顯(看到有大學實驗室是利用 40kHz 進行實驗，所產生的頻率變化應該會明顯許多)\n\n\n實驗結果V = 30,R = 5\nV = 60,R = 5\nV = 90,R = 5\nV = 30,R = 10\nV = 60,R = 10\nV = 90,R = 10\n—&gt;\n5cm 靜止\n5cm v = 30\n5cm v = 60\n5cm v = 90\n10cm 靜止\n10cm v = 30\n10cm v = 60\n10cm v = 90\n","categories":["程式模擬"],"tags":["數學","專題"]},{"title":"[題解]TIOJ 1354 池塘裡的青蛙","url":"/dp2-1/","content":"tioj-1354 池塘裡的青蛙\n題序這是一個排列組合的數學題目，透過動態規劃紀錄小問題的答案\n定義定義$dp[i][0]$為跳i次不回到A的方法數，$dp[i][1]$為跳i次回到A的方法數\n轉移方式\n$dp[i][1]$ = $dp[i-1][0]$應該不難理解，回到A的方法數為上一次不回到A的方法數 * 1\n$dp[i][0] = 3\\times dp[i-1][1]+2\\times dp[i-1][0]$不回到A可以分為2種情況，上一次回到A之後，可以往B,C,D，共三種情況。上一次不回到A的情況中，每一個都有兩個可以去的地方。\n\n邊界條件$dp[0][1] = 0, dp[0][0] = 1$\n程式碼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,k;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;k;        int dp[k+1][2];        memset(dp, 0, sizeof(dp));        dp[0][0] = 0;dp[0][1] = 1;        for(int i=1;i&lt;=k;i++)&#123;            dp[i][1] = dp[i-1][0];            dp[i][0] = 3*dp[i-1][1]+2*dp[i-1][0];        &#125;        cout&lt;&lt;dp[k][1]&lt;&lt;endl;    &#125;&#125;\n複雜度\n            這一題很討厭的，沒有給定測資的範圍，不然應該是可以直接建表然後用O(1)的複雜度求答案\n          \n","categories":["DP題解"],"tags":["題解","DP"]},{"title":"錯排問題（Derangements）","url":"/derangement/","content":"定義錯排是組合數學中的問題之一。考慮一個有n個元素的排列，若一個排列中所有的元素都不在自己原來的位置上，那麼這樣的排列就稱為原排列的一個錯排。本文將從錯排公式的推導開始，近一步探究其性質及應用。\n$n$個元素的錯排數記為 $D_n$ 或 $!n$。 研究一個排列錯排個數的問題，叫做錯排問題或稱為更列問題。\n規律與公式反面枚舉前幾項可以用取捨原理（或窮舉所有可能）求得：\n\\begin{align}D_1 &= 0 \\\\ D_2 &= 1\\\\D_3 &= 2 \\\\ D_4 &= 9\\end{align}\n            三個元素的錯排，以下共兩種：四個元素的錯排，以下共9種：412334213142431224132341432134122143\n          \n如下面的文氏圖可以看到，以三個元素的錯排為例，我們要求的就是綠色區域的數量，透過排容原理（取捨原理）來算。\n\\begin{split}D_3 = 3!-C^3_1\\cdot2!+C^3_2\\cdot1!-C^3_3\\cdot0! =2\\end{split}如果要求 $!4$ 也是一樣的作法：\nD_4 = 4!-C^4_1\\cdot3!+C^4_2\\cdot2!-C^4_3\\cdot1!+C^4_4\\cdot0! = 9這邊可以觀察到一個重要的規律，階乘的遞減、C取的數字遞增以及正負交替，這些性質會被用在等一下的一般化推導！\n遞迴解第一個公式是高中數學利用遞迴的概念得到的：\nD_n=(n-1)(D_{n-1}+D_{n-2})\n            證明：在原本 $n-1$ 個元素當中取一個元素跟新加入的元素（第n個元素）做交換，共有$C^{n-1}_1$ 種取法，假設取到的元素是K，則K有以下兩種情況：K本身即不在原本的位置上，跟新加入的元素調換亦是錯排K在原本的位置上，跟新加入的元素調換後形成錯排綜合以上兩種狀況，可以推得上面的公式\n          \n第二個是維基百科上面的公式：\nD_n = nD_{n-1}+(-1)^n這一個公式可以由等一下的一般式的公式（下面的公式解）推討過來：\n\\begin{split}D_n&=n!\\sum_{k=0}^{n}\\frac{(-1)^k}{k!}\\\\&=n(n-1)!\\sum_{k=0}^{n-1}\\frac{(-1)^k}{k!}+n!\\cdot\\frac{(-1)^n}{n!}\\\\&=nD_{n-1}+(-1)^n\\end{split}用這兩個遞迴式可以推得第n項的數值，不過時間複雜度依然是$O(n)$，想要求得的是$O(1)$的公式解\n公式解公式解可以利用取捨原理求得，寫成一般化的形式。對於第n項的錯排數可以利用之前觀察到排容原理的規律整理出以下式子：\n\\begin{split}D_n&=n!-C^n_1(n-1)!+C^n_2(n-2)!-\\cdots+C^n_n0!\\\\&=\\sum^n_{k=0}C^n_k(n-k)!\\cdot(-1)^k\\\\&=\\sum_{k=0}^{n}\\frac{n!}{k!(n-k)!}\\cdot(n-k)!\\cdot(-1)^k\\\\&=n!\\sum^{n}_{k=0}\\frac{(-1)^k}{k!}\\end{split}這個就是錯排數的一般化公式，如果想要把sigma消掉，還可以用以下處理：\n\\begin{split}D_n&=n!\\sum^{n}_{k=0}\\frac{(-1)^k}{k!}\\\\&=n![1-\\frac{1}{1!}+\\frac{1}{2!}-\\cdots+(-1)^n\\frac{1}{n!}]\\end{split}根據泰勒公式（$R_n$為修正項）\n\\begin{split}e^{-1}&=1+\\frac{(-1)^1}{1!}+\\frac{(-1)^2}{2!}+\\cdots+(-1)^n\\frac{1}{n!}+R(n)\\\\&=[1-\\frac{1}{1!}+\\frac{1}{2!}-\\cdots+(-1)^n\\frac{1}{n!}]+R(n)\\end{split}因為泰勒公式，中括號內的數值在n越大時會越接近$e^{-1}$，因此可以改寫成以下式子：\n\\begin{split}D_n \\cong n!\\cdot e^{-1}\\to\\frac{D_n}{n!}\\cong e^{-1}\\end{split}這就是n樣物品錯排的機率，那因為這只是近似值，由於正負交替，數值會在$e^{-1}$ 的地方震盪。為了要求出確切的$D_n$的解，我們要在後面加上一個修正項（泰勒展開餘項$R_n$），經過整理發現這個餘項 $\\frac{1}{n+1}$ 會嚴格小於 $0.5$，因此得到以下的一般項公式：\nD_n=\\lfloor\\frac{n!}{e}+0.5\\rfloor以上就是對於一般項$D_n$ 的一般項公式！\n實際模擬利用ggb的模擬做出震盪的效果，我是直接輸入一般化的公式，但討論n不是正整數的情況其實沒有意義，不過程式還是可以跑出一個數值如下：\n最後會趨近於$e^{-1}\\cong0.36787944$因為我們討論的都是整數解的狀況，利用python 模擬出正整數解的情況：\n印出n從一到20的跟$e^{-1}$的差距，可以看到有正負交替的情況，且每一次的差距都越來越小：\n以上都是近似的情況，因為公式是一個無窮級數，只會越來越接近理論的機率 $e^{-1}$ ，但永遠都會有一個微小的差距，也就是無限逼近的概念！\nimport numpy as npimport matplotlib.pyplot as pltconst = np.exp(-1)l = [0 for i in range(100)]l[0] = 1for i in range(1,21):    l[i] = l[i-1]*ia = [0 for i in range(100)]a[0] = 0a[1] = 0a[2] = 1a[3] = 2a[4] = 9for i in range(5,21):    a[i]= (a[i-1]+a[i-2])*(i-1)x = []y = []for i in range(1,21):    x.append(i)    y.append((a[i]/l[i]))    print((a[i]/l[i])-const)plt.title(&quot;Possibility to N&quot;, fontsize=20) #圖表標題plt.xlabel(&quot;N&quot;, fontsize=16) #x軸標題plt.ylabel(&quot;Possibility&quot;, fontsize=16) #y軸標題plt.xticks([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])plt.yticks([0,0.1,0.2,0.3,0.4,0.5,0.6])plt.plot(x,y)plt.show() #顯示繪製的圖形\n題目—P3182 [HAOI2016]放棋子題目連結題目敘述是這樣：\n\n給你一個 N×N 的矩陣，每行有一個障礙，數據保證任意兩個障礙不在同一行，任意兩個障礙不在同一列，要求你在這個矩陣上放 N 枚棋子（障礙的位置不能放棋子），要求你放 N 個棋子也滿足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少種方案。第一行一個N，接下來一個N*N的矩陣。n≤200，0 表示沒有障礙，1 表示有障礙，輸出一個整數，即合法的方案數。\n\n這一題是在整理錯排相關公式的時候發現這一題，很明顯的，障礙物代表原來的位置，所以其實要求的就是n個元素的錯排種類。因為這一題的$n≤200$，第200項的值會接近$200!$的量級，大約是$10^{374}$ 這麼多，對大數加法乘法來說卻是輕而易舉！可以用D_n = nD_{n-1}+(-1)^n的遞迴公式，時間複雜度$O(n)$的時間（把大數運算當作$O(1)$但其實它的常數算大）求出答案！\n如果想看從3個元素到200個元素的錯排總數，可以點這裡！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,c[1000],lenc=0;int power(int x)&#123;    if(x%2==0)return 1;    else return -1;&#125;void calculate(int s,string x)&#123;    int lenn = x.size(),product[lenc+lenn+10],brr[lenn+5];    memset(product,0,sizeof(product));    memset(brr,0,sizeof(brr));    for(int i=0;i&lt;lenn;i++)brr[i] = x[lenn-i-1]-&#x27;0&#x27;;    for(int i=0;i&lt;lenn;i++)&#123;        for(int j=0;j&lt;lenc;j++)&#123;            product[i+j] += brr[i]*c[j];            if(product[i+j] &gt;= 10)&#123;                product[i+j+1] += product[i+j]/10;                product[i+j] %= 10;            &#125;        &#125;    &#125;    for(int i=lenc+lenn+9;i&gt;=0;i--)&#123;        if(product[i]!=0)&#123;            lenc = i+1;            break;        &#125;    &#125;    for(int i=0;i&lt;lenc;i++)c[i] = product[i];    c[0] += power(s);    if(c[0]==10)&#123;        c[0] = 0;        c[1] += 1;        int ind = 1;        while(c[ind]&gt;=10)&#123;            c[ind+1]+=1;c[ind] = 0;            ind++;        &#125;    &#125;    else if(c[0]==-1)&#123;        c[0] = 9;        c[1] -= 1;        int ind = 1;        while(c[ind]&lt;=-1)&#123;            c[ind+1]-=1;c[ind]=9;            ind++;        &#125;    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;n;    memset(c,0,sizeof(c));    if(n==1)cout&lt;&lt;0&lt;&lt;endl;    else if(n==2)cout&lt;&lt;1&lt;&lt;endl;    else&#123;        c[0] = 1;lenc=1;        for(int i=3;i&lt;=n;i++)&#123;            string temp = to_string(i);            calculate(i,temp);        &#125;        for(int i=lenc-1;i&gt;=0;i--)cout&lt;&lt;c[i];        cout&lt;&lt;endl;    &#125;&#125;\n結論整理一下上面提到錯排數的公式：\n遞迴D_n = (n-1)(D_{n-1}+D_{n-2})\\quad,n\\ge3\\\\D_n = nD_{n-1}+(-1)^n\\quad,n\\ge2一般項公式解D_n=\\lfloor\\frac{n!}{e}+0.5\\rfloor\\quad,n\\ge1\\\\D_n=n!\\sum^{n}_{k=0}\\frac{(-1)^k}{k!}\\quad,n\\ge1分析錯排問題所用到的指數函數與泰勒展開會在以後學到的時候把相關東西補起來，在這之前就先接受結論吧！歐拉：「錯排問題組合數學中的一個奇妙問題」，實際查找資料發現到高中教錯排也只是淺淺的帶過公式，並沒有很深刻的對這個問題做討論（也算超出範圍啦），就想說對這個主題做更深入的一些探討！\n附錄一些的數學證明：\n要用python 繪圖之前要先在mac終端安裝一些東西：\npython3 -m pip install numpypython3 -mpip install matplotlib\n","categories":["數學筆記"],"tags":["數學","2021暑假筆記"]},{"title":"[題解]TIOJ 1019 Jumping Up","url":"/dp2-2/","content":"tioj-1019 Jumping Up\n題序\n定義定義 dp[i] 為第 0 個到第 i 個鈴鐺的最小移動水平距離總和\n轉移方式令$a0,a_1…a{n-1}$為相對於螢幕正中央的水平位移，選擇跳一格或跳兩格。\n$dp[i] = min(dp[i-1]+abs(ai-a{i-1}),dp[i-2]+abs(ai-a{i-2}))$\n邊界條件$dp[0] = 0,$ $dp[1] = abs(a_1-a_0)$\n程式碼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int T,N;signed main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;N;        int arr[N+1],dp[N+1];        memset(arr, 0, sizeof(arr));        memset(dp, 0, sizeof(dp));                for(int i=0;i&lt;N;i++)cin&gt;&gt;arr[i];        dp[0] = 0;dp[1] = abs(arr[1]-arr[0]);                for(int i=2;i&lt;N;i++)&#123;            dp[i] = min(dp[i-1]+abs(arr[i]-arr[i-1]),                        dp[i-2]+abs(arr[i]-arr[i-2]));        &#125;        cout&lt;&lt;dp[N-1]&lt;&lt;endl;    &#125;&#125;\n複雜度\n            這一題$dp_i$只會跟前兩項有關係，好像可以用滾動DP來優化空間，可以以後嘗試看看！\n          \n","categories":["DP題解"],"tags":["題解","DP"]},{"title":"[題解]TIOJ 1029 A遊戲","url":"/dp2-4/","content":"1029  A遊戲\ntioj1029leetcode877\n\n有一串由N個正整數所組成的數列，兩個玩者輪流拿走一個最左邊或最右邊的數，直到最後所有的數都取完之後，兩個玩者分別把自己所取到數加總，分數較高的人獲勝。範例輸入64 7 2 9 5 2輸出 18 11\n\n定義這一題用到的是區間DP定義dp[i][j]為區間$[i,j]$中先手可以拿到的最大值，因為先後手拿的總和不變，所以後手在區間$[i,j]$ 可以拿到的最大值為 $sum[i,j]-dp[i][j]$。同時，$dp[i][i] = arr[i]$    (先手取)\n轉移方式由題目可知，先後手都是以最佳策略來玩這個遊戲，而區間$[l,r]$中先手在區間$[l+1,r]$ 中就變成後手（對手先拿），因此可以推得轉移式：\ndp[i][j] = max(sum[i+1,j]-dp[i+1][j]+arr[i],\n                sum[i,j-1]-dp[i][j-1]+arr[j])（第一項取最左邊，第二項代表取最右邊）以此圖為例，以i為橫軸代表出發點，j為縱軸代表終點，由上而下、由右而左依序把左下角的表格填滿。所求即為(i,j) = (1,6)。\n邊界條件$dp[i][i] = arr[i]$\n程式碼上方的sum，可以透過表格儲存前綴和，快速求得\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);using namespace std;int n;int main()&#123;    ios    cin&gt;&gt;n;    int dp[n+1][n+1],pref[n+1],arr[n+1];    memset(dp,0,sizeof(dp));    pref[0] = 0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        dp[i][i] = arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    for(int i=n-1;i&gt;0;i--)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+arr[i],//右格                           pref[j-1]-pref[i-1]-dp[i][j-1]+arr[j]);//上格        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;&quot; &quot;&lt;&lt;pref[n]-dp[1][n]&lt;&lt;endl;    //    for(int j=1;j&lt;n+1;j++)&#123;//        for(int i=1;i&lt;=n;i++)cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;//        cout&lt;&lt;endl;//印出dp//    &#125;&#125;\n\n            Leetcode 877這裡有一系列的stone game 變化題class Solution &#123;public:    bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;        int n = piles.size();        piles.insert(piles.begin(),0);        int dp[n+1][n+1],pref[n+1];        memset(dp,0,sizeof(dp));        memset(pref,0,sizeof(pref));        for(int i=1;i&lt;=n;i++)&#123;            dp[i][i] = piles[i];            pref[i] = pref[i-1]+piles[i];        &#125;                for(int i=n-1;i&gt;0;i--)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+piles[i],                              pref[j-1]-pref[i-1]-dp[i][j-1]+piles[j]);            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;        if(dp[1][n]&gt;pref[n]/2)return true;        else return false;    &#125;&#125;;這一題有一個數學解，可以保證答案一定是true。We can extend this idea to N piles. Say the first, third, fifth, seventh, etc. piles are white, and the second, fourth, sixth, eighth, etc. piles are black. Alex can always take either all white piles or all black piles, and one of the colors must have a sum number of stones larger than the other color.簡單來說，alex可以控制對方拿到的一定是白色堆或是黑色堆，因此只要在一開始選擇數量較大的顏色就保證可以贏得遊戲\n          \n複雜度$O(N^2)$\n            這一題除了轉移式比較難想之外，要怎麼樣轉移也是一個問題。轉移方式可以透過小範圍測資試著找轉移的規律，如何轉移則可以透過畫表格的方式理解。\n          \n","categories":["DP題解"],"tags":["題解","DP"]},{"title":"DP例題","url":"/dp2/","content":"tioj-1354 池塘裡的青蛙題序這是一個排列組合的數學題目，透過動態規劃紀錄小問題的答案\n定義定義$dp[i][0]$為跳i次不回到A的方法數，$dp[i][1]$為跳i次回到A的方法數\n轉移方式\n$dp[i][1]$ = $dp[i-1][0]$應該不難理解，回到A的方法數為上一次不回到A的方法數 * 1\n$dp[i][0] = 3\\times dp[i-1][1]+2\\times dp[i-1][0]$不回到A可以分為2種情況，上一次回到A之後，可以往B,C,D，共三種情況。上一次不回到A的情況中，每一個都有兩個可以去的地方。邊界條件$dp[0][1] = 0, dp[0][0] = 1$程式碼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,k;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;k;        int dp[k+1][2];        memset(dp, 0, sizeof(dp));        dp[0][0] = 0;dp[0][1] = 1;        for(int i=1;i&lt;=k;i++)&#123;            dp[i][1] = dp[i-1][0];            dp[i][0] = 3*dp[i-1][1]+2*dp[i-1][0];        &#125;        cout&lt;&lt;dp[k][1]&lt;&lt;endl;    &#125;&#125;\n複雜度\n            這一題很討厭的，沒有給定測資的範圍，不然應該是可以直接建表然後用O(1)的複雜度求答案\n          \n\n\ntioj-1019 Jumping Up題序\n定義定義 dp[i] 為第 0 個到第 i 個鈴鐺的最小移動水平距離總和\n轉移方式令$a0,a_1…a{n-1}$為相對於螢幕正中央的水平位移，選擇跳一格或跳兩格。\n$dp[i] = min(dp[i-1]+abs(ai-a{i-1}),dp[i-2]+abs(ai-a{i-2}))$\n邊界條件$dp[0] = 0,$ $dp[1] = abs(a_1-a_0)$\n程式碼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int T,N;signed main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;N;        int arr[N+1],dp[N+1];        memset(arr, 0, sizeof(arr));        memset(dp, 0, sizeof(dp));                for(int i=0;i&lt;N;i++)cin&gt;&gt;arr[i];        dp[0] = 0;dp[1] = abs(arr[1]-arr[0]);                for(int i=2;i&lt;N;i++)&#123;            dp[i] = min(dp[i-1]+abs(arr[i]-arr[i-1]),                        dp[i-2]+abs(arr[i]-arr[i-2]));        &#125;        cout&lt;&lt;dp[N-1]&lt;&lt;endl;    &#125;&#125;\n複雜度\n            這一題$dp_i$只會跟前兩項有關係，好像可以用滾動DP來優化空間，可以以後嘗試看看！\n          \ntioj-1097 . F.營地tioj1097題序leetcode題序\n定義定義 dp[i][j] 為以索引(i,j)方格為正方形右下角所形成的最大正方形邊長\n轉移方式$dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1$看一個格字是否可以構成更大的正方形，要以它上方、左方、左上方的格子來決定（左、左上、上跟它自己剛好可以構成一個正方形）\n邊界條件初始化為題目給定的0與1（0代表不能放、1表示可以放）\n程式碼leetcode 221class Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int row = matrix.size(),col = matrix[0].size(),ans = 0;;                for(int i=0;i&lt;row;i++)&#123;            for(int j=0;j&lt;col;j++)&#123;                matrix[i][j]-=&#x27;0&#x27;;                if(matrix[i][j]==1&amp;&amp; ans ==0)ans = 1;                if(i==0||j==0)continue;                                if(matrix[i][j]==1)&#123;                    matrix[i][j] = min(min(matrix[i-1][j],matrix[i][j-1]),                                       matrix[i-1][j-1])+1;                    ans = max((int)matrix[i][j],ans);                &#125;            &#125;          &#125;        return ans*ans;    &#125;&#125;;tioj 1097#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int L,W,dp[2][5005],ans;void input(int ind)&#123;    for(int k=0;k&lt;W;k++)&#123;            int temp;            cin&gt;&gt;temp;            if(temp == 2)dp[ind][k] = 0;            else dp[ind][k] = 1;            if(dp[ind][k]==1&amp;&amp;ans == 0)ans = 1;    &#125;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;L&gt;&gt;W)&#123;        ans = 0;        if(L==0 &amp;&amp; W==0)break;        input(0);                for(int i=0;i&lt;L-1;i++)&#123;            input(1);            for(int j=1;j&lt;W;j++)&#123;                if(dp[1][j]==1)&#123;                    dp[1][j] = min(dp[0][j],min(dp[0][j-1],dp[1][j-1]))+1;                    ans = max(ans,dp[1][j]);                &#125;            &#125;            for(int i=0;i&lt;W;i++)dp[0][i] = dp[1][i];        &#125;        cout&lt;&lt;ans*ans&lt;&lt;endl;    &#125;&#125;\n複雜度\n            實作遇到的一些問題：陣列直接開空間複雜度會爆掉，所以要用到滾動DP （不然會MLE）當i=0 與j=0 時會被忽略掉，如果只有在i=0 或j=0 出現1而其他都是0（不能放）的時候，就會出現答案為0的情況，在輸入時就要做修正因為使用了滾動DP，所以在一開始會先輸入第一排，這時總共剩下L-1排，所以在第24行要是L-1次，才不會需要多輸入一行。\n          \n1029  A遊戲tioj1029leetcode877\n\n有一串由N個正整數所組成的數列，兩個玩者輪流拿走一個最左邊或最右邊的數，直到最後所有的數都取完之後，兩個玩者分別把自己所取到數加總，分數較高的人獲勝。範例輸入64 7 2 9 5 2輸出 18 11\n\n定義這一題用到的是區間DP定義dp[i][j]為區間$[i,j]$中先手可以拿到的最大值，因為先後手拿的總和不變，所以後手在區間$[i,j]$ 可以拿到的最大值為 $sum[i,j]-dp[i][j]$。同時，$dp[i][i] = arr[i]$    (先手取)\n轉移方式由題目可知，先後手都是以最佳策略來玩這個遊戲，而區間$[l,r]$中先手在區間$[l+1,r]$ 中就變成後手（對手先拿），因此可以推得轉移式：\ndp[i][j] = max(sum[i+1,j]-dp[i+1][j]+arr[i],\n                sum[i,j-1]-dp[i][j-1]+arr[j])（第一項取最左邊，第二項代表取最右邊）以此圖為例，以i為橫軸代表出發點，j為縱軸代表終點，由上而下、由右而左依序把左下角的表格填滿。所求即為(i,j) = (1,6)。\n邊界條件$dp[i][i] = arr[i]$\n程式碼上方的sum，可以透過表格儲存前綴和，快速求得#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);using namespace std;int n;int main()&#123;    ios    cin&gt;&gt;n;    int dp[n+1][n+1],pref[n+1],arr[n+1];    memset(dp,0,sizeof(dp));    pref[0] = 0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        dp[i][i] = arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    for(int i=n-1;i&gt;0;i--)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+arr[i],//右格                           pref[j-1]-pref[i-1]-dp[i][j-1]+arr[j]);//上格        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;&quot; &quot;&lt;&lt;pref[n]-dp[1][n]&lt;&lt;endl;    //    for(int j=1;j&lt;n+1;j++)&#123;//        for(int i=1;i&lt;=n;i++)cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;//        cout&lt;&lt;endl;//印出dp//    &#125;&#125;\n            Leetcode 877這裡有一系列的stone game 變化題class Solution &#123;public:    bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;        int n = piles.size();        piles.insert(piles.begin(),0);        int dp[n+1][n+1],pref[n+1];        memset(dp,0,sizeof(dp));        memset(pref,0,sizeof(pref));        for(int i=1;i&lt;=n;i++)&#123;            dp[i][i] = piles[i];            pref[i] = pref[i-1]+piles[i];        &#125;                for(int i=n-1;i&gt;0;i--)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+piles[i],                              pref[j-1]-pref[i-1]-dp[i][j-1]+piles[j]);            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;        if(dp[1][n]&gt;pref[n]/2)return true;        else return false;    &#125;&#125;;這一題有一個數學解，可以保證答案一定是true。We can extend this idea to N piles. Say the first, third, fifth, seventh, etc. piles are white, and the second, fourth, sixth, eighth, etc. piles are black. Alex can always take either all white piles or all black piles, and one of the colors must have a sum number of stones larger than the other color.簡單來說，alex可以控制對方拿到的一定是白色堆或是黑色堆，因此只要在一開始選擇數量較大的顏色就保證可以贏得遊戲\n          \n複雜度$O(N^2)$\n            這一題除了轉移式比較難想之外，要怎麼樣轉移也是一個問題。轉移方式可以透過小範圍測資試著找轉移的規律，如何轉移則可以透過畫表格的方式理解。\n          \n","categories":["C++基礎主題","動態規劃"],"tags":["DP","C++基礎主題"]},{"title":"DP問題-經典題學習","url":"/dp1/","content":"動態規劃的要素可以動態規劃的問題符合兩個條件\n重複子問題\n可分治性\n\n動態規劃的三要素\n0.定義\n1.狀態轉移方式\n2.初始狀態（邊界條件）\n\n\n動態規劃應注意的問題\n轉移方式：Top-Down or Bottom-up\n複雜度=狀態數*轉移時間\n轉移順序\n\n[IOI 1994] 三角旅行\n0.定義定義陣列dp[i][j]為走到第 i 橫排第 j 格的時候可能的最大值。\n1.轉移方式第 i 橫排第 j 格的解為：「第 i+1 橫排第 j 格」與「第 i+1 橫排第 j+1 格」的最大值，加上原本第 i 橫排第 j 格的值。以範測為例:轉移程式碼：\ndp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+arr[i][j];\n2.邊界條件我是從第 n-1 層開始dp轉移，所以邊界就是第 n 層的所有元素\nfor(int i=0;i&lt;n;i++)    dp[n-1][i] = arr[n-1][i];\n而答案即為dp[0][0]，也就是三角形的頂端\n程式碼#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,dp[105][105] = &#123;0&#125;,arr[105][105] = &#123;0&#125;;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;=i;j++)cin&gt;&gt;arr[i][j];        for(int i=0;i&lt;n;i++)dp[n-1][i] = arr[n-1][i];        for(int i=n-2;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=i;j++)&#123;            dp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+arr[i][j];        &#125;    &#125;    cout&lt;&lt;dp[0][0]&lt;&lt;endl;&#125;\n最大子陣列leetcode 53暴力解（O(n^2^)）或是用動態規劃處理（O(n)）方法：利用變數 sum 加總a[0],a[1] 到 a[n-1]，在加總過程中，如果出現負數，則代表對最大子陣列沒有幫助（只會越來越少，所以捨棄），則讓sum=0 ，繼續加總，並在每一次相加過程紀錄最大值 max。\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int sum = 0,len = nums.size(),max = -1e9;        for(int i=0;i&lt;len;i++)&#123;            sum+=nums[i];            if(sum&gt;max)max = sum;            if(sum&lt;0)sum = 0;        &#125;        return max;    &#125;&#125;;\n背包問題背包問題總共有以下幾種：\n\n分數背包（一個物品可以切下一部分、只取幾分之幾放進背包）—Greedy\n01背包問題\n無限背包\n\n分數背包策略：貪心法。每一次取單位價值最高的物品，優先放進背包。總是用當下最好的物品填滿背包空隙，最後沒有留下任何空隙。每一份背包空間，都是最有價值的物品，就算是交換物品也無法增加總價值 ── 顯然是最佳解。時間複雜度：$O(n)$，n為物品數量\n01背包問題不考慮最佳解路徑解一：暴力法（遞迴求解）。枚舉每一種物品要放或不放進背包，但複雜度會爆掉 $O(2^N)$以zerojudge b184 為例：\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int back_pack(int n,int w)&#123;//回傳n樣物品耐重為w的最大價值    if(w&lt;0)return -1e9;//耐重為負，只能不取    if(n==0)return 0;        return max(       back_pack(n-1,w-weight[n])+val[n],//取第n個物品       back_pack(n-1,w));//不取第n個物品&#125;int main()&#123;    int n;    while(cin&gt;&gt;n)&#123;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        cout&lt;&lt;back_pack(n,100)&lt;&lt;endl;    &#125;&#125;\n\n            if(w&lt;0)return -1e9;if(n==0)return 0;這兩行程式碼不能顛倒放，否則在最末端的計算上會出現問題！（在這邊debug 超久，顛倒放會讓不該放的物品有可能被放進背包 :zany_face:）\n          \n解二：因為遞迴的關係，可以透過二維陣列紀錄小問題的解，這樣可以更有效率\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int dp[1000][105] = &#123;0&#125;;//dp[][]儲存放n樣物品耐重w的最大利潤int back_pack(int n,int w)&#123;//回傳n樣物品耐重為w的最大價值    if(w&lt;0)return -1e9;    if(n==0)return 0;    if(dp[n][w])return dp[n][w];        return dp[n][w] = max(       back_pack(n-1,w-weight[n])+val[n],       back_pack(n-1,w));&#125;int main()&#123;    int n;    while(cin&gt;&gt;n)&#123;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        cout&lt;&lt;back_pack(n,100)&lt;&lt;endl;        for(int i=0;i&lt;1000;i++)for(int k=0;k&lt;105;k++)dp[i][k] = 0;    &#125;&#125;\n解三：可以重複利用記憶體，建立一條陣列；不過計算順序要改成由陣列後端開始– 從前端可能會重複使用到同一個物品，而物品只有一個，不能重複利用(可以重複利用就變成無限背包)。\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int main()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];    cin&gt;&gt;w;        int dp[105] = &#123;0&#125;;    for(int i=0;i&lt;n;i++)&#123;        for(int j=w;j&gt;=weight[i];j--)&#123;            dp[j] = max(dp[j],dp[j-weight[i]]+val[i]);        &#125;    &#125;    cout&lt;&lt;dp[w]&lt;&lt;endl;&#125;\n時間複雜度 O(NW) ，空間複雜度 O(W) 。其中 N 是物品數量， W 是背包重量限制。（上方11-15行）\n解四：用價值作為狀態，dp紀錄重量的最小值，可以看這裡\n#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,val[105],weight[100005];cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[100005];        //定義f(n,m)取n樣物品,價值為m,重量總和最小        //dp[i]：價值為i時,重量最小為dp[i]        memset(dp,INF,sizeof(dp));        dp[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=10000;j&gt;=val[i];j--)&#123;                dp[j] = min(dp[j],dp[j-val[i]]+weight[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;=10000;i++)            if(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n時間複雜度 O(NV) ，空間複雜度 O(V) 。其中 N 是物品數量， V是價值總和。（上方11-15行）\n細節注意：\n            背包問題是否恰好裝滿對於原本初始化dp[0] = 0，代表對於重量限制為0的背包價值最高為0接下來有兩種情況需要討論，第一種是重量限制為w的背包最多的價值1. 恰好裝滿此時必須初始化dp[i] = -INF，是因為要恰好裝滿的關係，初始化的dp 數組事實上就是在沒有任何物品可以放入背包時的合法狀態，其他除了0之外容量的背包均沒有合法的解，屬於未定義的狀態，所以都應該被賦值為 −∞ 。當前的合法解，一定是從之前的合法狀態推得的2. 不需恰好裝滿如果背包並非必須被裝滿，那麼任何容量的背包都有一個合法解“什麼也不裝”，這個解的價值為0,所以初始化時狀態的值也就全部為0了。\n          \n考慮最佳解路徑需要二維陣列 p[i][j] 紀錄第 i 個物品在耐重 j 下是否有放入背包由下面的程式碼可以發現，一個物品如果放入背包，則更新p[i][j]為1\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005],p[105][105] = &#123;0&#125;;int main()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];    cin&gt;&gt;w;        int dp[105] = &#123;0&#125;;    for(int i=0;i&lt;n;i++)&#123;        for(int j=w;j&gt;=weight[i];j--)&#123;            if(dp[j-weight[i]]+val[i]&gt;dp[j])&#123;                dp[j] = dp[j-weight[i]]+val[i];                p[i][j] = 1;            &#125;        &#125;    &#125;    cout&lt;&lt;dp[w]&lt;&lt;endl;    for(int i=n-1,j = w;i&gt;=0;i--)&#123;        if(p[i][j])&#123;            cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;個物品放入背包&quot;&lt;&lt;endl;            j-=weight[i];        &#125;    &#125;&#125;\n為什麼上方第20行程式碼要從n-1開始跑？\n            以下測資：43 204 459 7012 8512可以發現第1,3物品放入背包，但如果變成以下測資：53 204 459 7012 853 10012第五個物品可以取代第一個物品，如果從 j=0 開始計算，會把第一個物品也算進去，而這樣是錯的。從 n-1 開始計算可以確保答案正確。其實從後面計算才能算到在w耐重下最後一個被加入背包的物品，如果從前面開始計算，前面不是最佳解的物品會被算進去。以這個p[][]的結果來說，最後一個被加進去的才是最佳解，前面都是被替換掉的（在陣列dp[]中被取代，因為陣列dp[]被更新的條件就是有價值更高的解）\n          \n轉移方向的不同：\n            01背包問題在壓成一維的過程中必須知道是怎麼來的，從二維壓成一維，dp更新的順序要從前到後或後到前要看是存取到哪一格的內容。這是01背包問題轉移式所用到的格子：$f(n,m) = max(f(n-1,m),f(n-1,m-w_n)+v_n)$對於每一個f(n,m)只會取用到2個格子$f(n-1,m)$和$f(n-1,m-w_n)$兩個格子，如果從前到後更新格子的話，左上方的藍色格子會先被更新到，所以改成一維陣列之後必須要從後往前更新接下來是無限背包問題：左邊的藍色格子是被更新後的，因此無限背包問題必須從前到後更新\n          \n無限背包物品有許多種類，每一種物品都無限量供應的背包問題。演算法：跟解三差不多，因為物品有無限多個，所以第二個迴圈要從 weight[i] 開始執行：\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int main()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];    cin&gt;&gt;w;        int dp[105] = &#123;0&#125;;    for(int i=0;i&lt;n;i++)&#123;        for(int j=weight[i];j&lt;=w;j++)&#123;            dp[j] = max(dp[j],dp[j-weight[i]]+val[i]);        &#125;    &#125;    cout&lt;&lt;dp[w]&lt;&lt;endl;&#125;\n找零錢問題找零錢問題總共有以下幾種：\n\n湊得某價位的最少錢幣用量\n湊得某個價位的湊法總共幾種\n\n找零錢問題就是弱化版的背包問題！\n湊得某價位的最少錢幣用量不考慮最佳解路徑定義：dp(n,m) 代表用第0種到第n種錢幣湊得價位m的最少硬幣數初始值：dp值設為 $\\infty$（求最少），dp[0] = 0轉移方式：$dp[j] = min(dp[j], dp[j-val[i]]+1)$\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,dp[105],val[100],target;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i];    cin&gt;&gt;target;    memset(dp, 0x6f, sizeof(dp));    dp[0] = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=val[i];j&lt;=target;j++)&#123;            dp[j] = min(dp[j], dp[j-val[i]]+1);        &#125;    &#125;    cout&lt;&lt;dp[target]&lt;&lt;endl;&#125;\n考慮最佳解路徑使用陣列p[i] 代表達成金額i元最後加入的硬幣面額（即達成最小硬幣數量的面額）\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,dp[105],val[100],target,p[105];//p[i]達成金額i元最後加入的硬幣面額int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i];    cin&gt;&gt;target;    memset(dp, 0x6f, sizeof(dp));    memset(p, 0, sizeof(p));    dp[0] = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=val[i];j&lt;=target;j++)&#123;            if(dp[j]&gt;dp[j-val[i]]+1)&#123;//加入第i種硬幣，使數量更少                dp[j] = dp[j-val[i]]+1;                p[j] = val[i];            &#125;        &#125;    &#125;//陣列p留下來的即為達成金額i元最後加入的硬幣面額    cout&lt;&lt;dp[target]&lt;&lt;endl;    int  k= target;    while(k&gt;0)&#123;        cout&lt;&lt;p[k]&lt;&lt;&quot; &quot;;        k = k - p[k];//前往下一個錢幣數目    &#125;    cout&lt;&lt;endl;&#125;\n湊得某個價位的湊法總共幾種定義：dp(n,m) 代表用第0種到第n種錢幣湊得價位m的湊法數目初始值：dp[0]=1(雖然現實中不可能湊到0元)轉移方式：$dp[j] =dp[j] + dp[j-val[i]]$\n            程式碼中使用 += 是因為「不加上第n種錢幣的湊法（就是未更新的dp[j]）」加上「加上第n種錢幣的湊法（剩下的就是湊滿 j-val[i] 的湊法）」\n          \n#include &lt;bits/stdc++.h&gt;using namespace std;int n,dp[1005],val[105],target;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i];    cin&gt;&gt;target;    memset(dp, 0, sizeof(dp));    dp[0] = 1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=val[i];j&lt;=target;j++)&#123;            dp[j] += dp[j-val[i]];        &#125;    &#125;    cout&lt;&lt;dp[target]&lt;&lt;endl;&#125;\n最長上升子序列（LIS）\n給你一個正整數序列，問你最多可以從裡面選出幾個元素（不改變順序），使得這些元素嚴格遞增。\n\n不考慮最佳解路徑解一：複雜度（O(n^2^)）定義：以陣列dp[i] 代表長度為序列長度為 i 時的LIS(讓dp[i]表示取了a[i]為最後一個數字的LIS)初始值：dp中的每一個元素初始值為1轉移方式：將第 i 個元素設為第 0 到 i-1 的元素之最大值加一：$dp[i] = max_{j&lt;i,a[j]&lt;a[i]} (dp[j])+1$\n以tioj 1175 Longest Increasing Subsequence為例：\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,arr[100005],dp[100005];int main()&#123;    cin&gt;&gt;n;    memset(arr, 0, sizeof(arr));    memset(dp, 0, sizeof(dp));    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];        dp[i] = 1;    &#125;    for(int i=1;i&lt;n;i++)&#123;        for(int j=0;j&lt;i;j++)&#123;            if(arr[j]&lt;arr[i])                dp[i] = max(dp[i],dp[j]+1);        &#125;    &#125;    int ans = *max_element(dp,dp+n);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n解二：複雜度（$O(nlogn)$）可以利用vector維護一個嚴格遞增的序列，同時利用lower_bound 來二分搜a[i]該在序列中的哪一個位置以 leetcode 300為例：\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; lis;        int len=nums.size();        lis.push_back(nums[0]);        for(int i=1;i&lt;len;i++)&#123;            if(lis.back()&lt;nums[i])lis.push_back(nums[i]);            else *lower_bound(lis.begin(),lis.end(),nums[i]) = nums[i];        &#125;        return lis.size();    &#125;&#125;;\n考慮最佳解路徑\n            上面方法雖然可以正確求出LIS的長度，卻無法保證vector lis裡面儲存的是正確的序列（當最末端的LIS出現後，後面的元素會因為lower_bound插入的關係出現在序列的中間解決方法：透過dp[]紀錄每一個元素出現的位置，可以求得正確的序列\n          \nkey：下方第30-35行程式碼\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,L,dp[100005],temp;vector&lt;int&gt; vec,lis,ans;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;temp;        vec.push_back(temp);    &#125;    lis.push_back(vec[0]);    dp[0] = 1;    for(int i=1;i&lt;n;i++)&#123;        int ind = 0;        if(vec[i]&gt;lis.back())&#123;            lis.push_back(vec[i]);            ind = lis.size();            dp[i] = ind;        &#125;        else&#123;            ind = lower_bound(lis.begin(), lis.end(),vec[i])-lis.begin();            lis[ind] = vec[i];            dp[i] = ind+1;//dp以1為起始        &#125;    &#125;    L = lis.size();    cout&lt;&lt;&quot;LIS:&quot;&lt;&lt;L&lt;&lt;endl;//輸出lis長度，但此時vector lis中的序列是錯誤的        for(int i=n-1;i&gt;=0;i--)&#123;        if(dp[i] == L)&#123;            ans.push_back(vec[i]);//利用vec裡的東西產生正確序列ans，捨棄lis            L--;        &#125;    &#125;    reverse(ans.begin(), ans.end());    for(auto i: ans)cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125;\n\n            範例測資：810 9 2 5 3 7 101 6得到的dp = {1 1 1 2 2 3 4 3}我們要的就是上方粗體對應到的就是正確的LIS：2 3 7 101\n          \n最長共同子序列（LCS）\n給定兩個英文字串，找出 LCS。（在兩個字串中各取出字串中字元，使兩者相等的最大長度—字母順序不可以改變）\n\n不考慮最佳解路徑定義：給定字串 s1,s2，dp[n][m]為s1長度為n、s2長度為m時的LCS初始值：初始陣列dp為0轉移：\ndp[i][j] = dp[i-1][j-1]+1, if\\ s1[i-1]=s2[j-1]$$$$dp[i][j] = max(dp[i-1][j],dp[i][j-1]), if\\ s1[i-1]!=s2[j-1]推導過程可以看：資芽講義\n以 leetcode 1143. Longest Common Subsequence為例：\nclass Solution &#123;public:int longestCommonSubsequence(string text1, string text2) &#123;    int n1 = text1.size(), n2 = text2.size(),dp[n1+1][n2+1];    memset(dp,0,sizeof(dp));    for(int i=1;i&lt;=n1;i++)&#123;        for(int j=1;j&lt;=n2;j++)&#123;            if(text1[i-1]==text2[j-1])&#123;                dp[i][j] = dp[i-1][j-1]+1;            &#125;            else&#123;                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;    &#125;    return dp[n1][n2];&#125;&#125;;\n考慮最佳解路徑求出一組LCS的方法，可以利用一個二維陣列p[i][j] 紀錄dp[i][j]從何而來，由求LCS的過程中可以發現，dp[i][j]可以有三個來源(18-32行)，分別是：\n\n左上格（此時a[i]=b[j]) — 定義為0\n左格（此時 dp[i][j-1]&gt;dp[i-1][j]）— 定義為1\n上格（此時 dp[i-1][j]&gt;dp[i][j-1]）— 定義為2\n\n紀錄完成後，透過遞迴或迴圈的方式回朔求得答案。從末端開始，如果遇到0 則往左上格移動，1 則往左格，2則往上格。\n利用遞迴求解\nvoid print(int i,int j)&#123;    if(i==0||j==0)return;//邊界    if(p[i][j]==0)&#123;        print(i-1, j-1);        cout&lt;&lt;a[i-1];    &#125;    else if(p[i][j]==1)print(i, j-1);//左格    else print(i-1, j);//上格&#125;\n利用迴圈求解因為是利用回朔法，輸出會是反序，因此新開一個陣列儲存答案\nvoid print(int i,int j)&#123;    if(!len)return;    int l = len;    char lcs[l];    while(l&gt;0)&#123;        if(p[i][j]==0)&#123;            l--;i--;j--;            lcs[l] = a[i];        &#125;        else if(p[i][j]==1)j--;//左格        else i--;//上格    &#125;    cout&lt;&lt;lcs;&#125;\n完整版程式碼：\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;string a,b;int lenA,lenB,p[1005][1005],len;void print(int i,int j);signed main()&#123;    cin&gt;&gt;a&gt;&gt;b;    lenA = a.length();    lenB = b.length();        int dp[lenA+1][lenB+1];    memset(dp, 0, sizeof(dp));    memset(p, 0, sizeof(p));//紀錄每一個dp元素從何而來    //定義：0 左上格，1 左格，2上格。    for(int i=1;i&lt;=lenA;i++)&#123;        for(int j=1;j&lt;=lenB;j++)&#123;            if(a[i-1]==b[j-1])&#123;                dp[i][j] = dp[i-1][j-1]+1;                p[i][j] = 0;//left-top            &#125;            else&#123;                if(dp[i-1][j]&lt;dp[i][j-1])&#123;                    dp[i][j] = dp[i][j-1];                    p[i][j] = 1;//left                &#125;                else&#123;                    dp[i][j] = dp[i-1][j];                    p[i][j] = 2;//top                &#125;            &#125;        &#125;    &#125;    len = dp[lenA][lenB];    cout&lt;&lt;len&lt;&lt;endl;    print(lenA, lenB);    cout&lt;&lt;endl;&#125;//遞迴void print(int i,int j)&#123;    if(i==0||j==0)return;    if(p[i][j]==0)&#123;        print(i-1, j-1);        cout&lt;&lt;a[i-1];    &#125;    else if(p[i][j]==1)print(i, j-1);    else print(i-1, j);&#125;//迴圈void print(int i,int j)&#123;    if(!len)return;    int l = len;    char lcs[l];    while(l&gt;0)&#123;        if(p[i][j]==0)&#123;            l--;i--;j--;            lcs[l] = a[i];        &#125;        else if(p[i][j]==1)j--;        else i--;    &#125;    cout&lt;&lt;lcs;&#125;\n題目＆資源學長講yeehttps://leetcode.com/tag/dynamic-programming/\n\n[x] https://tioj.ck.tp.edu.tw/problems/1354\n[x] https://tioj.ck.tp.edu.tw/problems/1019\n[ ] https://codeforces.com/problemset/problem/1207/C\n[x] https://tioj.ck.tp.edu.tw/problems/1097\n[ ] https://codeforces.com/problemset/problem/1398/D\n[x] https://tioj.ck.tp.edu.tw/problems/1029\n[x] https://zerojudge.tw/ShowProblem?problemid=d038\n[x] https://zerojudge.tw/ShowProblem?problemid=d390\n[x] https://zerojudge.tw/ShowProblem?problemid=d133\n[x] https://zerojudge.tw/ShowProblem?problemid=a133\n[x] https://zerojudge.tw/ShowProblem?problemid=d674\n\n","categories":["C++基礎主題","動態規劃"],"tags":["演算法","動態規劃"]},{"title":"計算幾何（Computational Geometry）","url":"/geo1/","content":"暑假剩沒多少天了，趕緊追進度啊！\n課程內容座標與向量\n長度、角度、座標、向量\n最常以座標、向量表示\nDefine x first, y second\n內積Dot：$A \\cdot B = A_xB_x+A_yB_y$\n外積Cross：$A \\times B = A_xB_y-A_yB_x$\n運算子重載：加減乘除、取純量（$abs()$）\n\n有向面積\n用外積算面積（有正負：有向面積）\n逆時針為正、順時針為負\n多邊形面積：任選平面上一點A，將所有點與A連線\n透過順、逆加總有向面積（p0,p1…pn,其中p0=pn）\nAREA = $\\frac{1}{2}\\sum{i=0}^{N-1}\\vec{P_i}\\times\\vec{P{i+1}}$\n\n線段相交\n線段不平行：$P_1$ 與$P_2$ 會在線段$P_3$、$P_4$異側（方向函數）\n線段平行：檢驗是否共線、並確認某一個點是否在線段上\n\n誤差分析：EPS\n使用二進位儲存：必產生誤差\n精度：float $10^{-7}$, double $10^{-16}$, long double $10^{-19}$\n誤差容忍值$eps$，將 $x\\pm eps$視為 $x$\n重載運算子：==（視為相等）,&gt;,&lt;，加上誤差範圍\nEps大小：多落在 $10^{-6}$到 $10^{-12}$ 之間\n誤差：加減法，絕對誤差相加；乘除法，相對誤差相加\n下界：數字範圍為V內時，$eps$ 至少要VK 乘上資料型態本身誤差\n上界：題目一般會給\n避免誤差大法：非到最後關頭，否則都用整數運算！\n\n三角函數\n泰勒展開式逼近，時間並非O(1)\n$atan2(y,x) = \\theta$，回傳值域$(-pi,pi]$\n回傳long double ：使用$atan2l(y,x)$\n常數大，不建議使用\n\nIEEE 754\nSign, Exponent, Mantissa\n正負號、指數部分、小數部分\n\n極角排序\n給定很多點，依照與某特定點（原點）的角度進行排序\nSort by cross，依照內積排序\n題目：平面上n個點，問一條直線最多通過幾個點\n\n凸包\n多邊形：簡單多邊形（邊不相交）、凸多邊形（內角都≤180）、凹多邊形（有內角&gt;180）\n能包住所有點的凸多邊形\n凸包求法：Monotone Chain（二維平面）、DC（三維）\nMonotone Chain\n將所有點按照(x,y)排序\n把下凸包、上凸包「圍」出來\n合併下凸包、上凸包\n開一個vector（功能為stack）紀錄當前下半凸包\n檢查新加入的點會讓哪些點不再是凸包上的點\n\n\n\n模擬退火(SA)\n尋找空間中近似最優解\n一個隨機算法\n例題：給你平面上 N 個點，請你找出一個點，使得這個點連到這 N 個點的距離總和最短\n\n計算幾何函式模板計算幾何最重要的莫過於座標上的點，實作方式可以用 $std::pair$ 或是自己定義一個類別，將點的資訊以及相關的運算式定義出來。我們總共需要重載點的大於、等於、小於的運算子，以及加法減法、向量外積內積等，同時還有很多功能是可以繼續定義下去，例如向量乘上一個定值，可以繼續加入類別中。\n點的模板及運算子重載struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(abs(x-b.x)&lt;=eps &amp;&amp; abs(y-b.y)&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;\n以上是預設點的x座標y座標都是整數的情況，如果要改成使用自定義型別，可以改用樣板(Template)自定義資料型別，根據題目的要求，使用整數或是浮點數進行運算。\ntemplate &lt;typename T&gt;class pt&#123;    T x,y;    //下方運算子重載與上方相同&#125;pt&lt;int&gt; p[N];        //點座標宣告為整數pt&lt;double&gt; pp[N];    //點的不同資料型別宣告\n方向函數針對 $\\vec a$ 以及 $\\vec b$ 外積的結果，可以知道兩者之間相對的方向。如果 $\\vec a$ 和 $\\vec b$ 共線，則回傳0，$\\vec a$ 轉向 $\\vec b$ 如果是順時針則回傳1，其餘回傳-1。\nint dir(pt a, pt b, pt o) &#123;                         //方向函數    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;\n點與線段關係以下函式可以判斷點o是否在 $\\overline{AB}$ 上，首先利用外積是否為0判斷是 $\\overline{OA}$ 與 $\\overline{OB}$ 是否平行；接著以內積判斷是否在線段中，而非線段的兩側（平行的條件下內積只可能是1或是-1）。\nbool onseg(pt a, pt b, pt o)&#123;         //o是否在ab線段上    int cross = (a - o) ^ (b - o);    //是否平行    int dot = (a - o) * (b - o);      //是否在線段中    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;\n線段相交以下函式為給定四個點$A,B,C,D$，判斷 $\\overline{AB}$ 是否相交於 $\\overline{CD}$。首先是特例的判斷，線段的其中一端點在另一線段上，利用上方點與線段關係的函式完成這個判斷。\n特例判斷完成之後，我們需要用到上方方向函式判斷線段兩端點是否在另一條線段的異側，即以下的關係式：\ndir(A,B,C)\\times dir(A,B,D) < 0我們要檢查兩條線段，其相乘結果必須皆為負數，表示處於線段的異側！最後是平行線的判斷，如果兩線平行且相交，表示兩線共線，這可以在特例時就被判斷出來。\nbool Intersection(pt a, pt b, pt c, pt d)&#123;      //線段ab是否與cd相交    if(onseg(a,b,c)||onseg(a,b,d))return true;  //點c、d是否洽在線段ab上    if(onseg(c,d,a)||onseg(c,d,b))return true;  //點a、b是否洽在線段cd上    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                            //對於線段兩端點看另外兩端點必須方向相反    return false;&#125;\n極角排序在進行全點對線段共線問題的判斷時，使用極角排序通常會比單純暴力枚舉更快速。極角也就是極座標中每一個跟原點的夾角。如果兩個點位在左半平與右半平面，則先將其判斷出來，如此才能確定起始的角度為何。\n如果位在同一個左右半平面，則透過外積的方式比較兩個向量的先後順序。以下程式碼是從座標平面270度的地方開始逆時針掃一圈依序經過的點。\nbool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //逆時針將點進行極角排序，從270度開始逆時針&#125;sort(p.begin(),p.end(),cmp);     //以id為原點進行極角排序\n凸包函數（使用Monotone Chain）首先先將所有點依照x座標進行排序，之後用掃描線由左而右的將符合要求的點推入維護的單調容器中，維護下凸包，接著利用reverse()函數將所有點逆序，也就是x座標由大到小讓掃描線由右而左掃過一遍，將上凸包也圍起來。時間複雜度為$O(n\\log n)$。\nbool check(pt a, pt b, pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa ^ bb) &gt;= 0;&#125;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //起點會經過兩次，剛好來算有向面積&#125;\n旋轉卡尺旋轉卡尺可以被應用在尋找最遠點對、面積最大三角形等問題。利用兩條平行的線中間夾著凸包，繞一圈的過程中更新需要求的數值。實作上來說就是使用兩個指針，分別指向旋轉卡尺的平行線所在的兩個點，依照旋轉的方向進行增減的動作！\nbool check2(pt a,pt b,pt c,pt d)&#123;    int aa = abs((a - c)^(b - c));    int bb = abs((a - d)^(b - d));    return aa &lt; bb;&#125;void solve()&#123;    int ans = 0,d = h,sz = hull.size();    rep(i,0,sz-1)&#123;        while(check2(hull[i],hull[(i+1)%sz],hull[d],hull[(d+1)%sz]))            d = (d+1)%sz;        ans = max(ans,(hull[i]-hull[d]).dis());        ans = max(ans,(hull[(i+1)%sz]-hull[d]).dis());    &#125;&#125;\n基本數學知識計算幾何圍繞著幾個主軸，向量運算、內積、外積，利用它們進行角度、共線與否、距離等等的判斷。之前有稍微接觸過向量，不過內積與外積是第一次碰到的主題。\n因為目前絕大部分的討論都是在二維平面上進行，因此以下都是以二維平面為前提所進行的討論！\n內積（點積）內積跟 $\\cos\\theta$ 有關，因此主要可以幫助我們判斷線段是否垂直（等於零）、以及共線時點位於正向或是反向的判斷（等於正負一）。兩個向量 $\\vec u$ 以及 $\\vec v$ 的內積可以寫成以下關係式：\n\\vec u\\cdot \\vec v = |\\vec u||\\vec v|\\cos\\theta = u_1v_1 + u_2v_2兩個向量做內積的正負號會跟餘弦函數的正負變化相同（如下圖），值域為 $[-|\\vec u||\\vec v|,|\\vec u||\\vec v|]$，並且在 $\\theta = 0,\\pi$ 有最大最小值，$\\theta = \\frac{\\pi}{2},\\frac{3\\pi}{2}$ 的值為零。\n\n外積（叉積）外積跟 $\\sin\\theta$ 有關，主要可以判斷兩向量方向關係（順逆時針旋轉）、是否平行、比較角度大小等。外積的應用十分廣泛，找凸包以及旋轉卡尺都會用到外積判斷兩個向量角度關係。兩個向量 $\\vec u$ 以及 $\\vec v$ 的外積可以寫成以下關係式：\n\\vec u\\times \\vec v = |\\vec u||\\vec v|\\sin\\theta = \\begin{bmatrix}u_1&u_2\\\\v_1&v_2\\end{bmatrix}=u_1v_2 - u_2v_1用更簡單的方式理解外積 $\\vec u\\times \\vec v$ ，其正負值可以想像成 $\\vec u$ 轉向 $\\vec v$ 所經的劣弧順逆時鐘方向。順時針為正、逆時針為負。\n關於外積的數值變化，與正弦函數的變化是一樣的（下圖），其值域跟內積一樣，不過最大最小值發生在 $\\theta = \\frac{\\pi}{2},\\frac{3\\pi}{2}$，並在 $\\theta = 0,\\pi$ 時兩向量叉積為零。\n\n面積測量師公式（行列式）這是一個從給定多邊形的座標推得面積的公式，寫成很多個三角形有向面積的總和。以下圖來說，$\\triangle FBC$、$\\triangle FCD$ 、$\\triangle FDE$ 的有向面積皆大於零，而 $\\triangle FAB$、$\\triangle FEA$ 都會因為有向面積是負的（逆時針旋轉）而被扣除掉，運算的總和即是多邊形 $ABCDE$ 的面積！\n\n一般化的公式，多邊形上總共有 $N$ 個點，令第 $N+1$ 個點為第1個點（為了要繞一圈計算面積），多邊形面積為：\nAREA = \\frac{1}{2}\\sum_{i=1}^{N}\\vec{P_i}\\times\\vec{P_{i+1}}三角形外積面積公式三角形面積有非常多算法，不過利用外積的公式還是第一次聽到。以下是公式推導過程：\n先從高中三角函數的三角形公式開始：\n\\begin{split}\\triangle ABC &= \\frac{1}{2}\\overline{AB}\\,\\overline{AC}\\cdot\\sin A\n\\\\&=\\frac{1}{2}\\sqrt{\\overline{AB}^2\\,\\overline{AC}^2\\,(1-\\cos^2A)}\n\\\\&=\\frac{1}{2}\\sqrt{\\overline{AB}^2\\,\\overline{AC}^2-(\\overline{AB}\\cdot\\overline{AC})^2}\n\\\\&=\\frac{1}{2}\\sqrt{(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1\\,x_2+y_1\\,y_2)^2}\n\\\\&=\\frac{1}{2}\\sqrt{(x_1^2\\,y_2^2)+(x_2^2\\,y_1^2)-2x_1\\,y_2\\,x_2\\,y_1}\n\\\\&=\\frac{1}{2}\\sqrt{[(x_1\\,y_2)-(x_2\\,y_1)]^2}\n\\\\&=\\frac{1}{2}|\\overrightarrow{AB}\\times \\overrightarrow{AC}|\\end{split}將三角形其中一點對另外兩點的向量做外積，除以2即為三角形面積。這個公式會在旋轉卡尺的地方使用到！\n平行四邊形面積根據上面三角形面積公式的推導，可以相對應得知道兩向量所夾平行四邊形面積公式：\nAREA = |\\overrightarrow{AB}\\times \\overrightarrow{AC}|\n","categories":["C++進階主題","計算幾何"],"tags":["計算幾何","暑期筆記"]},{"title":"[題解]TIOJ 1097 .F.營地","url":"/dp2-3/","content":"tioj-1097 . F.營地\ntioj1097題序leetcode題序\n定義定義 dp[i][j] 為以索引(i,j)方格為正方形右下角所形成的最大正方形邊長\n轉移方式$dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1$看一個格字是否可以構成更大的正方形，要以它上方、左方、左上方的格子來決定（左、左上、上跟它自己剛好可以構成一個正方形）\n邊界條件初始化為題目給定的0與1（0代表不能放、1表示可以放）\n程式碼leetcode 221\nclass Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int row = matrix.size(),col = matrix[0].size(),ans = 0;;                for(int i=0;i&lt;row;i++)&#123;            for(int j=0;j&lt;col;j++)&#123;                matrix[i][j]-=&#x27;0&#x27;;                if(matrix[i][j]==1&amp;&amp; ans ==0)ans = 1;                if(i==0||j==0)continue;                                if(matrix[i][j]==1)&#123;                    matrix[i][j] = min(min(matrix[i-1][j],matrix[i][j-1]),                                       matrix[i-1][j-1])+1;                    ans = max((int)matrix[i][j],ans);                &#125;            &#125;          &#125;        return ans*ans;    &#125;&#125;;\ntioj 1097\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int L,W,dp[2][5005],ans;void input(int ind)&#123;    for(int k=0;k&lt;W;k++)&#123;            int temp;            cin&gt;&gt;temp;            if(temp == 2)dp[ind][k] = 0;            else dp[ind][k] = 1;            if(dp[ind][k]==1&amp;&amp;ans == 0)ans = 1;    &#125;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;L&gt;&gt;W)&#123;        ans = 0;        if(L==0 &amp;&amp; W==0)break;        input(0);                for(int i=0;i&lt;L-1;i++)&#123;            input(1);            for(int j=1;j&lt;W;j++)&#123;                if(dp[1][j]==1)&#123;                    dp[1][j] = min(dp[0][j],min(dp[0][j-1],dp[1][j-1]))+1;                    ans = max(ans,dp[1][j]);                &#125;            &#125;            for(int i=0;i&lt;W;i++)dp[0][i] = dp[1][i];        &#125;        cout&lt;&lt;ans*ans&lt;&lt;endl;    &#125;&#125;\n複雜度\n            實作遇到的一些問題：陣列直接開空間複雜度會爆掉，所以要用到滾動DP （不然會MLE）當i=0 與j=0 時會被忽略掉，如果只有在i=0 或j=0 出現1而其他都是0（不能放）的時候，就會出現答案為0的情況，在輸入時就要做修正因為使用了滾動DP，所以在一開始會先輸入第一排，這時總共剩下L-1排，所以在第24行要是L-1次，才不會需要多輸入一行。\n          \n","categories":["DP題解"],"tags":["題解","DP"]},{"title":"[題解]NEOJ 398 向量加法","url":"/geo2-1/","content":"向量加法\n題目連結Submission\n\n題目敘述：給你n個數字（0≤i&lt;1，小數點精度到末九位），想知道到底有多少組 $(i,j,k)$ 滿足 $v_i+v_j=v_k$，其中 $i,j,k$ 可以重複。\n\n這題其實跟計算幾何沒什麼關係，直接用unordered_map去做（有點像two sum，不過下面的code好像也不用開到multi），簡單！不過我在浮點數的地方吃了一些WA，最後算了直接改用字串處理這個惱人的東西XD\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define int long long#define double long double#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rep2(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define eps (1e-9)#define INF 1e10#define N 2001#define ll long long#define ld long double#define int long longusing namespace std;int n;signed main()&#123;    cin&gt;&gt;n;    vector&lt;int&gt; vec(n);    rep2(i,0,n)&#123;        string s;cin&gt;&gt;s;        int num = 0,times = 1000000000;        for(int i=2;i&lt;=10;i++)&#123;            num += (s[i]-&#x27;0&#x27;)*times;            times/=10;        &#125;        vec[i] = num;    &#125;    unordered_multimap&lt;int,int&gt; mp;    for(int i=0;i&lt;n;i++)&#123;        mp.insert(&#123;vec[i],i&#125;);    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            ans += mp.count(vec[i] + vec[j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]TIOJ 1280 領土 (Territory)","url":"/geo2-13/","content":"TIOJ 1280 領土 (Territory)\n題目連結Submission\n\n題目敘述一個國家有 n 個安全哨，每一個都有座標 $(x,y)$ ，代表在座標軸上的位置。輸出該國安全哨所能圍出的最大領土。\n\nn個點所能圍成的最大面積，其實等價於凸包的面積。與前幾題的最小凸多邊形是一模一樣的題目！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)&#123;        area += (hull[i]^hull[i+1]);    &#125;    cout&lt;&lt;((area%2)?(area/2)+1:(area/2))&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]ZJ b288 夏季大三角","url":"/geo2-11/","content":"ZJ b288: 夏季大三角\n題目連結解題報告\n\n題目敘述請輸出在N個二維平面的座標，挑選3顆出來成組成三角形的最大面積\n\n比較一下兩個複雜度的作法，第一個是使用 $O(n^3)$ 枚舉所有的點並計算面積，所需要的時間是0.4sec，而且需要特別注意不能使用到海龍公式計算面積，否則有很大的機會會超時。\n\n以下作法是先進行 $O(n\\log n)$ 找尋凸包，因為面積最大的三角形必定三個點都在凸包上，因此用 $n^2$ 的時間進行枚舉，旋轉卡尺（類似最遠點對的作法）找面積最大的第三個點，就能在總時間複雜度 $O(n^2)$ 完成！（會再更少，因為只要枚舉凸包上的點）\n\n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    ld x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(abs(x-b.x)&lt;=eps &amp;&amp; abs(y-b.y)&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    ld operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    ld operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p,hull;int n,t,h;ld ans;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //這裡很關鍵，別吃WA&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    ld aa = (a - c)^(b - c);    ld bb = (a - d)^(b - d);    return aa &lt; bb;&#125;ld area(pt a,pt b)&#123;    return abs(a^b)/2;&#125;void convex_hull()&#123;    hull.clear();    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    h = down_hull-1;    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int d,sz = hull.size();    rep(i,0,sz-1)&#123;        rep(j,i+1,sz-1)&#123;            d = (j+1)%sz;            while(check2(hull[i],hull[(j)%sz],hull[d],hull[(d+1)%sz]))                d = (d+1)%sz;            ans = max(ans,area((hull[d]-hull[i]),(hull[d]-hull[j])));        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    convex_hull();    ans = 0;    solve();    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]TIOJ 1500 Clean up on aisle 3","url":"/geo2-12/","content":"TIOJ 1500 Clean up on aisle 3\n題目連結Submission\n\n題目敘述平面上n個點找最近點對的距離\n\n最近點對真的有超多種作法的，枚舉、掃描線、分治、隨機都可以做！這邊有一篇筆記比較各種時間複雜度的最近點對作法，這邊不多做贅述！\n以下程式碼是掃描線演算法，最差情況下的時間複雜度是 $O(n^2)$，因為需要排序，所以下限為 $\\Omega(n\\log n)$！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p,p+n);        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                if(p[j].x &gt; p[i].x + d)break;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]TIOJ 1678 剪多邊形（molding）","url":"/geo2-15/","content":"TIOJ 1678 剪多邊形（molding）\n題目連結TIOJTIOJ Submission題目連結ZJ\n\n題目敘述間單來說是求出多邊形面積以及凸包面積的差，詳細可以點上面題目連結。\n\n題目說多邊形需要才剪下的面積，我們就算凸包面積以及多邊形面積，兩者的差去除上題目給的色塊面積即是答案！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,a,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;int Polygon()&#123;    vector&lt;pt&gt; temp(p);    temp.push_back(temp[0]);    int area = 0;    rep(i,0,n-1)area += (temp[i]^temp[i+1]);    return abs(area);&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;a;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    ld small = (ld)Polygon()/2;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)area += (hull[i]^hull[i+1]);    ld big = (ld)area/2;    int ans = ceil((big-small)/a);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]NEOJ 399 等長線段對","url":"/geo2-2/","content":"等長線段對\n題目連結Submission\n\n題目敘述：給定平面上很多個點，求出有幾對線段等長（輸入有重複的點）。\n\n既然n≤500，那就直接枚舉吧，沒啥特別難度。\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a,i&lt;=b;i++)#define rep2(i,a,b) for(int i=a;i&lt;b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];int dist(pii a,pii b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return x*x+y*y;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep2(i,0,n)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    map&lt;int,int&gt;mp;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            int dis = dist(p[i],p[j]);            mp[dis]+=1;        &#125;    &#125;    int ans = 0;    for(auto i:mp)&#123;        int cnt = i.second;        ans+=((cnt*(cnt-1))/2);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]ZJ a871 Museum Area","url":"/geo2-14/","content":"ZJ a871: Museum Area\n題目連結\n\n題目敘述n個點圍成的多邊形，求面積\n\n水題，直接套行列式公式即可算出答案！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pdd pair&lt;double,double&gt;#define int long long#define ld long double#define N 15#define x first#define y secondusing namespace std;int n;pdd p[N];ld check(pdd a, pdd b)&#123;    return a.x*b.y - a.y*b.x;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ld area = 0.0;        rep(i,0,n-1)area += check(p[i],p[i+1]);        ld ans = (ld)area/2;        if(ans&lt;0)ans = -ans;        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]ZJ d269 11579 Triangle Trouble","url":"/geo2-16/","content":"ZJ d269: 11579 - Triangle Trouble\n題目連結\n\n題目敘述有一個三角形工廠有一個很大的問題。給你一些邊的邊長，想辦法找出用這些邊長圍出最大的三角形。\n\n根據海龍公式，三角形面積：\n\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)}可以利用貪婪法，將所有邊長由大到小進行排序，每一次拿最大的三個邊長進行枚舉，即可算出最大的三角形面積。不難理解，當換上一個比較大的邊，算出來的s也會比較大，跟邊相減的值也會比較大，總面積自然較大（好啦，這是非常不嚴謹的證明XD）\n在想題過程中，我有思考到，如果周長一樣的情況下，到底何種面積的三角形面積會比較大？答案是正三角形！\n\n            三角形周長固定下面積的比較根據海龍公式：s = \\frac{1}{2}(a+b+c)想要比較在周長固定下三角形的面積，可以用算幾不等式比較，因為 $s$ 是定值，所以可以列出以下式子：\\frac{(s-a)+(s-b)+(s-c)}{3} ≥ \\sqrt[3]{(s-a)(s-b)(s-c)}等好成立時，$a=b=c$。因為$s = \\frac{a+b+c}{2}$，因此：(\\frac{a}{2})^2 ≥ (s-a)(s-b)(s-c)得到海龍公式\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)} ≤ \\sqrt{\\frac{3a}{2}\\cdot\\frac{a^3}{8}}=\\frac{\\sqrt{3}}{4}a^2\n          \n以下是使用貪婪法的AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define ll long long#define ld double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;int t,n;vector&lt;ld&gt; p;ld area(ld a ,ld b, ld c)&#123;    if(a &gt; b + c)return -1;    ld p = (a+b+c)/2;    return p*(p-a)*(p-b)*(p-c);&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,0);        rep(i,0,n-1)cin&gt;&gt;p[i];        sort(all(p),greater&lt;&gt;());        ld ans = 0;        rep(i,0,n-3)            ans = max(ans,area(p[i],p[i+1],p[i+2]));        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;sqrt(ans)&lt;&lt;endl;    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]TIOJ 1105 H.PS3","url":"/geo2-10/","content":"TIOJ 1105 H.PS3\n題目連結Submission $O(n^2)$Submission $O(n\\log n)$\n\n題目敘述給你平面上N個點（N≤3000），請求出最遠點對的索引值（小的在前、大的在後）\n\n我做了一份最近點對：不同複雜度之解決方式的筆記，共有四種方法可以解決那個問題，這一題要求的是最遠點對，作法與最近點對其實差蠻遠的。由上幾題知道凸包的求法，因為凸包是可以圍住所有點的多邊形，因此最遠點對也應該在凸包上，而且所在的位置會為在凸包的兩側上（如果不落在凸包上，一定可以把點向兩側延伸到凸包上，且移動過後的點對距離一定比原始的點對距離大）。\n找完凸包之後，可以用旋轉卡尺的方式尋找最遠點對。想像兩條平行線中間夾著凸包，逆時鐘旋轉繞行凸包一圈，過程不斷更新最遠點對的距離。在實作上兩條平行線可以被想像成由 $Pi$ 指向 $P{i+1}$ 的向量，透過外積三角形面積公式決定卡尺該如何移動。\nAREA = |\\overrightarrow{AB}\\times \\overrightarrow{AC}|以下圖為例，我們要找 $\\overline{HM}$ 為底可以形成的最大三角形面積的頂點，因為在同底的情況下面積就代表點與邊的垂直距離，最大的垂直距離意味著這條底邊可以垂直延伸的最遠距離。因為凸包必定是凸多邊形，因此三角形的面積會呈現單峰函數，因此只需要從下一個三角形面積的大小，決定雙指針中比較快的指標的移動情況。\n\n如果仔細來看，以下圖為例，當前較快的指標指向的位置是 $D$ 點，考慮一條與與 $\\overline{HM}$ 平行的直線，若下一個點 $J$ 在平行線段的另外一側，則將指標移往 $J$ 點。可能會有一個疑問，如果比較下圖的線段長度，會發現到 $\\overline{DH}$ 的長度比經過 $J$ 點的兩條線段都還要長，那為何還要更新至 $J$ 點？舉這個例子不太好，不過可以想像當旋轉卡尺轉到以 $\\overline{FH}$ 為底的時候，會將最遠點對的距離更新成 $\\overline{HD}$ 的長度。如果今天 $H$ 的左側又多加了一個新點 $P$，則最遠點對會變成 $\\overline{PD}$ 的距離。\n簡單來說，最遠點對一定會發生對角的凸包點上面，即使現在以 $\\overline{HM}$ 為底最遠點並非 $J$ 而是 $D$ ，但在旋轉卡尺旋轉到 $\\overline{FH}$ 時就能將距離更新成 $\\overline{HD}$ 的距離。\n\n\n            實作小細節這一題有點麻煩，因為他要輸出的是最遠點對的索引值，而不是最遠點對之間的距離。在尋找凸包的過程中，會對所有點進行排序，因此原有的索引值順序會被打亂，需要在一開始輸入的時後就好好維護每一個座標的索引值。\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y,ind;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot    int dis() &#123;return x*x + y*y;&#125;&#125;;vector&lt;pt&gt; p,hull;pt pt_ans;int n,h;bool check(pt a, pt b, pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa ^ bb) &gt;= 0;&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    int aa = abs((a - c)^(b - c));    int bb = abs((a - d)^(b - d));    return aa &lt; bb;&#125;bool cmp(pt a, pt b)&#123;    if(a == b)return a.ind &lt; b.ind;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void convex_hull()&#123;    stable_sort(all(p),cmp);    rep(i,0,n-2)if(p[i] == p[i+1])p[i+1].ind = p[i].ind;    hull.clear();    for(auto i : p)&#123;        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    int sz = hull.size();    h = hull.size()-1;    hull.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(hull.size() &gt; sz &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int ans = 0,d = h,sz = hull.size();    rep(i,0,sz-1)&#123;        while(check2(hull[i],hull[(i+1)%sz],hull[d],hull[(d+1)%sz]))            d = (d+1)%sz;        if(ans &lt; (hull[i]-hull[d]).dis())&#123;            ans = (hull[i]-hull[d]).dis();            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[i]-hull[d]).dis())&#123;            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;        if(ans &lt; (hull[(i+1)%sz]-hull[d]).dis())&#123;            ans = (hull[(i+1)%sz]-hull[d]).dis();            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[(i+1)%sz]-hull[d]).dis())&#123;            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;    &#125;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        pt_ans = (pt)&#123;0,0&#125;;        p.resize(n,&#123;0,0&#125;);        rep(i,0,n-1)&#123;            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;            p[i].ind = i;        &#125;        convex_hull();        solve();        cout&lt;&lt;pt_ans.x&lt;&lt;&quot; &quot;&lt;&lt;pt_ans.y&lt;&lt;endl;    &#125;&#125;/*59 11 51 29 95 1 */\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]NEOJ 400 向左轉向右轉","url":"/geo2-3/","content":"向左轉向右轉\n題目連結Submission\n\n題目敘述給你平面上n個點，依序走訪每一個點，試問走訪過程中共執行幾次的左轉、右轉以及迴轉。\n\n很特別，計算幾何讓電腦可以處理平常我們所看到的平面圖形，可以利用向量內積、外積等方式判斷方向。這一題最重要的就是方向函數。傳入3個點$(A,B,O)$，方向函數會會回傳$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ 的正負數值。\n下圖為外積$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ 的結果，當 $\\sin\\theta$的結果為負，也就是下圖的情況，從B走到A就需要往左邊走；反之亦然。\n至於如何判斷當兩個向量的方向呈現一直線時，也就是外積回傳的值為0時（$\\sin\\theta = 0$），應該是同向還是異向呢？這時候就需要搭配向量內積（這我想了很久），因為內積公式是$A\\cdot B = |A||B|\\cos\\theta$，將兩個向量內積之後就可以很明確的判斷到底是朝原本的方向走，還是反方向的行走！\n\n            內積、外積公式有一點數學，不過蠻有趣的。可以利用$\\sin$與$\\cos$達到計算角度的目的，利用兩者不同的值域，互相搭配，就可以更輕鬆的進行判斷！注意到外積的正負就代表著A到B是順時針或是逆時鐘。A\\cdot B = |A||B|\\cos\\theta = A_xB_x+A_yB_y\\\\A\\times B = |A||B|\\sin\\theta = A_xB_y-A_yB_x方向函數當我們要判斷方向的時候，會利用正弦函數，逆時針正、順時針為負進行判斷！int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;注意到此時在判斷是否為平行的時候（cross==0），使用到$fabs()$這個函數，目的是為了避免誤差而導致判斷錯誤，因此需要進行誤差的處理（其實不用也沒差啦，只是這樣嚴謹一點）\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; a;int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;int n,t;signed main()&#123;    Orz;    cin&gt;&gt;n;    a.resize(n+2);    rep(i,1,n)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;    int right = 0,left = 0,turn = 0;    pt pre = a[1],from = a[2];    for(int i=3;i&lt;=n;i++)&#123;        int ori = dir(a[i],from,pre);        if(ori == 1)right+=1;        else if(ori == -1)left+=1;        else if(ori == 0 &amp;&amp; ((a[i]-from)*(from-pre))&lt;0)turn+=1;        pre = from;from = a[i];    &#125;    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;turn&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]TIOJ 1178 Convex Hull","url":"/geo2-5/","content":"TIOJ 1178 Convex Hull\n題目連結Submission\n\n題目敘述給定n個二維平面的點，找出位在凸包上的所有點的個數\n\n最小凸多邊形 = 凸包，要找出能包住所有點的最小凸多邊形，簡稱凸包。聽說最好寫的凸包演算法是：Andrew’s Monotone Chain，翻成中文叫做Andrew’s 單調鍊？有一點單調+鍊的味道。下圖是我用照片合成起來的GIF，大致模擬出使用Andrew’s Monotone Chain 找凸包的方法。\n\n\n            Andrew’s Monotone Chain這個演算法的時間複雜度是 $O(n\\log n)$，空間複雜度 $O(n)$，資料說它可以解決了凸包有重疊的點、共線的點、退化成線段和點的情況。它的名字叫做「單調鍊」，要維護一個有點像單調隊列的東西，對於在容器中第 $i$ 個位置的點都滿足 $\\stackrel\\longrightarrow{Pi P{i+1}}\\times \\stackrel\\longrightarrow{P{i+1} P{i+2}} &gt; 0$ ，如果有點做外積後的結果小於等於0，則它會被pop掉（這是依照上圖逆時針完成凸包的描述，如果方向相反則會變號）。以下是此演算法的執行步驟：先把所有的點按照 $(x,y)$ 排序將下凸包圍出來，有點像維護單調隊列，對所有新加入的點i計算點i-2、i-1與i之間的外積，如果不符合情況代表圍不到新加入的點，需要將舊的點pop出來將原本已經排序好的點逆序再把上凸包由x座標大到小圍出來，將上下合併就是凸包了（必須注意起終點被push的次數問題）！\n          \n一般會用一個vector儲存在凸包上面的點（不包含在邊上的點，只有位於轉折點的點），在頭尾的部分（x座標最大與最小）需要特別處理，讓每一個點最多近到vector一次。\n\n            實作細節以下是確認是否需要將vector中元素pop出來的關鍵，對向量$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ 做外積的結果，必須排除外積結果為0的情況，如果將0也納入，會造成一個點被push進去很多次，在數量和計算上出現問題。bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;         //這裡很關鍵，別吃WA&#125;除此之外，上凸包在範圍限制上是需要注意的。假設x座標最大的點i，當在圍上凸包的過程中i是不可以被pop出去的，因此vector的大小必須大於下凸包的大小。凸包使用第i-1跟第i個點的向量去看第i到第i+1個點的向量，決定一個點要不要被推入vector中。當我們逆序從x座標最大的點往前看時，要確保每一輪結束之後在i點後都必須要有至少一個點，設定hull.size() &gt; down_hull的原因是防止在下凸包的點被圍上凸包的過程更新到。int down_hull = hull.size();    //圍上凸包的程式碼片段for(auto i: p)&#123;    while(hull.size() &gt; down_hull         &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;        hull.pop_back();    &#125;    hull.push_back(i);&#125;\n          \n以下是AC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //這裡很關鍵，別吃WA&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //起點會經過兩次，剛好來算有向面積&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = convex_hull();    cout&lt;&lt;hull.size()-1&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]NEOJ 790 來吧，遊戲開始了","url":"/geo2-7/","content":"來吧，遊戲開始了\n題目連結SubmissionGGB模擬\n\n題目敘述給你二維平面上n個點(n≤2400)，每一個點座標皆不相同，求出總共可以圍出多少個三角形？\n\n這是NEOJ上的加分題，好像是一個題組吧，反正總共有三題，這是第一題。如果 $O(n^3)$ 的枚舉，複雜度會爆炸（量級約$10^{10}$），根據電神的說法，這一題要用極角排序以及雙指標找到共線，接著就可以利用排列組合把因為共線而不能形成三角形的組合扣掉，就是答案了。\n\n這一題的核心概念是找共線，具體來說的作法是枚舉每一個點的同時，以它為原點對其他的點進行排序，如果遇到有相同的極角座標表示這些點共線，同時利用陣列cnt[x]統計共線點數為x的線段總共有幾條。\n以下的GIF就是大致上程式執行的樣子。因為一條長度為x的線段會因為枚舉x次的關係，在最後扣掉的情況會重複x次因此需要除掉。\n\n\n            共線與三角形一般情況下（任三點不共線），總共可以形成 $C^n_3$ 個三角形，如果有一條m個點共線的情況下（其他點不共線），則可以形成的三角形數量就必須扣除共線限制的情況，變成 $C^n_3-C^m_3$ 個三角形。\n          \n時間複雜度為：枚舉每一個點 $O(n)$，極角排序 $O(n\\log n)$，總時間複雜度 $O(n^2\\log n)$\n\n            實作小細節1. 維護共線連續區間我們要想辦法讓有共線的點們所在位置是一個連續的位置。三個點共線可能為在對角線的象限中，也就是點差了180度，如此一來就沒辦法讓共線的點為在連續的區間。為了達到這個目的，我們將所有位於下半平面的點都移到上半平面（在上半平面找到有相同 $\\tan\\theta$ 值的位置），接著就能利用雙指針找極角座標排序後有相同極角的區間之最大值！2. 特例判斷如果有一點y座標為0但x座標為負，要將其移到x軸正向的地方，不能把這種情況涵蓋為一般情況，否則原本在x軸正向的點會被移到x軸負向，沒有達到預期的效果。\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt; cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //逆時針將點進行極角排序，從270度開始逆時針&#125;//用cnt[i]統計區間長度為i的線段數量void solve(pt id)&#123;    vector&lt;pt&gt; pp;    for(auto i : p)&#123;                         //以id為原點        pt cur = i-id;        if(cur == pt&#123;0,0&#125;)continue;        if(cur.y &lt; 0)&#123;cur.x = -cur.x;cur.y = -cur.y;&#125;        if(cur.x &lt; 0 &amp;&amp; cur.y==0)&#123;cur.x = -cur.x;&#125;        pp.push_back(cur);    &#125;    sort(all(pp),cmp);                      //將id當作原點進行排序    int p1 = 0,p2 = 0,len = pp.size();      //雙指針找共線區間    while(p1 &lt; n-1)&#123;                        //最大化區間        while(p2+1 &lt; len &amp;&amp; (pp[p1]^pp[p2+1]) == 0)p2++;        cnt[p2-p1+2]+=1;        p1 = p2+1;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    cnt.resize(n+1,0);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    rep(i,0,n-1)solve(p[i]);    int ans = (n*(n-1)*(n-2))/6;    rep(i,3,n)ans-=(cnt[i]*(i-1)*(i-2))/6;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]NEOJ 402 最小凸多邊形","url":"/geo2-6/","content":"最小凸多邊形\n題目連結Submission\n\n題目敘述找出二維平面上n個點的凸包所圍出來的面積為何？\n\n跟上一題類似，在找到全部在凸包上面的點後，就可以利用有向面積把凸包面積算出來，有一個公式可以計算多邊形面積，利用外積得到正負值，轉一圈後得到面積！對於多邊形的頂點 $P0,P_1,…,P{n-1},P_n=P_0$ 的面積如下：\nArea = \\frac{1}{2}\\sum_{i=0}^{n-1}\\stackrel\\longrightarrow{P_i}\\times \\stackrel\\longrightarrow{P_{i+1}}其中最後一個點會回到起點，形成一個封閉的迴路。\n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //起點會經過兩次，剛好來算有向面積&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        vector&lt;pt&gt; hull = convex_hull();        int area = 0,len = hull.size();        for(int i=0;i&lt;len-1;i++)area += (hull[i]^hull[i+1]);        cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;((ld)area/2)&lt;&lt;endl;    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]NEOJ 401 線段相交","url":"/geo2-4/","content":"線段相交\n題目連結Submission線段相交 = 線段香蕉，自動選字永遠都是香蕉，有點煩XDD\n如何判斷兩線段是否相交？首先需要一個函數可以判斷點是否在一個線段上，如此一來就可以判斷端點在另一條線段上的特殊情況。以下程式碼為判斷點$P_o$ 是否在 $\\overline{P_aP_b}$ 上。利用向量外積可以判斷兩線段是否平行，而使用內積公式可以判斷$P_o$是否在線段中，而非線段的兩側！\nbool onseg(pt a, pt b, pt o)&#123;       //o是否在ab線段上    int cross = (a - o) ^ (b - o);  //是否平行    int dot = (a - o) * (b - o);    //是否在線段中    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;\n說明：由點$P_o$指向a和b的向量必須呈現180度角（也就是異向），才可確保在ab線段中（跟a,b重合也算是跟ab線段相交）。\n接下來是主要的部分，首先先確認4個端點是否恰好在另外一條線段上，判斷完之後就是處理一般相交的情況。若線段 $\\overline{P_1P_2}$ 與 $\\overline{P_3P_4}$ 相交，則點 $P_1$ 與點 $P_2$ 會在線段$\\overline{P_3P_4}$ 的異側。用方向函數表示：$dir(a,b,c)\\times dir(a,b,d)&lt;0$。確認完兩個線段之後即完成線段相交的判斷！\nbool Intersection(pt a, pt b, pt c, pt d)&#123;      //線段ab是否與cd相交    if(onseg(a,b,c)||onseg(a,b,d))return true;  //點c、d是否洽在線段ab上    if(onseg(c,d,a)||onseg(c,d,b))return true;  //點a、b是否洽在線段cd上    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                            //對於線段兩端點看另外兩端點必須方向相反    return false;&#125;\n由下圖可以得到上面的結論，當兩線段相交時，方向函數得到的值（用外積，也就是下圖 $\\theta_1$ 以及 $\\theta_2$）的方向），會呈現一正一負，從兩個相反的方向看同一條線段得出來的結論！\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; point;int dir(pt a, pt b, pt o) &#123;                         //方向函數    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;bool onseg(pt a, pt b, pt o)&#123;                       //o是否在ab線段上    int cross = (a - o) ^ (b - o);                  //是否平行    int dot = (a - o) * (b - o);                    //是否在線段中    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;bool Intersection(pt a, pt b, pt c, pt d)&#123;          //線段ab是否與cd相交    if(onseg(a,b,c)||onseg(a,b,d))return true;      //點c、d是否洽在線段ab上    if(onseg(c,d,a)||onseg(c,d,b))return true;      //點a、b是否洽在線段cd上    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                                //對於線段兩端點看另外兩端點必須方向相反    return false;&#125;int n,t;void solve()&#123;    point.assign(4,&#123;0,0&#125;);    rep(i,0,3)cin&gt;&gt;point[i].x&gt;&gt;point[i].y;    if(Intersection(point[0],point[1],point[2],point[3]))&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]TIOJ 1205 直角三角形","url":"/geo2-9/","content":"TIOJ 1205 直角三角形\n題目連結Submission\n\n題目敘述給你N（N≤1500）個座標平面上的點，請問總共可形成多少個直角三角形呢？\n\n從極角排序後的第一個點開始逆時針進行雙指針的枚舉。這邊使用到一個很特別的手法，對於共線的情況我們先透過預處理的方式將共線的點合併起來，並用cnt[x]陣列紀錄第x個點是由幾個點所合併起來的，如此一來，在進行計算的時候就不會有共線要分別處理的問題（不需擔心是不是可以跟之前的點形成直角三角形，因為相同斜率的點已經被合併剩下一個），直接將數量相乘就可以知道直角三角形的數量！\n時間複雜度：枚舉所有點 $O(n)\\times$ 進行極角排序$O(n\\log n)$ 以及雙指標$O(n)$，總時間複雜度為 $O(n^2\\log n)$。\n\n            實作小細節雙指針進行枚舉的過程中，很有可能會指標指向的索引值會超出範圍。解決的方法有兩種：超出了即代表繞了一圈，只需要對索引值取餘數即可。除了取餘數的方法之外，其實也可以直接在點集後面將所有點再推入一次，讓角度從360延伸成720度，就不會有超出範圍的問題！\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //逆時針將點進行極角排序，從270度開始逆時針&#125;//O(n)枚舉每個點當直角情況int solve(pt id)&#123;    pp.clear();cnt.clear();temp.clear();    for(pt i : p)&#123;        pt cur = i - id;        if(cur == pt&#123;0,0&#125;)continue;        temp.push_back(cur);    &#125;    sort(all(temp),cmp);            //以id為原點進行極角排序    pp.push_back(temp[0]);          //pp每一角度只存至多一個點    cnt.push_back(1);               //考慮每個點共線情況    int len = temp.size();    rep(i,1,len-1)&#123;        int cross = temp[i]^temp[i-1],dot = temp[i]*temp[i-1];        if(cross == 0 &amp;&amp; dot &gt;= 0)cnt[cnt.size()-1] += 1;   //共線數量+=1        else &#123;pp.push_back(temp[i]);cnt.push_back(1);&#125;      //非共線設定數量為1    &#125;    len = pp.size();            //考慮橫跨一周的情況    rep(i,0,len-1)&#123;             //雙指針i,p1可能會超過一圈        pp.push_back(pp[i]);    //將點再繞一圈        cnt.push_back(cnt[i]);    &#125;    int ans = 0,p1 = 0;    rep(i, 0, len-1)&#123;        while(p1 &lt; i+len &amp;&amp; (pp[i]^pp[p1]) &gt;= 0 &amp;&amp; (pp[i]*pp[p1]) &gt; 0)p1 += 1;        //夾銳角的情況要p1+=1        if((pp[i]^pp[p1]) &gt; 0 &amp;&amp; (pp[i]*pp[p1]) == 0)ans += cnt[i]*cnt[p1];        //正向的直角三角形，若共線則兩者數量相乘    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;                int ans = 0;        rep(i,0,n-1)&#123;            ans += solve(p[i]);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"[題解]NEOJ 792 遊戲：最終回","url":"/geo2-8/","content":"遊戲：最終回\n題目連結Submission\n\n題目敘述共有n個二維平面上的格子點，這些點會形成簡單多邊形。試求或在簡單多邊形內部的格線總長（包括垂直與水平格線）。\n\n這邊有一個不嚴謹的推導方式，不過他是正確的。令多邊形內部格線長度為S，多邊形的邊落在的格線長度為T，多邊形面積T，則有以下關係式：\nS = 2A-\\frac{T}{2}詳細的公式推導可以可以參閱下圖，平行四邊形（斜線部分）內部垂直的格線長度為： 大矩形 $(x_1+x_2)(y_1+y_2)$ 扣掉左右上下共四個三角形兩兩拼成一個矩形 $x_1y_1$ 以及 $x_2y_2$，還有左上右下兩個正方形 $2x_2y_1$，整理之後會發現其實跟面積是一樣的。對於垂直部分也是類似的情況。\n\n好像隱約發現到面積與格線長度有十分密切的關係，算出面積，把在格線上的邊進行特判扣掉，就可以得到格線長度。\n這一題我想了很久，一直看不出來關係式到底長怎樣，直到大神提點才發現原來有這樣的關係，我反應好遲鈍:cry:\n\n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt;  cnt;int n,edge,ans;int solve()&#123;    int area = 0;    rep(i,0,n-1)&#123;        area += (p[i]^p[i+1]);        if(p[i].y == p[i+1].y)edge += abs(p[i].x-p[i+1].x);        if(p[i].x == p[i+1].x)edge += abs(p[i].y-p[i+1].y);    &#125;    area = abs(area);    return area;&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(1);    while(cin&gt;&gt;n)&#123;        p.assign(n+1,&#123;0,0&#125;);        edge = 0;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ans = solve();        cout&lt;&lt;ans-((ld)edge/2)&lt;&lt;endl;    &#125;&#125;\n","categories":["計算幾何題解"],"tags":["題解","計算幾何"]},{"title":"計算幾何例題（Computational Geometry Problems）","url":"/geo2/","content":"題目目錄\n向量加法\n等長線段對\n向左轉向右轉\n線段相交\n最小凸多邊形\nTIOJ 1178 Convex Hull\n來吧，遊戲開始了\n遊戲：最終回\nTIOJ 1205 直角三角形\nTIOJ 1105 H.PS3\nZJ b288: 夏季大三角\nTIOJ 1500 Clean up on aisle 3\nZJ a871: Museum Area\nTIOJ 1280 領土 (Territory)\nTIOJ 1678 剪多邊形（molding）\nZJ d269: 11579 - Triangle Trouble\n\n向量加法題目連結Submission\n\n題目敘述：給你n個數字（0≤i&lt;1，小數點精度到末九位），想知道到底有多少組 $(i,j,k)$ 滿足 $v_i+v_j=v_k$，其中 $i,j,k$ 可以重複。\n\n這題其實跟計算幾何沒什麼關係，直接用unordered_map去做（有點像two sum，不過下面的code好像也不用開到multi），簡單！不過我在浮點數的地方吃了一些WA，最後算了直接改用字串處理這個惱人的東西XD\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define int long long#define double long double#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rep2(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define eps (1e-9)#define INF 1e10#define N 2001#define ll long long#define ld long double#define int long longusing namespace std;int n;signed main()&#123;    cin&gt;&gt;n;    vector&lt;int&gt; vec(n);    rep2(i,0,n)&#123;        string s;cin&gt;&gt;s;        int num = 0,times = 1000000000;        for(int i=2;i&lt;=10;i++)&#123;            num += (s[i]-&#x27;0&#x27;)*times;            times/=10;        &#125;        vec[i] = num;    &#125;    unordered_multimap&lt;int,int&gt; mp;    for(int i=0;i&lt;n;i++)&#123;        mp.insert(&#123;vec[i],i&#125;);    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            ans += mp.count(vec[i] + vec[j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n等長線段對題目連結Submission\n\n題目敘述：給定平面上很多個點，求出有幾對線段等長（輸入有重複的點）。\n\n既然n≤500，那就直接枚舉吧，沒啥特別難度。\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a,i&lt;=b;i++)#define rep2(i,a,b) for(int i=a;i&lt;b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];int dist(pii a,pii b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return x*x+y*y;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep2(i,0,n)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    map&lt;int,int&gt;mp;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            int dis = dist(p[i],p[j]);            mp[dis]+=1;        &#125;    &#125;    int ans = 0;    for(auto i:mp)&#123;        int cnt = i.second;        ans+=((cnt*(cnt-1))/2);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n向左轉向右轉題目連結Submission\n\n題目敘述給你平面上n個點，依序走訪每一個點，試問走訪過程中共執行幾次的左轉、右轉以及迴轉。\n\n很特別，計算幾何讓電腦可以處理平常我們所看到的平面圖形，可以利用向量內積、外積等方式判斷方向。這一題最重要的就是方向函數。傳入3個點$(A,B,O)$，方向函數會會回傳$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ 的正負數值。\n下圖為外積$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ 的結果，當 $\\sin\\theta$的結果為負，也就是下圖的情況，從B走到A就需要往左邊走；反之亦然。\n至於如何判斷當兩個向量的方向呈現一直線時，也就是外積回傳的值為0時（$\\sin\\theta = 0$），應該是同向還是異向呢？這時候就需要搭配向量內積（這我想了很久），因為內積公式是$A\\cdot B = |A||B|\\cos\\theta$，將兩個向量內積之後就可以很明確的判斷到底是朝原本的方向走，還是反方向的行走！\n\n            內積、外積公式有一點數學，不過蠻有趣的。可以利用$\\sin$與$\\cos$達到計算角度的目的，利用兩者不同的值域，互相搭配，就可以更輕鬆的進行判斷！注意到外積的正負就代表著A到B是順時針或是逆時鐘。A\\cdot B = |A||B|\\cos\\theta = A_xB_x+A_yB_y\\\\A\\times B = |A||B|\\sin\\theta = A_xB_y-A_yB_x方向函數當我們要判斷方向的時候，會利用正弦函數，逆時針正、順時針為負進行判斷！int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;注意到此時在判斷是否為平行的時候（cross==0），使用到$fabs()$這個函數，目的是為了避免誤差而導致判斷錯誤，因此需要進行誤差的處理（其實不用也沒差啦，只是這樣嚴謹一點）\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; a;int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;int n,t;signed main()&#123;    Orz;    cin&gt;&gt;n;    a.resize(n+2);    rep(i,1,n)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;    int right = 0,left = 0,turn = 0;    pt pre = a[1],from = a[2];    for(int i=3;i&lt;=n;i++)&#123;        int ori = dir(a[i],from,pre);        if(ori == 1)right+=1;        else if(ori == -1)left+=1;        else if(ori == 0 &amp;&amp; ((a[i]-from)*(from-pre))&lt;0)turn+=1;        pre = from;from = a[i];    &#125;    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;turn&lt;&lt;endl;&#125;\n線段相交題目連結Submission線段相交 = 線段香蕉，自動選字永遠都是香蕉，有點煩XDD\n如何判斷兩線段是否相交？首先需要一個函數可以判斷點是否在一個線段上，如此一來就可以判斷端點在另一條線段上的特殊情況。以下程式碼為判斷點$P_o$ 是否在 $\\overline{P_aP_b}$ 上。利用向量外積可以判斷兩線段是否平行，而使用內積公式可以判斷$P_o$是否在線段中，而非線段的兩側！\nbool onseg(pt a, pt b, pt o)&#123;       //o是否在ab線段上    int cross = (a - o) ^ (b - o);  //是否平行    int dot = (a - o) * (b - o);    //是否在線段中    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;\n說明：由點$P_o$指向a和b的向量必須呈現180度角（也就是異向），才可確保在ab線段中（跟a,b重合也算是跟ab線段相交）。\n接下來是主要的部分，首先先確認4個端點是否恰好在另外一條線段上，判斷完之後就是處理一般相交的情況。若線段 $\\overline{P_1P_2}$ 與 $\\overline{P_3P_4}$ 相交，則點 $P_1$ 與點 $P_2$ 會在線段$\\overline{P_3P_4}$ 的異側。用方向函數表示：$dir(a,b,c)\\times dir(a,b,d)&lt;0$。確認完兩個線段之後即完成線段相交的判斷！\nbool Intersection(pt a, pt b, pt c, pt d)&#123;      //線段ab是否與cd相交    if(onseg(a,b,c)||onseg(a,b,d))return true;  //點c、d是否洽在線段ab上    if(onseg(c,d,a)||onseg(c,d,b))return true;  //點a、b是否洽在線段cd上    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                            //對於線段兩端點看另外兩端點必須方向相反    return false;&#125;\n由下圖可以得到上面的結論，當兩線段相交時，方向函數得到的值（用外積，也就是下圖 $\\theta_1$ 以及 $\\theta_2$）的方向），會呈現一正一負，從兩個相反的方向看同一條線段得出來的結論！\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; point;int dir(pt a, pt b, pt o) &#123;                         //方向函數    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;bool onseg(pt a, pt b, pt o)&#123;                       //o是否在ab線段上    int cross = (a - o) ^ (b - o);                  //是否平行    int dot = (a - o) * (b - o);                    //是否在線段中    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;bool Intersection(pt a, pt b, pt c, pt d)&#123;          //線段ab是否與cd相交    if(onseg(a,b,c)||onseg(a,b,d))return true;      //點c、d是否洽在線段ab上    if(onseg(c,d,a)||onseg(c,d,b))return true;      //點a、b是否洽在線段cd上    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                                //對於線段兩端點看另外兩端點必須方向相反    return false;&#125;int n,t;void solve()&#123;    point.assign(4,&#123;0,0&#125;);    rep(i,0,3)cin&gt;&gt;point[i].x&gt;&gt;point[i].y;    if(Intersection(point[0],point[1],point[2],point[3]))&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nTIOJ 1178 Convex Hull題目連結Submission\n\n題目敘述給定n個二維平面的點，找出位在凸包上的所有點的個數\n\n最小凸多邊形 = 凸包，要找出能包住所有點的最小凸多邊形，簡稱凸包。聽說最好寫的凸包演算法是：Andrew’s Monotone Chain，翻成中文叫做Andrew’s 單調鍊？有一點單調+鍊的味道。下圖是我用照片合成起來的GIF，大致模擬出使用Andrew’s Monotone Chain 找凸包的方法。\n\n\n            Andrew’s Monotone Chain這個演算法的時間複雜度是 $O(n\\log n)$，空間複雜度 $O(n)$，資料說它可以解決了凸包有重疊的點、共線的點、退化成線段和點的情況。它的名字叫做「單調鍊」，要維護一個有點像單調隊列的東西，對於在容器中第 $i$ 個位置的點都滿足 $\\stackrel\\longrightarrow{Pi P{i+1}}\\times \\stackrel\\longrightarrow{P{i+1} P{i+2}} &gt; 0$ ，如果有點做外積後的結果小於等於0，則它會被pop掉（這是依照上圖逆時針完成凸包的描述，如果方向相反則會變號）。以下是此演算法的執行步驟：先把所有的點按照 $(x,y)$ 排序將下凸包圍出來，有點像維護單調隊列，對所有新加入的點i計算點i-2、i-1與i之間的外積，如果不符合情況代表圍不到新加入的點，需要將舊的點pop出來將原本已經排序好的點逆序再把上凸包由x座標大到小圍出來，將上下合併就是凸包了（必須注意起終點被push的次數問題）！\n          \n一般會用一個vector儲存在凸包上面的點（不包含在邊上的點，只有位於轉折點的點），在頭尾的部分（x座標最大與最小）需要特別處理，讓每一個點最多近到vector一次。\n\n            實作細節以下是確認是否需要將vector中元素pop出來的關鍵，對向量$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ 做外積的結果，必須排除外積結果為0的情況，如果將0也納入，會造成一個點被push進去很多次，在數量和計算上出現問題。bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;         //這裡很關鍵，別吃WA&#125;除此之外，上凸包在範圍限制上是需要注意的。假設x座標最大的點i，當在圍上凸包的過程中i是不可以被pop出去的，因此vector的大小必須大於下凸包的大小。凸包使用第i-1跟第i個點的向量去看第i到第i+1個點的向量，決定一個點要不要被推入vector中。當我們逆序從x座標最大的點往前看時，要確保每一輪結束之後在i點後都必須要有至少一個點，設定hull.size() &gt; down_hull的原因是防止在下凸包的點被圍上凸包的過程更新到。int down_hull = hull.size();    //圍上凸包的程式碼片段for(auto i: p)&#123;    while(hull.size() &gt; down_hull         &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;        hull.pop_back();    &#125;    hull.push_back(i);&#125;\n          \n以下是AC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //這裡很關鍵，別吃WA&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //起點會經過兩次，剛好來算有向面積&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = convex_hull();    cout&lt;&lt;hull.size()-1&lt;&lt;endl;&#125;\n最小凸多邊形題目連結Submission\n\n題目敘述找出二維平面上n個點的凸包所圍出來的面積為何？\n\n跟上一題類似，在找到全部在凸包上面的點後，就可以利用有向面積把凸包面積算出來，有一個公式可以計算多邊形面積，利用外積得到正負值，轉一圈後得到面積！對於多邊形的頂點 $P0,P_1,…,P{n-1},P_n=P_0$ 的面積如下：\nArea = \\frac{1}{2}\\sum_{i=0}^{n-1}\\stackrel\\longrightarrow{P_i}\\times \\stackrel\\longrightarrow{P_{i+1}}其中最後一個點會回到起點，形成一個封閉的迴路。\n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //起點會經過兩次，剛好來算有向面積&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        vector&lt;pt&gt; hull = convex_hull();        int area = 0,len = hull.size();        for(int i=0;i&lt;len-1;i++)area += (hull[i]^hull[i+1]);        cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;((ld)area/2)&lt;&lt;endl;    &#125;&#125;\n來吧，遊戲開始了題目連結SubmissionGGB模擬\n\n題目敘述給你二維平面上n個點(n≤2400)，每一個點座標皆不相同，求出總共可以圍出多少個三角形？\n\n這是NEOJ上的加分題，好像是一個題組吧，反正總共有三題，這是第一題。如果 $O(n^3)$ 的枚舉，複雜度會爆炸（量級約$10^{10}$），根據電神的說法，這一題要用極角排序以及雙指標找到共線，接著就可以利用排列組合把因為共線而不能形成三角形的組合扣掉，就是答案了。\n\n這一題的核心概念是找共線，具體來說的作法是枚舉每一個點的同時，以它為原點對其他的點進行排序，如果遇到有相同的極角座標表示這些點共線，同時利用陣列cnt[x]統計共線點數為x的線段總共有幾條。\n以下的GIF就是大致上程式執行的樣子。因為一條長度為x的線段會因為枚舉x次的關係，在最後扣掉的情況會重複x次因此需要除掉。\n\n\n            共線與三角形一般情況下（任三點不共線），總共可以形成 $C^n_3$ 個三角形，如果有一條m個點共線的情況下（其他點不共線），則可以形成的三角形數量就必須扣除共線限制的情況，變成 $C^n_3-C^m_3$ 個三角形。\n          \n時間複雜度為：枚舉每一個點 $O(n)$，極角排序 $O(n\\log n)$，總時間複雜度 $O(n^2\\log n)$\n\n            實作小細節1. 維護共線連續區間我們要想辦法讓有共線的點們所在位置是一個連續的位置。三個點共線可能為在對角線的象限中，也就是點差了180度，如此一來就沒辦法讓共線的點為在連續的區間。為了達到這個目的，我們將所有位於下半平面的點都移到上半平面（在上半平面找到有相同 $\\tan\\theta$ 值的位置），接著就能利用雙指針找極角座標排序後有相同極角的區間之最大值！2. 特例判斷如果有一點y座標為0但x座標為負，要將其移到x軸正向的地方，不能把這種情況涵蓋為一般情況，否則原本在x軸正向的點會被移到x軸負向，沒有達到預期的效果。\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt; cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //逆時針將點進行極角排序，從270度開始逆時針&#125;//用cnt[i]統計區間長度為i的線段數量void solve(pt id)&#123;    vector&lt;pt&gt; pp;    for(auto i : p)&#123;                         //以id為原點        pt cur = i-id;        if(cur == pt&#123;0,0&#125;)continue;        if(cur.y &lt; 0)&#123;cur.x = -cur.x;cur.y = -cur.y;&#125;        if(cur.x &lt; 0 &amp;&amp; cur.y==0)&#123;cur.x = -cur.x;&#125;        pp.push_back(cur);    &#125;    sort(all(pp),cmp);                      //將id當作原點進行排序    int p1 = 0,p2 = 0,len = pp.size();      //雙指針找共線區間    while(p1 &lt; n-1)&#123;                        //最大化區間        while(p2+1 &lt; len &amp;&amp; (pp[p1]^pp[p2+1]) == 0)p2++;        cnt[p2-p1+2]+=1;        p1 = p2+1;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    cnt.resize(n+1,0);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    rep(i,0,n-1)solve(p[i]);    int ans = (n*(n-1)*(n-2))/6;    rep(i,3,n)ans-=(cnt[i]*(i-1)*(i-2))/6;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n遊戲：最終回題目連結Submission\n\n題目敘述共有n個二維平面上的格子點，這些點會形成簡單多邊形。試求或在簡單多邊形內部的格線總長（包括垂直與水平格線）。\n\n這邊有一個不嚴謹的推導方式，不過他是正確的。令多邊形內部格線長度為S，多邊形的邊落在的格線長度為T，多邊形面積T，則有以下關係式：\nS = 2A-\\frac{T}{2}詳細的公式推導可以可以參閱下圖，平行四邊形（斜線部分）內部垂直的格線長度為： 大矩形 $(x_1+x_2)(y_1+y_2)$ 扣掉左右上下共四個三角形兩兩拼成一個矩形 $x_1y_1$ 以及 $x_2y_2$，還有左上右下兩個正方形 $2x_2y_1$，整理之後會發現其實跟面積是一樣的。對於垂直部分也是類似的情況。\n\n好像隱約發現到面積與格線長度有十分密切的關係，算出面積，把在格線上的邊進行特判扣掉，就可以得到格線長度。\n這一題我想了很久，一直看不出來關係式到底長怎樣，直到大神提點才發現原來有這樣的關係，我反應好遲鈍:cry:\n\n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt;  cnt;int n,edge,ans;int solve()&#123;    int area = 0;    rep(i,0,n-1)&#123;        area += (p[i]^p[i+1]);        if(p[i].y == p[i+1].y)edge += abs(p[i].x-p[i+1].x);        if(p[i].x == p[i+1].x)edge += abs(p[i].y-p[i+1].y);    &#125;    area = abs(area);    return area;&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(1);    while(cin&gt;&gt;n)&#123;        p.assign(n+1,&#123;0,0&#125;);        edge = 0;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ans = solve();        cout&lt;&lt;ans-((ld)edge/2)&lt;&lt;endl;    &#125;&#125;\nTIOJ 1205 直角三角形題目連結Submission\n\n題目敘述給你N（N≤1500）個座標平面上的點，請問總共可形成多少個直角三角形呢？\n\n從極角排序後的第一個點開始逆時針進行雙指針的枚舉。這邊使用到一個很特別的手法，對於共線的情況我們先透過預處理的方式將共線的點合併起來，並用cnt[x]陣列紀錄第x個點是由幾個點所合併起來的，如此一來，在進行計算的時候就不會有共線要分別處理的問題（不需擔心是不是可以跟之前的點形成直角三角形，因為相同斜率的點已經被合併剩下一個），直接將數量相乘就可以知道直角三角形的數量！\n時間複雜度：枚舉所有點 $O(n)\\times$ 進行極角排序$O(n\\log n)$ 以及雙指標$O(n)$，總時間複雜度為 $O(n^2\\log n)$。\n\n            實作小細節雙指針進行枚舉的過程中，很有可能會指標指向的索引值會超出範圍。解決的方法有兩種：超出了即代表繞了一圈，只需要對索引值取餘數即可。除了取餘數的方法之外，其實也可以直接在點集後面將所有點再推入一次，讓角度從360延伸成720度，就不會有超出範圍的問題！\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //逆時針將點進行極角排序，從270度開始逆時針&#125;//O(n)枚舉每個點當直角情況int solve(pt id)&#123;    pp.clear();cnt.clear();temp.clear();    for(pt i : p)&#123;        pt cur = i - id;        if(cur == pt&#123;0,0&#125;)continue;        temp.push_back(cur);    &#125;    sort(all(temp),cmp);            //以id為原點進行極角排序    pp.push_back(temp[0]);          //pp每一角度只存至多一個點    cnt.push_back(1);               //考慮每個點共線情況    int len = temp.size();    rep(i,1,len-1)&#123;        int cross = temp[i]^temp[i-1],dot = temp[i]*temp[i-1];        if(cross == 0 &amp;&amp; dot &gt;= 0)cnt[cnt.size()-1] += 1;   //共線數量+=1        else &#123;pp.push_back(temp[i]);cnt.push_back(1);&#125;      //非共線設定數量為1    &#125;    len = pp.size();            //考慮橫跨一周的情況    rep(i,0,len-1)&#123;             //雙指針i,p1可能會超過一圈        pp.push_back(pp[i]);    //將點再繞一圈        cnt.push_back(cnt[i]);    &#125;    int ans = 0,p1 = 0;    rep(i, 0, len-1)&#123;        while(p1 &lt; i+len &amp;&amp; (pp[i]^pp[p1]) &gt;= 0 &amp;&amp; (pp[i]*pp[p1]) &gt; 0)p1 += 1;        //夾銳角的情況要p1+=1        if((pp[i]^pp[p1]) &gt; 0 &amp;&amp; (pp[i]*pp[p1]) == 0)ans += cnt[i]*cnt[p1];        //正向的直角三角形，若共線則兩者數量相乘    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;                int ans = 0;        rep(i,0,n-1)&#123;            ans += solve(p[i]);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nTIOJ 1105 H.PS3題目連結Submission $O(n^2)$Submission $O(n\\log n)$\n\n題目敘述給你平面上N個點（N≤3000），請求出最遠點對的索引值（小的在前、大的在後）\n\n我做了一份最近點對：不同複雜度之解決方式的筆記，共有四種方法可以解決那個問題，這一題要求的是最遠點對，作法與最近點對其實差蠻遠的。由上幾題知道凸包的求法，因為凸包是可以圍住所有點的多邊形，因此最遠點對也應該在凸包上，而且所在的位置會為在凸包的兩側上（如果不落在凸包上，一定可以把點向兩側延伸到凸包上，且移動過後的點對距離一定比原始的點對距離大）。\n找完凸包之後，可以用旋轉卡尺的方式尋找最遠點對。想像兩條平行線中間夾著凸包，逆時鐘旋轉繞行凸包一圈，過程不斷更新最遠點對的距離。在實作上兩條平行線可以被想像成由 $Pi$ 指向 $P{i+1}$ 的向量，透過外積三角形面積公式決定卡尺該如何移動。\nAREA = |\\overrightarrow{AB}\\times \\overrightarrow{AC}|以下圖為例，我們要找 $\\overline{HM}$ 為底可以形成的最大三角形面積的頂點，因為在同底的情況下面積就代表點與邊的垂直距離，最大的垂直距離意味著這條底邊可以垂直延伸的最遠距離。因為凸包必定是凸多邊形，因此三角形的面積會呈現單峰函數，因此只需要從下一個三角形面積的大小，決定雙指針中比較快的指標的移動情況。\n\n如果仔細來看，以下圖為例，當前較快的指標指向的位置是 $D$ 點，考慮一條與與 $\\overline{HM}$ 平行的直線，若下一個點 $J$ 在平行線段的另外一側，則將指標移往 $J$ 點。可能會有一個疑問，如果比較下圖的線段長度，會發現到 $\\overline{DH}$ 的長度比經過 $J$ 點的兩條線段都還要長，那為何還要更新至 $J$ 點？舉這個例子不太好，不過可以想像當旋轉卡尺轉到以 $\\overline{FH}$ 為底的時候，會將最遠點對的距離更新成 $\\overline{HD}$ 的長度。如果今天 $H$ 的左側又多加了一個新點 $P$，則最遠點對會變成 $\\overline{PD}$ 的距離。\n簡單來說，最遠點對一定會發生對角的凸包點上面，即使現在以 $\\overline{HM}$ 為底最遠點並非 $J$ 而是 $D$ ，但在旋轉卡尺旋轉到 $\\overline{FH}$ 時就能將距離更新成 $\\overline{HD}$ 的距離。\n\n\n            實作小細節這一題有點麻煩，因為他要輸出的是最遠點對的索引值，而不是最遠點對之間的距離。在尋找凸包的過程中，會對所有點進行排序，因此原有的索引值順序會被打亂，需要在一開始輸入的時後就好好維護每一個座標的索引值。\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y,ind;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot    int dis() &#123;return x*x + y*y;&#125;&#125;;vector&lt;pt&gt; p,hull;pt pt_ans;int n,h;bool check(pt a, pt b, pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa ^ bb) &gt;= 0;&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    int aa = abs((a - c)^(b - c));    int bb = abs((a - d)^(b - d));    return aa &lt; bb;&#125;bool cmp(pt a, pt b)&#123;    if(a == b)return a.ind &lt; b.ind;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void convex_hull()&#123;    stable_sort(all(p),cmp);    rep(i,0,n-2)if(p[i] == p[i+1])p[i+1].ind = p[i].ind;    hull.clear();    for(auto i : p)&#123;        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    int sz = hull.size();    h = hull.size()-1;    hull.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(hull.size() &gt; sz &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int ans = 0,d = h,sz = hull.size();    rep(i,0,sz-1)&#123;        while(check2(hull[i],hull[(i+1)%sz],hull[d],hull[(d+1)%sz]))            d = (d+1)%sz;        if(ans &lt; (hull[i]-hull[d]).dis())&#123;            ans = (hull[i]-hull[d]).dis();            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[i]-hull[d]).dis())&#123;            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;        if(ans &lt; (hull[(i+1)%sz]-hull[d]).dis())&#123;            ans = (hull[(i+1)%sz]-hull[d]).dis();            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[(i+1)%sz]-hull[d]).dis())&#123;            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;    &#125;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        pt_ans = (pt)&#123;0,0&#125;;        p.resize(n,&#123;0,0&#125;);        rep(i,0,n-1)&#123;            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;            p[i].ind = i;        &#125;        convex_hull();        solve();        cout&lt;&lt;pt_ans.x&lt;&lt;&quot; &quot;&lt;&lt;pt_ans.y&lt;&lt;endl;    &#125;&#125;/*59 11 51 29 95 1 */\nZJ b288: 夏季大三角題目連結解題報告\n\n題目敘述請輸出在N個二維平面的座標，挑選3顆出來成組成三角形的最大面積\n\n比較一下兩個複雜度的作法，第一個是使用 $O(n^3)$ 枚舉所有的點並計算面積，所需要的時間是0.4sec，而且需要特別注意不能使用到海龍公式計算面積，否則有很大的機會會超時。\n\n以下作法是先進行 $O(n\\log n)$ 找尋凸包，因為面積最大的三角形必定三個點都在凸包上，因此用 $n^2$ 的時間進行枚舉，旋轉卡尺（類似最遠點對的作法）找面積最大的第三個點，就能在總時間複雜度 $O(n^2)$ 完成！（會再更少，因為只要枚舉凸包上的點）\n\n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    ld x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(abs(x-b.x)&lt;=eps &amp;&amp; abs(y-b.y)&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    ld operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    ld operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p,hull;int n,t,h;ld ans;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //這裡很關鍵，別吃WA&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    ld aa = (a - c)^(b - c);    ld bb = (a - d)^(b - d);    return aa &lt; bb;&#125;ld area(pt a,pt b)&#123;    return abs(a^b)/2;&#125;void convex_hull()&#123;    hull.clear();    sort(p.begin(),p.end(),cmp);       //首先對x進行排序    for(auto i : p)&#123;                   //依序走訪，如果遇到外積&lt;0則不在凸包上        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //在凸包hull的每一點都符合外積小於0    &#125;    int down_hull = hull.size();    h = down_hull-1;    hull.pop_back();                   //x最大的點會在凸包上，不用做兩次先pop一次    reverse(p.begin(),p.end());        //將所有點逆序之後做一次上面的凸包    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int d,sz = hull.size();    rep(i,0,sz-1)&#123;        rep(j,i+1,sz-1)&#123;            d = (j+1)%sz;            while(check2(hull[i],hull[(j)%sz],hull[d],hull[(d+1)%sz]))                d = (d+1)%sz;            ans = max(ans,area((hull[d]-hull[i]),(hull[d]-hull[j])));        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    convex_hull();    ans = 0;    solve();    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nTIOJ 1500 Clean up on aisle 3題目連結Submission\n\n題目敘述平面上n個點找最近點對的距離\n\n最近點對真的有超多種作法的，枚舉、掃描線、分治、隨機都可以做！這邊有一篇筆記比較各種時間複雜度的最近點對作法，這邊不多做贅述！\n以下程式碼是掃描線演算法，最差情況下的時間複雜度是 $O(n^2)$，因為需要排序，所以下限為 $\\Omega(n\\log n)$！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p,p+n);        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                if(p[j].x &gt; p[i].x + d)break;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\nTIOJ 1280 領土 (Territory)題目連結Submission\n\n題目敘述一個國家有 n 個安全哨，每一個都有座標 $(x,y)$ ，代表在座標軸上的位置。輸出該國安全哨所能圍出的最大領土。\n\nn個點所能圍成的最大面積，其實等價於凸包的面積。與前幾題的最小凸多邊形是一模一樣的題目！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)&#123;        area += (hull[i]^hull[i+1]);    &#125;    cout&lt;&lt;((area%2)?(area/2)+1:(area/2))&lt;&lt;endl;&#125;\nZJ a871: Museum Area題目連結\n\n題目敘述n個點圍成的多邊形，求面積\n\n水題，直接套行列式公式即可算出答案！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pdd pair&lt;double,double&gt;#define int long long#define ld long double#define N 15#define x first#define y secondusing namespace std;int n;pdd p[N];ld check(pdd a, pdd b)&#123;    return a.x*b.y - a.y*b.x;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ld area = 0.0;        rep(i,0,n-1)area += check(p[i],p[i+1]);        ld ans = (ld)area/2;        if(ans&lt;0)ans = -ans;        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nTIOJ 1678 剪多邊形（molding）題目連結TIOJTIOJ Submission題目連結ZJ\n\n題目敘述間單來說是求出多邊形面積以及凸包面積的差，詳細可以點上面題目連結。\n\n題目說多邊形需要才剪下的面積，我們就算凸包面積以及多邊形面積，兩者的差去除上題目給的色塊面積即是答案！\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //向量相加    pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //向量相減    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //向量外積cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //向量內積dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,a,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;int Polygon()&#123;    vector&lt;pt&gt; temp(p);    temp.push_back(temp[0]);    int area = 0;    rep(i,0,n-1)area += (temp[i]^temp[i+1]);    return abs(area);&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;a;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    ld small = (ld)Polygon()/2;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)area += (hull[i]^hull[i+1]);    ld big = (ld)area/2;    int ans = ceil((big-small)/a);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nZJ d269: 11579 - Triangle Trouble題目連結\n\n題目敘述有一個三角形工廠有一個很大的問題。給你一些邊的邊長，想辦法找出用這些邊長圍出最大的三角形。\n\n根據海龍公式，三角形面積：\n\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)}可以利用貪婪法，將所有邊長由大到小進行排序，每一次拿最大的三個邊長進行枚舉，即可算出最大的三角形面積。不難理解，當換上一個比較大的邊，算出來的s也會比較大，跟邊相減的值也會比較大，總面積自然較大（好啦，這是非常不嚴謹的證明XD）\n在想題過程中，我有思考到，如果周長一樣的情況下，到底何種面積的三角形面積會比較大？答案是正三角形！\n\n            三角形周長固定下面積的比較根據海龍公式：s = \\frac{1}{2}(a+b+c)想要比較在周長固定下三角形的面積，可以用算幾不等式比較，因為 $s$ 是定值，所以可以列出以下式子：\\frac{(s-a)+(s-b)+(s-c)}{3} ≥ \\sqrt[3]{(s-a)(s-b)(s-c)}等好成立時，$a=b=c$。因為$s = \\frac{a+b+c}{2}$，因此：(\\frac{a}{2})^2 ≥ (s-a)(s-b)(s-c)得到海龍公式\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)} ≤ \\sqrt{\\frac{3a}{2}\\cdot\\frac{a^3}{8}}=\\frac{\\sqrt{3}}{4}a^2\n          \n以下是使用貪婪法的AC Code：\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define ll long long#define ld double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;int t,n;vector&lt;ld&gt; p;ld area(ld a ,ld b, ld c)&#123;    if(a &gt; b + c)return -1;    ld p = (a+b+c)/2;    return p*(p-a)*(p-b)*(p-c);&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,0);        rep(i,0,n-1)cin&gt;&gt;p[i];        sort(all(p),greater&lt;&gt;());        ld ans = 0;        rep(i,0,n-3)            ans = max(ans,area(p[i],p[i+1],p[i+2]));        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;sqrt(ans)&lt;&lt;endl;    &#125;&#125;\n心得計算幾何，顧名思義就是在電腦完成幾何的運算，要怎麼把平面的東西轉化成電腦看得懂的東西就是計算幾何在做的事情。常常我們覺得很容易判斷的事情，例如判斷線段是否相交，我們可以利用肉眼直輕易判斷出來，因為我們有強大的空間感幫助我們進行判斷，但換作是電腦就必須用一些數學的技巧，對於不同的情況做各自的判斷，才能讓電腦正確回答兩條線段的相交情形。\n除此之外，在寫題過程中，使用到ggb進行輔助，讓我可以對程式的執行過程有更是覺化的概念，也幫助我在解題時能更理解解題的策略！上面一題三角形個數的判斷，就使用了ggb判定將點搬移的所有情況。利用它我抓到了當點的y座標為零時並沒進行好特殊情況的判斷，這也是一個視覺化之後的好處！\n有一題沒有做的是模擬退火的題目實作，要求圓與三角形的交集面積，感覺超級複雜，以後有時間來慢慢實作！\n","categories":["C++進階主題","計算幾何"],"tags":["計算幾何","暑期筆記"]},{"title":"[題解]Leetcode 149 Max Points on a Line","url":"/geo3-1/","content":"149 Max Points on a Line\n題目連結\nclass Solution &#123;public:        int gcd(int a,int b)&#123;        if(a &gt; b)swap(a,b);        if(a == 0)return b;        return gcd(b % a, a);    &#125;        int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            map&lt;pair&lt;int,int&gt;,int&gt; mp;            int same = 0,hori = 0;            for(int j = i+1;j &lt; n;j++)&#123;                int dx = points[i][0] - points[j][0];                int dy = points[i][1] - points[j][1];                if(dx == 0 &amp;&amp; dy == 0)&#123;same++;continue;&#125;                if(dx == 0 &amp;&amp; dy != 0)&#123;hori++;continue;&#125;                int g = gcd(abs(dx),abs(dy));                if(dy &lt; 0 || (dy == 0 &amp;&amp; dx &lt; 0))&#123;dx = -dx;dy = -dy;&#125;                mp[&#123;dx/g,dy/g&#125;]++;            &#125;            int sum = hori + same + 1;            for(auto it : mp)sum = max(sum,it.second + 1);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 892 Surface Area of 3D Shapes","url":"/geo3-11/","content":"892 Surface Area of 3D Shapes\n題目連結\nclass Solution &#123;public:    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans = 0,n = grid.size();        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans += 4 * grid[i][j] + 2;                if(i &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i+1][j])*2;                &#125;                if(j &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i][j+1])*2;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 939 Minimum Area Rectangle","url":"/geo3-12/","content":"939 Minimum Area Rectangle\n題目連結\nclass Solution &#123;public:    int minAreaRect(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        vector&lt;vector&lt;int&gt;&gt;p = points;        int n = points.size();        set&lt;pair&lt;int,int&gt;&gt;s;        for(int i=0;i&lt;n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        int ans = INT_MAX;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(s.find(&#123;p[i][0],p[j][1]&#125;)!=s.end()                    &amp;&amp; s.find(&#123;p[j][0],p[i][1]&#125;)!=s.end())&#123;                    if(p[i][0] == p[j][0] || p[i][1] == p[j][1])continue;                    ans = min(ans,abs(p[i][0]-p[j][0])*abs(p[i][1]-p[j][1]));                &#125;            &#125;        &#125;        if(ans == INT_MAX)return 0;        else return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 883 Projection Area of 3D Shapes","url":"/geo3-10/","content":"883 Projection Area of 3D Shapes\n題目連結\n三種不同的投影對應到三種不同的角度看圖形。x-y的面積即為由上而下看有方格的個數。x-z是從前方看，因此對應到的是每一行的最大方塊個數。\nclass Solution &#123;public:    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int n = grid.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            int maxR = 0,maxC = 0;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans++;        //由上往下看                maxR = max(maxR,grid[i][j]);    //由側邊看                maxC = max(maxC,grid[j][i]);    //由前面看            &#125;            ans += maxR + maxC;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 963 Minimum Area Rectangle II","url":"/geo3-13/","content":"963 Minimum Area Rectangle II\n題目連結\nclass Solution &#123;public:    double minAreaFreeRect(vector&lt;vector&lt;int&gt;&gt;&amp; p)&#123;        set&lt;pair&lt;int,int&gt;&gt; s;        int n = p.size();        for(int i = 0;i &lt; n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        double ans = 1e9;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                int x1 = p[j][0] - p[i][0];                int y1 = p[j][1] - p[i][1];                for(int k = j+1;k &lt; n;k++)&#123;                    int x2 = p[k][0] - p[i][0];                    int y2 = p[k][1] - p[i][1];                    if(x1 * x2 + y1 * y2 != 0)continue;                    int nx = p[k][0] + x1,ny = p[k][1] + y1;                    if(s.find(&#123;nx,ny&#125;) != s.end())&#123;                        ans = min(ans,sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2));                    &#125;                &#125;            &#125;        &#125;        if(ans == 1e9)return 0;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 973 K Closest Points to Origin","url":"/geo3-14/","content":"973 K Closest Points to Origin\n題目連結\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;        int n = points.size();        multimap&lt;int,int&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            int x = points[i][0];            int y = points[i][1];            mp.insert(&#123;x * x + y * y,i&#125;);        &#125;        auto it = mp.begin();        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;k;i++)&#123;            int id = it-&gt;second;            ans.push_back(points[id]);            it++;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1030 Matrix Cells in Distance Order","url":"/geo3-15/","content":"1030 Matrix Cells in Distance Order\n題目連結\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) &#123;        int n = rows,m = cols;        multimap&lt;int,pair&lt;int,int&gt;&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; m;j++)&#123;                int dis = abs(i - rCenter) + abs(j - cCenter);                mp.insert(&#123;dis,&#123;i,j&#125;&#125;);            &#125;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n*m);        for(int i=0;i&lt;n*m;i++)ans[i].resize(2,0);        int id = 0;        for(auto it : mp)&#123;            ans[id][0] = (it.second.first);            ans[id][1] = (it.second.second);            id++;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1037 Valid Boomerang","url":"/geo3-16/","content":"1037 Valid Boomerang\n題目連結\nclass Solution &#123;public:    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int x1 = points[1][0]-points[0][0],y1 = points[1][1]-points[0][1];        int x2 = points[2][0]-points[1][0],y2 = points[2][1]-points[1][1];        int cross = x1 * y2 - x2 * y1;        if(cross == 0)return false;        return true;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1232 Check If It Is a Straight Line","url":"/geo3-17/","content":"1232 Check If It Is a Straight Line\n題目連結\nclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        vector&lt;vector&lt;int&gt;&gt; p = coordinates;        int n = p.size();        for(int i = 0;i &lt; n-2;i++)&#123;            int x1 = p[i+1][0] - p[i][0],y1 = p[i+1][1] - p[i][1];            int x2 = p[i+2][0] - p[i+1][0],y2 = p[i+2][1] - p[i+1][1];            if(x1 * y2 != x2 * y1)return false;        &#125;        return true;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1266 Minimum Time Visiting All Points","url":"/geo3-18/","content":"1266 Minimum Time Visiting All Points\n題目連結\nclass Solution &#123;public:    int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        vector&lt;vector&lt;int&gt;&gt; p = points;        for(int i = 0;i &lt; n-1;i++)&#123;            ans += max(abs(p[i+1][0] - p[i][0]),abs(p[i+1][1] - p[i][1]));        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1401 Circle and Rectangle Overlapping","url":"/geo3-19/","content":"1401 Circle and Rectangle Overlapping\n題目連結\nclass Solution &#123;public:    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) &#123;        int x = clamp(x_center,x1,x2) - x_center;        int y = clamp(y_center,y1,y2) - y_center;        return x*x + y*y &lt;= radius * radius;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 223 Rectangle Area","url":"/geo3-2/","content":"223 Rectangle Area\n題目連結\nclass Solution &#123;public:    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) &#123;        int x = max(min(ax2,bx2) - max(ax1,bx1),0);        int y = max(min(ay2,by2) - max(ay1,by1),0);        int ans = (ax2 - ax1)*(ay2 - ay1)+(bx2 - bx1)*(by2 - by1)-x * y;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1453 Maximum Number of Darts Inside of a Circular Dartboard","url":"/geo3-20/","content":"1453 Maximum Number of Darts Inside of a Circular Dartboard\n題目連結\n#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y second#define exp 1e-6class Solution &#123;public:        double dis(pdd a,pdd b)&#123;        ld x = a.x - b.x,y = a.y - b.y;        return sqrt(x * x + y * y);    &#125;        pair&lt;pdd,pdd&gt; get_center(pdd a,pdd b,ld R)&#123;        pdd mid = &#123;(a.x + b.x) / 2,(a.y + b.y) / 2&#125;;        ld theta = atan2(a.y - b.y, b.x - a.x);        ld tmp = dis(a,b) / 2, d = sqrt(R * R - tmp * tmp);                pair&lt;pdd,pdd&gt; ans;        ans.x = &#123;mid.x - d * sin(theta),mid.y - d * cos(theta)&#125;;        ans.y = &#123;mid.x + d * sin(theta),mid.y + d * cos(theta)&#125;;        return ans;    &#125;        int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; point, int R) &#123;        int n = point.size(),ans = 1;        pdd p[n];for(int i=0;i&lt;n;i++)&#123;p[i] = &#123;point[i][0],point[i][1]&#125;;&#125;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(dis(p[i],p[j]) - 2.0 * R &gt;= exp)continue;                pair&lt;pdd,pdd&gt; cur = get_center(p[i],p[j],R);                int cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.x) - R&lt;= exp)cnt ++;                ans = max(ans, cnt);cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.y) - R &lt;= exp)cnt ++;                ans = max(ans, cnt);            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1610 Maximum Number of Visible Points","url":"/geo3-22/","content":"1610 Maximum Number of Visible Points\n題目連結\n#define ld long doubleconst int N = 1e5+5;class Solution &#123;public:    int visiblePoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int angle, vector&lt;int&gt;&amp; loc) &#123;        vector&lt;ld&gt; ang;        int overlap = 0,n = points.size(),ans = 0;        for(auto p : points)&#123;            if(p[0] == loc[0] &amp;&amp; p[1] == loc[1])overlap++;            else ang.push_back(atan2l(p[1]-loc[1],p[0]-loc[0]) * 180 / (ld)M_PI);        &#125;        int sz = ang.size();        for(int i = 0;i &lt; sz;i++)ang.push_back(ang[i] + 360);        sort(ang.begin(),ang.end());        sz = ang.size();        for(int i = 0,it2 = 0;i &lt; sz;i++)&#123;            while(it2 &lt; sz &amp;&amp; ang[it2] - ang[i] &lt;= angle)it2++;            ans = max(ans,it2 - i);        &#125;        return ans + overlap;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1515 Best Position for a Service Centre","url":"/geo3-21/","content":"1515 Best Position for a Service Centre\n題目連結\n這一題是模擬退火，非常酷，之前沒有寫過的東西。\n#define eps 1e-6#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 100;        ld dx[4] = &#123;1.0,0.0,-1.0,0.0&#125;,dy[4] = &#123;0.0,1.0,0.0,-1.0&#125;;        bool flag = 0;        while(test_size &gt; eps)&#123;            flag = 0;            for(int i = 0;i &lt; 4;i++)&#123;                pdd newp = cur;                newp.x += dx[i] * test_size;                newp.y += dy[i] * test_size;                ld new_dis = dis_all(newp);                if(new_dis &lt; mid_dis)&#123;                    mid_dis = new_dis;                    cur = newp;                    flag = 1;                    break;                &#125;            &#125;            if(flag == 0)test_size /= 2.0;        &#125;        return mid_dis;    &#125;&#125;;\n換另外一種迭代方式\n#define eps 1e-8#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        srand(time(NULL));        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 150.0;        while(test_size &gt; eps)&#123;            pdd newp = cur;            int temp = rand();            newp.x += cos(temp) * test_size;            newp.y += sin(temp) * test_size;            ld new_dis = dis_all(newp);            if(new_dis &lt; mid_dis)&#123;                mid_dis = new_dis;                cur = newp;            &#125;            else test_size *= 0.99;        &#125;        return mid_dis;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 1828 Queries on Number of Points Inside a Circle","url":"/geo3-23/","content":"1828 Queries on Number of Points Inside a Circle\n題目連結\nclass Solution &#123;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int n = queries.size(),m = points.size();        vector&lt;int&gt; ans;ans.resize(n);        for(int i = 0;i &lt; n;i++)&#123;            int rx = queries[i][0],ry = queries[i][1],sum = 0;            for(int j = 0;j &lt; m;j++)&#123;                int x = points[j][0] - rx,y = points[j][1] - ry;                if(x * x + y * y &lt;= queries[i][2] * queries[i][2])sum++;            &#125;            ans[i] = sum;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 2101 Detonate the Maximum Bombs","url":"/geo3-24/","content":"2101. Detonate the Maximum Bombs\n題目連結\n把圖形考慮成一張圖，符合條件的就增加一條有向邊，接著對每一個點做一次DFS即可。時間 $O(n^2)$。\n#define pii pair&lt;int,int&gt;#define ld long doubleclass Solution &#123;public:        vector&lt;int&gt; E[105];    ld dis(pii a,pii b)&#123;        int x = a.first - b.first,y = a.second - b.second;        return sqrt((long long)x * x + (long long)y * y);    &#125;    int sum = 1;    bool vis[105];    void dfs(int now)&#123;        vis[now] = 1;        for(auto i : E[now])&#123;            if(vis[i])continue;            sum++;vis[i] = 1;            dfs(i);        &#125;    &#125;        int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bomb) &#123;        int n = bomb.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                pii a = &#123;bomb[i][0],bomb[i][1]&#125;,b = &#123;bomb[j][0],bomb[j][1]&#125;;                int r1 = bomb[i][2],r2 = bomb[j][2];                ld d = dis(a,b);                if(r1 &gt;= d)E[i].push_back(j);                if(r2 &gt;= d)E[j].push_back(i);            &#125;        &#125;        for(int i = 0;i &lt; n;i++)&#123;            fill(vis,vis+105,0);            sum = 1;            dfs(i);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 335 Self Crossing","url":"/geo3-3/","content":"335 Self Crossing\n題目連結\nclass Solution &#123;public:    bool isSelfCrossing(vector&lt;int&gt;&amp; d) &#123;        int n = d.size();        if(n &lt;= 3)return false;        for(int i = 3;i &lt; n;i++)&#123;            //第四條、第五條、第六條交第一條            if(d[i] &gt;= d[i-2] &amp;&amp; d[i-1] &lt;= d[i-3])return true;            if(i &gt;= 4 &amp;&amp; d[i-1] == d[i-3] &amp;&amp; d[i] + d[i-4] &gt;= d[i-2])return true;            if(i &gt;= 5 &amp;&amp; d[i-2] &gt;= d[i-4] &amp;&amp; d[i] &gt;= d[i-2] - d[i-4]              &amp;&amp; d[i-1] &gt;= d[i-3]-d[i-5] &amp;&amp; d[i-1] &lt;= d[i-3])return true;                    &#125;        return false;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 593 Valid Square","url":"/geo3-5/","content":"593 Valid Square\n題目連結\nclass Solution &#123;public:        int dis(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2)&#123;        int x = p1[0] - p2[0],y = p1[1] - p2[1];        return x * x + y * y;    &#125;        bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) &#123;        map&lt;int,int&gt;mp;     //長度、個數        mp[dis(p1,p2)]++;        mp[dis(p1,p3)]++;        mp[dis(p1,p4)]++;        mp[dis(p2,p3)]++;        mp[dis(p2,p4)]++;        mp[dis(p3,p4)]++;        return mp.size() == 2 &amp;&amp; mp.begin()-&gt;second == 4;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 587 Erect the Fence","url":"/geo3-4/","content":"587 Erect the Fence\n題目連結\n#define pii pair&lt;int,int&gt;#define ff first#define ss secondclass Solution &#123;public:        bool check(pii a,pii b,pii o)&#123;        pii aa = &#123;a.ff - o.ff,a.ss - o.ss&#125;;        pii bb = &#123;b.ff - o.ff,b.ss - o.ss&#125;;        int cross = aa.ff * bb.ss - aa.ss * bb.ff;        return cross &gt; 0;    &#125;        vector&lt;vector&lt;int&gt;&gt; outerTrees(vector&lt;vector&lt;int&gt;&gt;&amp; point) &#123;        vector&lt;pii&gt; h;        int n = point.size();        vector&lt;pii&gt; p(n);        for(int i = 0;i &lt; n;i++)p[i] = &#123;point[i][0],point[i][1]&#125;;        sort(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; 1 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        int down = h.size();        h.pop_back();        reverse(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; down &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        set&lt;pii&gt; s;for(auto i : h)s.insert(i);        n = s.size();        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n);        for(int i=0;i&lt;n;i++)ans[i].resize(2);        int id = 0;        for(auto i : s)&#123;ans[id][0] = i.ff;ans[id][1] = i.ss;id++;&#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 812\tLargest Triangle Area","url":"/geo3-6/","content":"812 Largest Triangle Area\n題目連結\nclass Solution &#123;public:        int cross(int x1,int y1,int x2,int y2)&#123;        return x1 * y2 - x2 * y1;    &#125;        double area(int a,int b,int c,int d,int e,int f)&#123;        double sum = 0;        sum += cross(a,b,c,d);        sum += cross(c,d,e,f);        sum += cross(e,f,a,b);        return abs(sum / 2.0);    &#125;        double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size();        double ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i + 1;j &lt; n;j++)&#123;                for(int p = j + 1;p &lt; n;p++)&#123;                    ans = max(ans,area(points[i][0],points[i][1]                                      ,points[j][0],points[j][1]                                      ,points[p][0],points[p][1]));                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 836 Rectangle Overlap","url":"/geo3-7/","content":"836 Rectangle Overlap\n題目連結\nclass Solution &#123;public:    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;        //最小的右端點 - 最大的左端點        int x = min(rec1[2],rec2[2]) - max(rec1[0],rec2[0]);        //最小的上端點 - 最大的下端點        int y = min(rec1[3],rec2[3]) - max(rec1[1],rec2[1]);        return x &gt; 0 &amp;&amp; y &gt; 0;    &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 858 Mirror Reflection","url":"/geo3-8/","content":"858 Mirror Reflection\n題目連結\nclass Solution &#123;public:    int gcd(int a,int b)&#123;        if(a == 0)return b;        return gcd(b % a,a);    &#125;        int mirrorReflection(int p, int q) &#123;        int len = p * q / gcd(q,p);        int a = (len / p) % 2,b = (len / q) % 2;        if(a == 0 &amp;&amp; b == 1)return 0;        else if(a == 1 &amp;&amp; b == 1)return 1;        else return 2;            &#125;&#125;;\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"[題解]Leetcode 478 Generate Random Point in a Circle","url":"/geo3-9/","content":"478 Generate Random Point in a Circle\n題目連結\n直接Random半徑會出事（可能不夠亂，或是半徑太小），如果random面積之後算半徑才OK。\nclass Solution &#123;public:    double R,X,Y;    Solution(double radius, double x_center, double y_center) &#123;        R = radius;X = x_center;Y = y_center;        srand(time(NULL));    &#125;        vector&lt;double&gt; randPoint() &#123;        double Area = rand() * R * R * M_PI / (RAND_MAX + 1.0);        double r = sqrt(Area / M_PI);        double theta = 2.0 * M_PI * rand() / (RAND_MAX + 1.0);        vector&lt;double&gt; ans;        ans.push_back(X + r * cos(theta));        ans.push_back(Y + r * sin(theta));        return ans;    &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&lt;double&gt; param_1 = obj-&gt;randPoint(); */\n","categories":["Leetcode題解"],"tags":["題解","Leetcode"]},{"title":"Geometry in Leetcode & CSES","url":"/geo3/","content":"CSES Geometry\nPoint Location Test\nLine Segment Intersection\nPolygon Area\nPoint in Polygon\nPolygon Lattice Points\nMinimum Euclidean Distance\nConvex Hull\n\n\nPoint Location TestCODE\n給你三個點 $P_1,P_2,P_3$ ，判斷出向量 $(P_1,P_2)$ 之於 $P_3$ 的方向為何？關係共有相交、位於左側以及位於右側。\nLine Segment IntersectionCODE\n給你兩條線段，判斷他們是否相交。線段相交裸題。\nPolygon AreaCODE\n給你N個點，計算出此多邊形圍成的面積為何。帶入行列式公式可解。\nPoint in PolygonCODE\n給你N個點構成的一個簡單多邊形，判斷一個點是否在多邊形內部。\n參考資料：greekforgreek\n\n凸多邊形的情況，我們可以利用內角和是360度轉一圈的的方法，判斷一點是否在多邊形內部。但本題是簡單多邊形，因此用這種方法是不可行的。\n\n這張圖是作法，我們做出一個由x點出發向x軸正向的射線，計算這一條射線跟多邊形共有幾個交點。如果是奇數，表示在內部；反之則是在外部。交在多邊形上的點要特別注意，因為他可能會被統計到兩次，因此我們特別處理當點相交一點時，只計算那條邊的兩端點中，y座標比較大的那一點是否相交的情況。\n最後，我們發現遇上如圖中g點的狀況直接就被處理好了！他會被算到零次，因為在看兩條邊加上去之後，又因為頂點是y座標比較大的，會被剪掉兩次。\nPolygon Lattice PointsCODE\n給定頂點座標均是整點（或正方形格子點）的簡單多邊形，皮克定理說明了其面積 $A$ 和內部格點數目 $i$、邊上格點數目 $b$ 的關係：\nA = i + \\frac{b}{2} - 1PROOF\nMinimum Euclidean DistanceCODE\n最近點對問題。不過，既然是計算幾何，我們就用掃描線做最近點對。掃描線有兩個做法（可以參考那個連結），至於搭配set輔助步驟就是：\n\n將點輸入並且排序，X座標為主，Y座標為輔。\n使用set，並以Y座標為排序基準（pair的首項），以儲存第 $i$ 點的左方、水平距離小於等於d的點。\n右掃描線依序窮舉各點作為右端點。　(1) Erase與右端點水平距離大於d的點們（左掃描線右移）　(2) 用二分搜找出與第 $i$ 點垂直距離小於d的點，並嘗試更新　(3) 將第 $i$ 點加入set中。\n\n\nConvex HullCODE\n凸包裸題。\nLeetcode：GeographyLeetcode 總共有27題的tag是計算幾何的，題單在這裡。有三題被鎖起來不能看，所以總共有24題。\n149 Max Points on a Line題目連結\nclass Solution &#123;public:        int gcd(int a,int b)&#123;        if(a &gt; b)swap(a,b);        if(a == 0)return b;        return gcd(b % a, a);    &#125;        int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            map&lt;pair&lt;int,int&gt;,int&gt; mp;            int same = 0,hori = 0;            for(int j = i+1;j &lt; n;j++)&#123;                int dx = points[i][0] - points[j][0];                int dy = points[i][1] - points[j][1];                if(dx == 0 &amp;&amp; dy == 0)&#123;same++;continue;&#125;                if(dx == 0 &amp;&amp; dy != 0)&#123;hori++;continue;&#125;                int g = gcd(abs(dx),abs(dy));                if(dy &lt; 0 || (dy == 0 &amp;&amp; dx &lt; 0))&#123;dx = -dx;dy = -dy;&#125;                mp[&#123;dx/g,dy/g&#125;]++;            &#125;            int sum = hori + same + 1;            for(auto it : mp)sum = max(sum,it.second + 1);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n223 Rectangle Area題目連結\nclass Solution &#123;public:    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) &#123;        int x = max(min(ax2,bx2) - max(ax1,bx1),0);        int y = max(min(ay2,by2) - max(ay1,by1),0);        int ans = (ax2 - ax1)*(ay2 - ay1)+(bx2 - bx1)*(by2 - by1)-x * y;        return ans;    &#125;&#125;;\n335 Self Crossing題目連結\nclass Solution &#123;public:    bool isSelfCrossing(vector&lt;int&gt;&amp; d) &#123;        int n = d.size();        if(n &lt;= 3)return false;        for(int i = 3;i &lt; n;i++)&#123;            //第四條、第五條、第六條交第一條            if(d[i] &gt;= d[i-2] &amp;&amp; d[i-1] &lt;= d[i-3])return true;            if(i &gt;= 4 &amp;&amp; d[i-1] == d[i-3] &amp;&amp; d[i] + d[i-4] &gt;= d[i-2])return true;            if(i &gt;= 5 &amp;&amp; d[i-2] &gt;= d[i-4] &amp;&amp; d[i] &gt;= d[i-2] - d[i-4]              &amp;&amp; d[i-1] &gt;= d[i-3]-d[i-5] &amp;&amp; d[i-1] &lt;= d[i-3])return true;                    &#125;        return false;    &#125;&#125;;\n587 Erect the Fence題目連結\n#define pii pair&lt;int,int&gt;#define ff first#define ss secondclass Solution &#123;public:        bool check(pii a,pii b,pii o)&#123;        pii aa = &#123;a.ff - o.ff,a.ss - o.ss&#125;;        pii bb = &#123;b.ff - o.ff,b.ss - o.ss&#125;;        int cross = aa.ff * bb.ss - aa.ss * bb.ff;        return cross &gt; 0;    &#125;        vector&lt;vector&lt;int&gt;&gt; outerTrees(vector&lt;vector&lt;int&gt;&gt;&amp; point) &#123;        vector&lt;pii&gt; h;        int n = point.size();        vector&lt;pii&gt; p(n);        for(int i = 0;i &lt; n;i++)p[i] = &#123;point[i][0],point[i][1]&#125;;        sort(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; 1 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        int down = h.size();        h.pop_back();        reverse(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; down &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        set&lt;pii&gt; s;for(auto i : h)s.insert(i);        n = s.size();        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n);        for(int i=0;i&lt;n;i++)ans[i].resize(2);        int id = 0;        for(auto i : s)&#123;ans[id][0] = i.ff;ans[id][1] = i.ss;id++;&#125;        return ans;    &#125;&#125;;\n593 Valid Square題目連結\nclass Solution &#123;public:        int dis(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2)&#123;        int x = p1[0] - p2[0],y = p1[1] - p2[1];        return x * x + y * y;    &#125;        bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) &#123;        map&lt;int,int&gt;mp;     //長度、個數        mp[dis(p1,p2)]++;        mp[dis(p1,p3)]++;        mp[dis(p1,p4)]++;        mp[dis(p2,p3)]++;        mp[dis(p2,p4)]++;        mp[dis(p3,p4)]++;        return mp.size() == 2 &amp;&amp; mp.begin()-&gt;second == 4;    &#125;&#125;;\n812    Largest Triangle Area題目連結class Solution &#123;public:        int cross(int x1,int y1,int x2,int y2)&#123;        return x1 * y2 - x2 * y1;    &#125;        double area(int a,int b,int c,int d,int e,int f)&#123;        double sum = 0;        sum += cross(a,b,c,d);        sum += cross(c,d,e,f);        sum += cross(e,f,a,b);        return abs(sum / 2.0);    &#125;        double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size();        double ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i + 1;j &lt; n;j++)&#123;                for(int p = j + 1;p &lt; n;p++)&#123;                    ans = max(ans,area(points[i][0],points[i][1]                                      ,points[j][0],points[j][1]                                      ,points[p][0],points[p][1]));                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n836 Rectangle Overlap題目連結\nclass Solution &#123;public:    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;        //最小的右端點 - 最大的左端點        int x = min(rec1[2],rec2[2]) - max(rec1[0],rec2[0]);        //最小的上端點 - 最大的下端點        int y = min(rec1[3],rec2[3]) - max(rec1[1],rec2[1]);        return x &gt; 0 &amp;&amp; y &gt; 0;    &#125;&#125;;\n858 Mirror Reflection題目連結\nclass Solution &#123;public:    int gcd(int a,int b)&#123;        if(a == 0)return b;        return gcd(b % a,a);    &#125;        int mirrorReflection(int p, int q) &#123;        int len = p * q / gcd(q,p);        int a = (len / p) % 2,b = (len / q) % 2;        if(a == 0 &amp;&amp; b == 1)return 0;        else if(a == 1 &amp;&amp; b == 1)return 1;        else return 2;            &#125;&#125;;\n478 Generate Random Point in a Circle題目連結\n直接Random半徑會出事（可能不夠亂，或是半徑太小），如果random面積之後算半徑才OK。\nclass Solution &#123;public:    double R,X,Y;    Solution(double radius, double x_center, double y_center) &#123;        R = radius;X = x_center;Y = y_center;        srand(time(NULL));    &#125;        vector&lt;double&gt; randPoint() &#123;        double Area = rand() * R * R * M_PI / (RAND_MAX + 1.0);        double r = sqrt(Area / M_PI);        double theta = 2.0 * M_PI * rand() / (RAND_MAX + 1.0);        vector&lt;double&gt; ans;        ans.push_back(X + r * cos(theta));        ans.push_back(Y + r * sin(theta));        return ans;    &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&lt;double&gt; param_1 = obj-&gt;randPoint(); */\n883 Projection Area of 3D Shapes題目連結\n三種不同的投影對應到三種不同的角度看圖形。x-y的面積即為由上而下看有方格的個數。x-z是從前方看，因此對應到的是每一行的最大方塊個數。\nclass Solution &#123;public:    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int n = grid.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            int maxR = 0,maxC = 0;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans++;        //由上往下看                maxR = max(maxR,grid[i][j]);    //由側邊看                maxC = max(maxC,grid[j][i]);    //由前面看            &#125;            ans += maxR + maxC;        &#125;        return ans;    &#125;&#125;;\n892 Surface Area of 3D Shapes題目連結\nclass Solution &#123;public:    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans = 0,n = grid.size();        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans += 4 * grid[i][j] + 2;                if(i &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i+1][j])*2;                &#125;                if(j &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i][j+1])*2;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n939 Minimum Area Rectangle題目連結class Solution &#123;public:    int minAreaRect(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        vector&lt;vector&lt;int&gt;&gt;p = points;        int n = points.size();        set&lt;pair&lt;int,int&gt;&gt;s;        for(int i=0;i&lt;n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        int ans = INT_MAX;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(s.find(&#123;p[i][0],p[j][1]&#125;)!=s.end()                    &amp;&amp; s.find(&#123;p[j][0],p[i][1]&#125;)!=s.end())&#123;                    if(p[i][0] == p[j][0] || p[i][1] == p[j][1])continue;                    ans = min(ans,abs(p[i][0]-p[j][0])*abs(p[i][1]-p[j][1]));                &#125;            &#125;        &#125;        if(ans == INT_MAX)return 0;        else return ans;    &#125;&#125;;\n963 Minimum Area Rectangle II題目連結\nclass Solution &#123;public:    double minAreaFreeRect(vector&lt;vector&lt;int&gt;&gt;&amp; p)&#123;        set&lt;pair&lt;int,int&gt;&gt; s;        int n = p.size();        for(int i = 0;i &lt; n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        double ans = 1e9;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                int x1 = p[j][0] - p[i][0];                int y1 = p[j][1] - p[i][1];                for(int k = j+1;k &lt; n;k++)&#123;                    int x2 = p[k][0] - p[i][0];                    int y2 = p[k][1] - p[i][1];                    if(x1 * x2 + y1 * y2 != 0)continue;                    int nx = p[k][0] + x1,ny = p[k][1] + y1;                    if(s.find(&#123;nx,ny&#125;) != s.end())&#123;                        ans = min(ans,sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2));                    &#125;                &#125;            &#125;        &#125;        if(ans == 1e9)return 0;        return ans;    &#125;&#125;;\n973 K Closest Points to Origin題目連結\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;        int n = points.size();        multimap&lt;int,int&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            int x = points[i][0];            int y = points[i][1];            mp.insert(&#123;x * x + y * y,i&#125;);        &#125;        auto it = mp.begin();        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;k;i++)&#123;            int id = it-&gt;second;            ans.push_back(points[id]);            it++;        &#125;        return ans;    &#125;&#125;;\n1030 Matrix Cells in Distance Order題目連結\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) &#123;        int n = rows,m = cols;        multimap&lt;int,pair&lt;int,int&gt;&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; m;j++)&#123;                int dis = abs(i - rCenter) + abs(j - cCenter);                mp.insert(&#123;dis,&#123;i,j&#125;&#125;);            &#125;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n*m);        for(int i=0;i&lt;n*m;i++)ans[i].resize(2,0);        int id = 0;        for(auto it : mp)&#123;            ans[id][0] = (it.second.first);            ans[id][1] = (it.second.second);            id++;        &#125;        return ans;    &#125;&#125;;\n1037 Valid Boomerang題目連結\nclass Solution &#123;public:    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int x1 = points[1][0]-points[0][0],y1 = points[1][1]-points[0][1];        int x2 = points[2][0]-points[1][0],y2 = points[2][1]-points[1][1];        int cross = x1 * y2 - x2 * y1;        if(cross == 0)return false;        return true;    &#125;&#125;;\n1232 Check If It Is a Straight Line題目連結\nclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        vector&lt;vector&lt;int&gt;&gt; p = coordinates;        int n = p.size();        for(int i = 0;i &lt; n-2;i++)&#123;            int x1 = p[i+1][0] - p[i][0],y1 = p[i+1][1] - p[i][1];            int x2 = p[i+2][0] - p[i+1][0],y2 = p[i+2][1] - p[i+1][1];            if(x1 * y2 != x2 * y1)return false;        &#125;        return true;    &#125;&#125;;\n1266 Minimum Time Visiting All Points題目連結\nclass Solution &#123;public:    int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        vector&lt;vector&lt;int&gt;&gt; p = points;        for(int i = 0;i &lt; n-1;i++)&#123;            ans += max(abs(p[i+1][0] - p[i][0]),abs(p[i+1][1] - p[i][1]));        &#125;        return ans;    &#125;&#125;;\n1401 Circle and Rectangle Overlapping題目連結\nclass Solution &#123;public:    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) &#123;        int x = clamp(x_center,x1,x2) - x_center;        int y = clamp(y_center,y1,y2) - y_center;        return x*x + y*y &lt;= radius * radius;    &#125;&#125;;\n1453 Maximum Number of Darts Inside of a Circular Dartboard題目連結\n#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y second#define exp 1e-6class Solution &#123;public:        double dis(pdd a,pdd b)&#123;        ld x = a.x - b.x,y = a.y - b.y;        return sqrt(x * x + y * y);    &#125;        pair&lt;pdd,pdd&gt; get_center(pdd a,pdd b,ld R)&#123;        pdd mid = &#123;(a.x + b.x) / 2,(a.y + b.y) / 2&#125;;        ld theta = atan2(a.y - b.y, b.x - a.x);        ld tmp = dis(a,b) / 2, d = sqrt(R * R - tmp * tmp);                pair&lt;pdd,pdd&gt; ans;        ans.x = &#123;mid.x - d * sin(theta),mid.y - d * cos(theta)&#125;;        ans.y = &#123;mid.x + d * sin(theta),mid.y + d * cos(theta)&#125;;        return ans;    &#125;        int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; point, int R) &#123;        int n = point.size(),ans = 1;        pdd p[n];for(int i=0;i&lt;n;i++)&#123;p[i] = &#123;point[i][0],point[i][1]&#125;;&#125;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(dis(p[i],p[j]) - 2.0 * R &gt;= exp)continue;                pair&lt;pdd,pdd&gt; cur = get_center(p[i],p[j],R);                int cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.x) - R&lt;= exp)cnt ++;                ans = max(ans, cnt);cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.y) - R &lt;= exp)cnt ++;                ans = max(ans, cnt);            &#125;        &#125;        return ans;    &#125;&#125;;\n1515 Best Position for a Service Centre題目連結\n這一題是模擬退火，非常酷，之前沒有寫過的東西。\n#define eps 1e-6#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 100;        ld dx[4] = &#123;1.0,0.0,-1.0,0.0&#125;,dy[4] = &#123;0.0,1.0,0.0,-1.0&#125;;        bool flag = 0;        while(test_size &gt; eps)&#123;            flag = 0;            for(int i = 0;i &lt; 4;i++)&#123;                pdd newp = cur;                newp.x += dx[i] * test_size;                newp.y += dy[i] * test_size;                ld new_dis = dis_all(newp);                if(new_dis &lt; mid_dis)&#123;                    mid_dis = new_dis;                    cur = newp;                    flag = 1;                    break;                &#125;            &#125;            if(flag == 0)test_size /= 2.0;        &#125;        return mid_dis;    &#125;&#125;;\n換另外一種迭代方式\n#define eps 1e-8#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        srand(time(NULL));        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 150.0;        while(test_size &gt; eps)&#123;            pdd newp = cur;            int temp = rand();            newp.x += cos(temp) * test_size;            newp.y += sin(temp) * test_size;            ld new_dis = dis_all(newp);            if(new_dis &lt; mid_dis)&#123;                mid_dis = new_dis;                cur = newp;            &#125;            else test_size *= 0.99;        &#125;        return mid_dis;    &#125;&#125;;\n1610 Maximum Number of Visible Points題目連結\n#define ld long doubleconst int N = 1e5+5;class Solution &#123;public:    int visiblePoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int angle, vector&lt;int&gt;&amp; loc) &#123;        vector&lt;ld&gt; ang;        int overlap = 0,n = points.size(),ans = 0;        for(auto p : points)&#123;            if(p[0] == loc[0] &amp;&amp; p[1] == loc[1])overlap++;            else ang.push_back(atan2l(p[1]-loc[1],p[0]-loc[0]) * 180 / (ld)M_PI);        &#125;        int sz = ang.size();        for(int i = 0;i &lt; sz;i++)ang.push_back(ang[i] + 360);        sort(ang.begin(),ang.end());        sz = ang.size();        for(int i = 0,it2 = 0;i &lt; sz;i++)&#123;            while(it2 &lt; sz &amp;&amp; ang[it2] - ang[i] &lt;= angle)it2++;            ans = max(ans,it2 - i);        &#125;        return ans + overlap;    &#125;&#125;;\n1828 Queries on Number of Points Inside a Circle題目連結\nclass Solution &#123;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int n = queries.size(),m = points.size();        vector&lt;int&gt; ans;ans.resize(n);        for(int i = 0;i &lt; n;i++)&#123;            int rx = queries[i][0],ry = queries[i][1],sum = 0;            for(int j = 0;j &lt; m;j++)&#123;                int x = points[j][0] - rx,y = points[j][1] - ry;                if(x * x + y * y &lt;= queries[i][2] * queries[i][2])sum++;            &#125;            ans[i] = sum;        &#125;        return ans;    &#125;&#125;;\n2101. Detonate the Maximum Bombs題目連結\n把圖形考慮成一張圖，符合條件的就增加一條有向邊，接著對每一個點做一次DFS即可。時間 $O(n^2)$。\n#define pii pair&lt;int,int&gt;#define ld long doubleclass Solution &#123;public:        vector&lt;int&gt; E[105];    ld dis(pii a,pii b)&#123;        int x = a.first - b.first,y = a.second - b.second;        return sqrt((long long)x * x + (long long)y * y);    &#125;    int sum = 1;    bool vis[105];    void dfs(int now)&#123;        vis[now] = 1;        for(auto i : E[now])&#123;            if(vis[i])continue;            sum++;vis[i] = 1;            dfs(i);        &#125;    &#125;        int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bomb) &#123;        int n = bomb.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                pii a = &#123;bomb[i][0],bomb[i][1]&#125;,b = &#123;bomb[j][0],bomb[j][1]&#125;;                int r1 = bomb[i][2],r2 = bomb[j][2];                ld d = dis(a,b);                if(r1 &gt;= d)E[i].push_back(j);                if(r2 &gt;= d)E[j].push_back(i);            &#125;        &#125;        for(int i = 0;i &lt; n;i++)&#123;            fill(vis,vis+105,0);            sum = 1;            dfs(i);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n延伸問題\n給定平面上N個點，問一條直線最多能穿越幾個點\n線段相交座標\n給你一個線段及一個圓，判斷圓跟線段的最短距離\n給你一個三角形（其中一頂點為圓心）和圓形，求出兩者的交集面積\n兩圓交點\n圓跟多邊形交集面積\n最小包覆圓\n半平面交\nBentley–Ottmann Algorithm\nVoronoi Diagram\nDelaunay Triangulation\n\n","categories":["C++進階主題","計算幾何"],"tags":["計算幾何"]},{"title":"萬有引力與四星運動之探討","url":"/gravity1/","content":"此文將從萬有引力定律開始，在只考慮萬有引力的狀況下，探討衛星運動、雙星運動、三星運動、四星系統甚至是N體問題的軌跡與運動模式並進行模擬，並進行理論的驗證。\n模擬連結：點這裡\n理論與數學萬有引力定律牛頓於1687年提出：「任何兩個質點之間必有一吸引力F，其量值和兩質量的乘積成正比，和它們之間的距離平方成反比，其方向在連心線上。」\n\nF = \\frac{GMm}{r^2}\n圓周運動公式高中選修物理提到，一個質量為$m$的物體以半徑$R$繞著圓心旋轉，角速度為$\\omega$，其速度$v$、加速度$a$與週期$T$有以下公式，在分析衛星運動及多體運動中會常常用到。在行星運動當中，就是以彼此間的萬有引力當作向心力，進行圓周運動。\n\n\\begin{align}\\omega &= \\frac{\\Delta\\theta}{\\Delta t} = \\frac{2\\pi}{T}\n\\\\v &= R\\omega = \\frac{2\\pi R}{T}\n\\\\a &= R\\omega^2 =\\frac{v^2}{R} =\\frac{4\\pi^2 R}{T^2}\\end{align}橢圓性質一個橢圓具有兩個焦點分別是下圖的$F_1,F_2$，其定義就是橢圓上任一點$P$到兩焦點的距離和固定，也就是$\\overline{PF_1}+\\overline{PF_1} = K$，$K$為定值。下圖中，$a$為半長軸，$b$為半短軸，滿足 $a^2 = b^2+c^2$，面積為 $\\pi ab$。我們定義了一個決定橢圓扁平程度偏心率 $e = \\frac{c}{a}&lt;1$，偏心率愈大，橢圓愈扁平。\n\n也可以說，圓就是一個橢圓的特例，當$F_1,F_2$重合在一點的時候就變成了一個正圓。同時，橢圓軌跡能用以下方程式說明（可用距離公式證明）：\n\\frac{x^2}{a^2}+\\frac{y^2}{b^2} = 1平方相加容易聯想到三角函數的平方關係，因此我們可以假設 $x = a\\cos\\theta,y = b\\sin\\theta$，如此一來平方相加可得證。由此可知，對於一個中心點為$(h,k)$的橢圓而言，其參數式為：\n\\left\\{\\begin{aligned} x &= h+a\\cos\\theta\n\\\\y &= k+b\\cos\\theta\\end{aligned}\\right.-\\pi≤\\theta≤\\pi克普勒三大行星運動定律克普勒提出了行星三大運動定律，分別為：\n\n軌道定律：所有行星各以太陽為焦點的橢圓形軌道上運動。\n面積定律：太陽與行星的連線在相同時間間隔內掃過相等的面積。\n週期定律：各行星繞行同一恆星，其公轉週期的平方與行星到太陽平均距離的三次方成正比。\n\n下面主要會用到的是第一和第二定律，以及公式 $r_Av_A = r_Bv_B$進行證明。\n\n力學能守恆定律一個質量為$m$的物體以速度$v$前進，與地心相距$r$，則該物體的動能與該處的重力位能為：\n\\begin{align}E_k &= \\frac{1}{2}mv^2\\\\U &= -\\frac{GMm}{r}\\end{align}在系統只有保守力做功下，其力學能保持不變。在分析以半徑$r$的等速率圓周運動的過程中，其力學能可以表示為：\nE = U+E_k = \\frac{-GMm}{r}+\\frac{1}{2}m\\frac{GM}{r} = \\frac{-GMm}{2r}由此我們可以得到：\nE_k = \\frac{-1}{2}U行星與人造衛星運動理論與數學衛星質量$m$以軌道半徑$r$繞質量為$M$的行星行等速率圓周運動，其萬有引力恆指向$M$球心，作為圓周運動所需要的向心力。\nF = \\frac{GMm}{r^2} = ma_c = m\\frac{v^2}{r}由此可知，當有一個物體質量$m$在距離行星$r$處行等速率圓周運動，其速度大小$v = \\sqrt{\\frac{GM}{r}}$，速度方向與向心力方向垂直。在模擬過程中，有兩個很重要的要素，分別是初始的速度大小、以及速度的方向，有了這兩個東西以後，就能讓電腦以彼此之間的萬有引力進行模擬。\n橢圓軌道與運動軌跡方程式在實作的過程中，我發現到當速度 $v$ 比$\\sqrt{\\frac{GM}{r}}$大一點或小一點時，跑出來的軌跡就不會是正圓而是橢圓，讓我十分好奇能否在給定一個速度的情況下，計算出橢圓軌跡方程式。\n下圖是初始狀態的設定，白球質量$M$、位置為原點、紅球質量$m$，紅球距離白球$H$、初始速度$v=k\\sqrt{\\frac{GM}{H}}$垂直向上，透過調整$k$的大小，預測其運動軌跡。顯然，當$k = 1$時軌跡會是正圓形，$k1$則是分別以H為近日點、遠日點半徑的橢圓。\n\n若近日點距為$r_1$、遠日點距為$r_2$，半軸長$a = \\frac{r_1+r_2}{2}$，根據遠日點以及近日點的力學能守恆以及克卜勒第二定律，可以列出以下兩式：\n\\begin{aligned}\\frac{1}{2}mv_1^2 - \\frac{GMm}{r_1} &= \\frac{1}{2}mv_2^2 - \\frac{GMm}{r_2}\\\\\\\\\n\\frac{\\pi ab}{T} = \\frac{1}{2}r_1v_1 &= \\frac{1}{2}r_2v_2\\end{aligned}將二式帶入一式可得：\n(r_1v_1)^2 = \\frac{GMr_1r_2}{\\frac{1}{2}(r_1+r_2)} =\n\\frac{GM(a+c)(a-c)}{a} = \\frac{GMb^2}{a}帶入我們的初始速度與近、遠日點距：\n(H\\cdot k\\sqrt{\\frac{GM}{H}})^2 = k^2GMH=\\frac{GMb^2}{a}上面是第一式，還有兩條比較顯而易見的兩條方程式，總共用三條方程式解三個未知數：\n\\left\\{\\begin{aligned} \\frac{b^2}{a} &= k^2H\n\\\\a^2 &= b^2+c^2\n\\\\a &= H-c\\end{aligned}\\right.將三式帶入二式消去$c$，得到：\n\\left\\{\\begin{aligned} a &= \\frac{H}{2-k^2}\n\\\\b &= \\sqrt{aHk^2}\\end{aligned}\\right.有了$a,b$之後，就可以回推週期：\n\\begin{aligned}\\frac{\\pi ab}{T} &= \\frac{1}{2}r_1v_1\n\\\\\\\\\\Longrightarrow \\ T &= \\frac{2\\pi ab}{r_1v_1}\\end{aligned}最後，就可以用橢圓參數式畫出軌跡，並且完全吻合紅球的運動軌跡！\n程式實作程式連結：點這裡\n分別將$k$帶入不同數值，觀察軌跡的變化。左邊為模擬的狀況，右邊則是紅球動能（黑線）、位能（綠線）以及力學能（紅線）大小，由於只有保守力做功，其力學能總和保持不變。初始狀態如下：$M = 10,m = 1,H = 5$。\nK = 0.6代入\n\\left\\{\\begin{aligned}\na &= 3.0488\n\\\\b &= 2.3426\n\\\\c &= 1.9512\\\n\\\\T &= 4.0955\\end{aligned}\\right.K = 1代入\n\\left\\{\\begin{aligned}\na &= 5.0000\n\\\\b &= 5.0000\n\\\\c &= 0.0000\n\\\\T &= 8.6015\\end{aligned}\\right.K = 1.3代入\n\\left\\{\\begin{aligned}\na &= 16.1290\n\\\\b &= 11.6743\n\\\\c &= 11.1290\n\\\\T &= 49.8344\\end{aligned}\\right.K = 2代入\n\\left\\{\\begin{aligned}\na &= -2.5000\n\\\\b &= nan\n\\\\c &= nan\n\\\\T &= nan\\end{aligned}\\right.這種情況是紅球脫離了黑球的重力束縛，一去不復返。可以看到，動能與位能呈現對稱縮小的狀況，動能逐漸趨近於總力學能，而重力位能逐漸趨近於零。\n這裡發生了一個有趣的現象，當我把$k$繼續調小到足夠小，紅球會繞行一個非常扁平的橢圓軌跡，在現實世界中也就是紅球撞上白球的感覺。\n反之，當我把$k$繼續往上調大時，會發現紅球脫離了白球的重力場而一去不復返，我試著找出這個臨界值，從我們上面的推導可知$a = H/(2-k^2),b = \\sqrt{aHk^2}$，當$k&gt;\\sqrt{2}$時，$b$無解，也就代表這樣的橢圓形軌跡是不存在的。換句話說，當$v&gt;\\sqrt 2\\cdot\\sqrt{\\frac{GM}{H}}$時，紅球會擺脫白球重力的影響，也就是第二宇宙速度或脫離速度。\n由此可知，$|k|&lt;\\sqrt 2$。\n\n            第二宇宙速度或脫離速度是指在地球上發射的物體擺脫地球重力束縛，飛離地球所需的最小初始速度。假設質量$m$的物體速度為$v$，則如果要擺脫地球重力的束縛，其動能要大於其重力位能，取最小值就是兩者相等，因此：\\frac{1}{2}mv^2 =\\frac{GMm}{r}得到脫離速度：v = \\sqrt{\\frac{2GM}{r}}\n          \n很巧的是，我們可以從橢圓半短軸長的無解推出脫離速度，也能從力學能的方向角度切入，得到一樣的結果，可謂殊途同歸！\n雙星運動觀察兩個質量分別為$m1,m2$的物體，繞著彼此的質心進行週期運動。\n\n理論與數學令兩物體彼此間距離為$d$，則有以下的數學關係式：\n\n\n\n\n\nm_1\nm_2\n\n\n\n\n軌道半徑\nr_1 = \\frac{m_2}{m_1+m_2}\\cdot d\nr_2 = \\frac{m_1}{m_1+m_2}\\cdot d\n\n\n向心加速度\na_1 = \\frac{Gm_2}{d^2}\na_2 = \\frac{Gm_1}{d^2}\n\n\n軌道速率\nv_1 = m_2\\sqrt{\\frac{G}{d(m_1+m_2)}}\nv_2 = m_1\\sqrt{\\frac{G}{d(m_1+m_2)}}\n\n\n\n\n模擬實作模擬連結：點這裡\n正圓雙星運動正圓形的軌道中，軌道半徑與其質量呈反比。\n\n\\left\\{\\begin{aligned}\nm1 &= 3.0000\\\\\nm2 &= 1.0000\\\\\nv1 &= 0.7455\\\\\nv2 &= 2.2366\\\\\\end{aligned}\\right.橢圓雙星運動（質量不同）橢圓形的軌道中，軌道半徑也會與其質量呈反比（此軌道半徑可以定義為半軸長，由微積分可得證）。\n\n\\left\\{\\begin{aligned}\nm1 &= 3.0000\\\\\nm2 &= 1.0000\\\\\nv1 &= 0.3728\\\\\nv2 &= 1.1183\\\\\\end{aligned}\\right.橢圓雙星運動（質量相同）\n\\left\\{\\begin{aligned}\nm1 &= 1.0000\\\\\nm2 &= 1.0000\\\\\nv1 &= 0.5272\\\\\nv2 &= 0.5272\\\\\\end{aligned}\\right.三星運動再研究天體力學上，雙星問題（Two-Body Problem）是已經被證明有精確解，但對於三體問題（Three-body problem）甚至是多體問題（N-body problem）問題就變得特別複雜，除特別案例以外，並沒有辦法能精確描述各物體運動的行為。儘管如此，此系統還是會遵守動量守恆，其質心不會移動。\n三星問題困難的地方在於，往往初始非常微小的誤差，就有可能造成之後完全不同的結果，變得混亂而不可預測，也就是混沌狀態。\n理論與數學由於三體問題過於複雜，我們簡化成將三個物體的質量都設為$m$，放在邊長為$L$的正三角形三個頂點上，與質心距離$r = \\frac{\\sqrt3}{3}L$，則彼此間的萬有引力取餘弦將作為繞質心旋轉所需要的向心力：\n\\sqrt 3\\frac{Gm^2}{L^2} = ma_c = m\\frac{v^2}{r} = m\\frac{4\\pi^2r}{T}可得到以下：\n\\left\\{\\begin{aligned}\nv &= \\sqrt{\\frac{Gm}{L}}\\\\\nT &= 2\\pi\\sqrt{\\frac{L^3}{G(3m)}}\n\\end{aligned}\\right.正圓軌跡三星運動模擬模擬連結：點這裡\n正三角形的三個頂點以相對位置固定、共同質心為旋轉中心進行旋轉。透過彼此的萬有引力餘弦結果當作向心力，設定好初始速度大小與方向（分別在90度、210度、300度），就能讓電腦完成剩下的工作！\n\n橢圓軌跡三星運動模擬模擬連結：點這裡影片連結：點這裡\n此為不穩定的模擬，也就是說在一段時間過後，整個系統會失序，呈現混亂的狀態。\n\n其他軌跡的三星運動其他三體互繞的軌跡如八字型，就被證明出來是一個穩定的運動模式。\n\n以及衛星的五個拉格朗日點，可以在下圖五個位置放入第三個不考慮其質量的物體，使其與其他星體的相對位置不變。\n\n四星運動在一堂物理課，老師教到三星系統時，順便提及了四星運動應該以什麼樣的性狀、什麼方式運動。若要保持四個物體等距，唯一的方式就是把他們放在正四面體上的四個頂點上，以正四面體之外心為旋轉中心進行旋轉\n理論與數學假設四個質量均為$m$的物體，分別落在正四面體的四個頂點上，若以正六面體思考正四面體，正四個頂點分別是$(0,0,0),(1,1,0),(1,0,1),(0,1,1)$\n\n如下圖，假設$A,B,C,D$上均有一個質量為$m$的物體，我們針對$B$分析其受力狀況（其他點其實是一樣的）。可以看到，$B$受到了分別指向$A,B,D$三點、大小為$\\frac{Gm^2}{L^2}$的力，將這些力在指向質心$M$方向做分力。\n\n\n水平方向（ABC平面）：\n\n2\\times\\frac{Gm^2}{L^2}\\cdot\\cos30^{\\circ}+\\frac{Gm^2}{L^2}\\cdot\\cos\\theta\n垂直方向：\n\n\\frac{Gm^2}{L^2}\\cdot\\sin\\theta分析正四邊形的長度性質，由於四面體高度是$h = \\frac{\\sqrt6}{3}$、正三角形外接圓$\\frac{\\sqrt3}{3}$，我們可以得到$\\sin\\theta = \\frac{\\sqrt3}{3},\\cos\\theta = \\frac{\\sqrt 6}{3}$，代入上式可得並做畢氏定理可得：\n\\begin{align}F_B &= \\frac{Gm^2}{L^2}\\sqrt{(\\sqrt3+\\frac{\\sqrt3}{3})^2 + (\\frac{\\sqrt6}{3})^2}\\\\\n&=\\sqrt6\\cdot\\frac{Gm^2}{L^2}\\end{align}正四面體的外接圓半徑$R = \\frac{\\sqrt6}{4}L$，因此可得：\n\\frac{mv^2}{R} = \\sqrt6\\cdot\\frac{Gm^2}{L^2}最後得到軌道速度與旋轉週期：\n\\begin{align}v &= \\sqrt{\\frac{3Gm}{2L}}\\\\\nT &= 2\\pi\\sqrt{\\frac{L^3}{G\\cdot(4m)}}\n\\end{align}程式實作模擬連結：點這裡影片連結：點這裡\n有了速度大小以後，接下來就是初始速度方向的設定。這一部分特別困難，以正四面體的四星在立體空間的運動，旋轉的角度若沒有抓好，很有可能整個結構會崩塌。例如下圖情況，前後兩個物體會因為萬有引力作用而不斷吸引：\n\n嘗試解決的方法是，將正四面體的四個頂點座標投影到$xy$平面，因為四個頂點是$z$座標極大或極小，如此一來就能讓所有速度方向的$z$分量為零。接著，只要將速度方向依照下圖分解即可：\n\n可以看到下圖左方有兩張圖，上圖是四顆球的總動能、位能與力學能的圖、下圖是黃球與其他球的距離（黑線是與質心距離）。在理想的狀況下，我們預期所有球的相對位置應該保持不變，但在模擬中卻是呈現週期性的變化，並且可以觀察球與質心的距離並不是固定的，而是有上下起伏的變化。\n\n轉了差不多十圈後，會發現四星系統呈現混沌狀態，分析原因可能有以下兩個：\n\n精度問題：初始狀態速度方向向量精度不足，初始的些許差別導致後續的混亂。\n模擬本身限制：我們採用的是對時間微分進行每一個瞬間的力學分析，時間間隔大小也會影響到整個模擬的結果。\n\n\n這也讓我們思考一個蠻有趣問題，是否真的存在一個穩定的四星系統彼此能在相對位置固定的狀況下進行運動？\nN體問題運動模擬模擬連結：點這裡\n最後就是N體問題的模擬，將50個質量為$m$的物體在隨機生成的位置上，彼此受到萬有引力運動。右圖的黑線為50個物體的總動能、綠線為彼此的位能，紅線為兩者相加，也就是總力學能。在沒有外力作用的狀況下，能由右圖看出來力學能是守恆的！\n\n總結與延伸問題從萬有引力的理論與數學出發，整理行星的運動軌跡、雙星、三星、四星甚至到N星的運動模式以及模擬，讓我們能從不一樣的角度切入物理問題。這邊還有一個十分有趣的問題尚未解決，也就是是否存在一個穩定的四星系統？在大部分的N體問體的情況中，都沒有辦法得到一個穩定的運動模式，總會因為起始狀態的小小誤差導致截然不同的結果，穩定的四星系統也就變成蠻難解決的問題。\n參考資料\nWiki:Two-body problem\nWiki:Three-body problem\nWiki:N-body problem\n科學online：力學能(Mechanical energy)\n\n物理講義：第八、九章\n\n","categories":["數學筆記"],"tags":["數學","物理筆記"]},{"title":"橢圓軌道上行星到太陽平均距離","url":"/gravity2/","content":"簡介克卜勒第三運動定律說明公轉週期的平方與行星到太陽的平均距離三次方成正比。若是行星以橢圓軌道繞行太陽，則行星到太陽的平均距離 $\\overline d$ 會是近日點距 $r_1$ 加上遠日點距 $r_2$ 的平均，也就是橢圓的半長軸，讓我十分好奇該如何證明這件事！\n\\overline d = \\frac{r_1+r_2}{2} = a所要做的是就是將橢圓圓周上的每一點，到太陽的距離進行積分後取平均。\n\n\n數學證明定義連續函數$f(x)$在$[a,b]$區間上的平均值為：\nf_{ave} = \\frac{1}{b-a}\\int_{a}^{b} f(x) dx在一個以原點為中心的橢圓周上有一點$P$，其參數式可以表示成$P(a\\cos\\theta,b\\sin\\theta)$，其中 $a,b$ 為半長軸、半短軸。令太陽的座標為橢圓的其中一個焦點$S(-c,0)$，如下圖：\n\n則橢圓周上每一點$P$到太陽$S$的距離可以表示為：\nf(x) = \\overline{PS} = \\sqrt{(a\\cos(x)+c)^2+(b\\sin( x))^2}如此一來就可以對$f(\\theta)$在$[0,2\\pi]$區間內取平均值：\n\\begin{align}f_{ave} &= \\frac{1}{2\\pi}\\int_0^{2\\pi} f(x)dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{\\sqrt{(a\\cos(x)+c)^2+(b\\sin(x))^2}}\\ dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{\\sqrt{a^2\\cos^2(x)+2ac\\cdot\\cos(x)+(a^2-c^2)\\cdot\\sin^2(x)+c^2}\\ }dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{\\sqrt{c^2\\cos^2(x)+2ac\\cos(x)+a^2}}\\ dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{(c\\cdot\\cos(x)+a)}\\ dx\\\\\n&=\\frac{1}{2\\pi}[c\\int_0^{2\\pi}{\\cos(x)}\\ dx+\\int_0^{2\\pi}a\\ dx]\\\\\n&=\\frac{1}{2\\pi}\\cdot(0 + 2\\pi a)\\\\\n&=a\n\\end{align}得證橢圓軌道上地球到太陽的平均距離為半軸長！\n程式實作這次主要是以程式實作積分，透過將角度切成很小塊再疊加起來取平均，得到函數的平均值。以下影片中的橢圓$a = 13,b = 5,c = 12$，透過將角度切成30度、15度、1度、0.5度觀察疊加的狀況。\n角度 = 30度\n\n角度 = 15度\n\n角度 = 1度\n\n角度 = 0.5度\n\n這四個影片加起來的平均值都是半長軸$a$！\n","categories":["數學筆記"],"tags":["數學","物理筆記"]},{"title":"Manim學習筆記","url":"/manim/","content":"Manim安裝\nManim is an animation engine for explanatory math videos.\n\n利用Manim可以生成許多數學類的動畫影片、以及製作一些動畫模擬！\n我是利用Mac安裝Manim，只要按照這一篇的說明一步步完成即可，不要上網找教學影片，因為很多都是過時的，在安裝上會出現一些問題。\n至於使用教學的部分，可以參考這一篇官方使用手冊。Manim總共有三種版本，建議使用Manim Community比較方便，資源比較多！\n\n語法筆記架構程式碼from manim import *class Test(Scene):    def construct(self):        #程式碼區塊\n終端指令\nmp4:    manim test.py Test -pqm\ngif: manim test.py Test -pqm -i\n\n影片品質設定：-pql,-pqm,-pqh\nUpdatesfrom manim import *class Test(Scene):    def construct(self):        rec = Rectangle(color = WHITE,width = 2,height = 2.5).to_edge(UL)        circ = Circle().to_edge(DOWN)        arr = always_redraw(            lambda: Line(                start = rec.get_bottom(),end = circ.get_top(),buff = 0.5            ).add_tip()        )        self.play(Create(VGroup(rec,circ,arr)))        self.wait()        self.play(rec.animate.to_edge(UR),circ.animate.scale(0.5),run_time = 3)\nValue Trackerfrom manim import *class Updaters(Scene):    def construct(self):                k = ValueTracker(0)        num = always_redraw(            lambda: DecimalNumber().set_value(k.get_value())        )        self.play(FadeIn(num))        self.play(k.animate.set_value(10),run_time = 5,rate_func = smooth)        self.wait()\nNumberPlane注意：get_graph() —&gt; plot()自動排版：alt + shift + f\nfrom manim import *import mathclass Test(Scene):    def construct(self):        plane = (            NumberPlane(x_range=[-20, 20, 5], x_length=8,                        y_range=[-4, 20, 5], y_length=8)            .to_edge(DOWN)            .add_coordinates()        )        l = plane.get_axis_labels(x_label=&#x27;x&#x27;, y_label=&#x27;f(x)&#x27;)        par = plane.plot(lambda x: (0.5*x) ** 2,                         x_range=[-10, 10], color=GREEN)        func_l = MathTex(&quot;f(x) = &#123;x&#125;^2&quot;).next_to(par, RIGHT).set_color(GREEN)        area = plane.get_riemann_rectangles(            graph=par, x_range=[-5, 5], dx=1, stroke_width=0.1, stroke_color=WHITE)        self.play(DrawBorderThenFill(plane), run_time=2)        self.play(Create(VGroup(par, l, func_l)), run_time=2)        self.wait()        self.play(Create(area))        self.wait()\nValueTrackers to Graphing Scenesfrom manim import *class Test(Scene):    def construct(self):        k = ValueTracker(-4)        ax = Axes(x_range=[-4, 4, 1], y_range=[-2, 16, 2],                  x_length=5, y_length=5).to_edge(DOWN).add_coordinates()        func = ax.plot(lambda x: x ** 2, x_range=[-4, 4], color=BLUE)        slope = always_redraw(            lambda: ax.get_secant_slope_group(                graph=func, dx=0.01, x=k.get_value(), secant_line_color=GREEN, secant_line_length=5)        )        pt = always_redraw(            lambda:            Dot().move_to(ax.c2p(k.get_value(), func.underlying_function(k.get_value())))        )        self.add(ax, func, slope, pt)        self.wait()        self.play(k.animate.set_value(4), run_time=10)        self.wait()\nOpen a file1. svg file:\nfrom manim import *H = &quot;/Users/peienwu/Downloads/&quot;class Test(Scene):    def construct(self):        Icon = SVGMobject(f&quot;&#123;H&#125;//test.svg&quot;)        self.play(FadeIn(Icon))        self.wait()\n2. png file:\nfrom manim import *class Test(Scene):    def construct(self):        Icon = ImageMobject(f&quot;/Users/peienwu/Downloads/minion.jpeg&quot;)        self.play(FadeIn(Icon))        self.wait()        self.play(Icon.animate.to_edge(LEFT))\nBar chartfrom pyclbr import Functionfrom manim import *class DifferentRotations(Scene):    def construct(self):        num = [1, 2, 5, 4, 3]        ver = [&quot;v1.0&quot;, &quot;v2.0&quot;, &quot;v3.0&quot;, &quot;v4.0&quot;, &quot;v5.0&quot;]        r = BarChart(            num,            max_value=max(num),            bar_names=ver,        )        self.play(Create(r), run_time=2)        self.wait()\n影片成果\n文章：Bertrand Paradox\n文章：橢圓軌道上行星到太陽平均距離\n影片：Youtube頻道\n\n","categories":["程式模擬"],"tags":["數學","Manim"]},{"title":"婚姻匹配問題（Stable Marriage Problem）","url":"/marriage/","content":"問題描述對於婚姻匹配問題有以下描述：對於一個群體來說，男生女生都要尋找自己最心儀的對象。而一個「穩定」的群體我們把他定義為在婚姻中的每一對男女都沒有比目前的配對方式更好的組合。\n下圖為四男（小寫字母）以及四女（大寫字母）對異性的偏好順序，第一格代表男生對女生的偏好順序，第二格則代表女生對男生的偏好順序。|     |  A  |  B  |  C  |  D  || :—-: |:—-:|:—-:|:—-:|:—-:|| a   | 1,3 | 2,3 | 3,2 | 4,3 || b   | 1,4 | 4,1 | 3,3 | 2,2 || c   | 2,2 | 1,4 | 3,4 | 4,1 || d   | 4,1 | 2,2 | 3,1 | 1,4 |\n我們發現到只有$(a,C),(b,D),(c,A),(d,B)$是唯一一組穩定的配對，對於其他的配對必可找到一對男女喜歡彼此的程度勝過對原本的伴侶。\nGale-Shapley Algorithm（男方求婚法）演算法步驟如下：\n所有男生各自向他們最喜歡的女生求婚;每當（有女生被兩個以上的男生求婚）&#123;    這個女生暫時保留所有求婚者中她最喜歡的一個，而拒絕其他人；     被拒絕的男生退而求其次，向不曾拒絕過他的人當中最喜歡的女生求婚；&#125;\n數學證明小觀察如果是男生不斷向女生求婚，則有以下的觀察：\n\n一個女生一旦訂婚，她對訂婚對象的喜好程度會不斷增加。\n一個男生一旦訂婚，他對訂婚對象的喜好程度會不斷下降。\n\n引理\nGale-Shapley Algorithm 的結果必定是完美配對。\n\n            注意到每一個女生最多只會拒絕$n-1$個男生（必定留下一個），這時候每個女生都一定會被求婚過，否則，因為每一個女生只會暫時接受一個求婚者，一定還有一個未被接受的男生還可以向某一位女生求婚。\n          \n\nGale-Shapley Algorithm 的結果必定是穩定的。\n\n            假設這個匹配裡出現不穩定配對，不失一般性假設是$(a,B)$，其中 $a$ 喜歡 $B$ 勝過於他的配偶 $A$，而 $B$ 喜歡 $a$ 多過他的配偶 $b$。由於 $a$ 比較喜歡 $B$，他必定曾經向 $B$ 求婚過，但最後沒有和 $B$ 配對，表示 $a$ 被拒絕而當時 $B$ 身旁是有一個求婚者是 $B$ 比較喜歡的，因此這個求婚者在 $B$ 的排行中也優先於 $b$ （優先於 $a$ 因而優先於 $b$），根據觀察一，不可能最後 $B$ 跟 $b$ 配對在一起（女生對訂婚對象喜好程度只會不斷增加），矛盾。\n          \n\n\n證明根據引理1,2，我們知道 Gale-Shapley Algorithm 輸出的匹配必定是完美配對且不存在不穩定配對。根據定義，得證。\n複雜度分析證明算法的複雜度為：$O(n^2)$。\n\n總共不會超過 $n^2$ 個求婚要求：每個男生只會對一個女生求婚最多一次，總共有 $n$ 個女生，因此最多有 $n^2$ 個求婚要求。\n對於每一個求婚要求以 $O(1)$ 處理：可以藉由一個二維陣列 $O(1)$ 比較女生對男生的喜好程度，同時維護一個佇列使我們能 $O(1)$ 取得男生要下一個要配對的女生。\n\n得證 Gale-Shapley Algorithm 的複雜度是 $O(n^2)$。\n實作題目連結\n這題是女生求婚法。\n比較難處理的部分是輸入，其他就照著虛擬碼執行算法。在以下程式碼中，我們使用cur_que放入尚未成功配對的女生，每一個女生下一個要配對的男生則儲存在que中，並利用Man記錄男生目前配對到的女生。\n執行完演算法之後，利用反函數找出Man女生配對到的男生並輸出。\n#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int,int&gt;#define ff first#define ss second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;const int N = 1005;int t,n;pii P[N][N];vector&lt;int&gt; gale_shapley(queue&lt;int&gt; *q)&#123;    queue&lt;int&gt; cur_que;    vector&lt;int&gt; Man;Man.resize(n+1,0);    for(int i = 1;i &lt;= n;i++)cur_que.push(i);    while(!cur_que.empty())&#123;        int woman = cur_que.front(),man = q[woman].front();        q[woman].pop();        if(!Man[man])&#123;            Man[man] = woman;            cur_que.pop();        &#125;        else if(P[woman][man].ss &lt; P[Man[man]][man].ss)&#123;            cur_que.push(Man[man]);            Man[man] = woman;            cur_que.pop();        &#125;    &#125;    return Man;&#125;signed main()&#123;    IOS;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        queue&lt;int&gt; q[N];        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)&#123;            int temp;cin&gt;&gt;temp;            P[i][temp].ff = j;            q[i].push(temp);        &#125;        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)&#123;            int temp;cin&gt;&gt;temp;            P[temp][i].ss = j;        &#125;        int ans[N];        vector&lt;int&gt; Man = gale_shapley(q);        for(int i = 1;i &lt;= n;i++)ans[Man[i]] = i;        for(int i = 1;i &lt;= n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;        if(t)cout&lt;&lt;endl;    &#125;&#125;\n延伸問題\n證明男方求婚法會給出男性的最佳匹配。\n如何有效率的找出所有可能的穩定匹配？\n承上，根據Wiki所述，試證明$n$男$n$女穩定匹配數的平均會漸進於$e^{-1}n\\ln n$。\n證明找出穩定匹配數的問題是一個#P-complete的問題。\n\n下圖是男女對數$n$跟穩定匹配數$S$的關係圖，其增長的速度與$n\\ln n$同級：\n參考資料Wiki:Gale–Shapley Algorithm\n演算法筆記:Matching\nMichael Dzierzawa, Marie-José Oméro, Statistics of stable marriages, Physica A 287 (1–2) (2000) 321–333\n","categories":["數學筆記"],"tags":["數學","匹配"]},{"title":"三門問題（Monty Hall Problem）","url":"/monty-hall/","content":"三門問題，或蒙提霍爾問題是一個違反直覺的條件機率問題，本文將從不同角度切入，探討不同選擇的機率大小。\n問題敘述資料來源影片網址在 2008 年上映的美國電影《決勝21點》中，劇中主角班 (Ben Campbell)在非線性代數的課堂上與授課教授米奇(Mickey Rosa) 有一段精彩的對話：\n\n米奇：「假設你正參加一個遊戲節目，你有機會從三扇不同的門裡選一扇，其中一扇門後面有一輛新車，另外兩扇門後面各有一頭山羊？你要選擇哪一扇門？」\n班：  「一號門。」\n米奇：「好！這時節目主持人，順便一提，他知道門後的秘密，他去打開另一扇門，比方說他開了三號門，後面是一頭山羊。這時節目主持人說：「班，你想要堅持選擇一號門，還是換成二號門？」現在問題是–改變選擇(換另一扇門)是否對你有利?」\n班：  「是的」\n米奇：「記住！主持人知道那輛車在哪裡，你怎麼知道他不是在耍你？……」\n班：  「我並不介意，因為我的答案是基於統計學，……，當一開始他讓我選一扇門時，我有 33.3% 的機率是選對的，但當他開其中一扇門時，然後又讓我選時，此刻如果我選擇換一扇門，選對的機率是 66.7%，……。」\n\n換句話說，假設你正在參加一個游戲節目，你被要求在三扇門中選擇一扇：其中一扇後面有一輛車；其餘兩扇後面則是山羊。你選擇了一道門，假設是一號門，然後知道門後面有什麼的主持人，開啟了另一扇後面有山羊的門，假設是三號門。他然後問你：「你想選擇二號門嗎？」轉換你的選擇對你來說是一種優勢嗎？\n\n答案：換門贏得獎品的機率為$\\frac{2}{3}$，不換門為$\\frac{1}{3}$，因此應該選擇換門！\n這個問題可以擴展成N門問題，也就是主持人在開了$N-2$道門以後，分析換門與不換門贏得汽車的機率。\n條件機率：貝式定理在條件機率中，以$P(A|B)$表示在B發生的條件下A發生的機率，其值：\nP(A|B)=\\frac{P(A\\cap B)}{P(B)}我們還可以畫出以下樹狀圖做分析：假設 $A$ 為得獎的情況，$A’$ 為不得獎的情況，$B$ 為換門的情況，$B’$ 為不換門的情況如果要得獎會發生以下兩種狀況：\n\n不換門得獎：$P(A|B’)=\\frac{\\frac{1}{6}}{\\frac{1}{6}+\\frac{1}{3}}=\\frac{1}{3}\\cong 0.33$\n換門得獎：$P(A|B)=\\frac{\\frac{1}{3}}{\\frac{1}{6}+\\frac{1}{3}}=\\frac{1}{3}\\cong 0.66$\n\n從貝式定律可以得到，換門的機率比較高！\n窮舉法（列表觀察）我們也可以透過列表得到相同的結論，在下表中假設「選中」為參與者第一次選中的門，「開門」則是主持人打開的有山羊的門，「換門」則是剩下的那個門\n這邊可能會有一個疑惑（如果沒有那不要理我XD）：當我第一次選中有車的門時為什麼只有列一次，主持人不是可以選擇打開兩個有山羊的門其中一個，不應是兩種狀況？\n只有一種是因為後面有車的門觀眾只會選到一次，不像山羊觀眾可以選兩次，並且主持人打開哪一道門實際是沒有影響，都視為同一種狀況！\n\n\n\n\n新車\n山羊\n山羊\n結果\n\n\n\n\n選中\n開門\n換門\n不換門贏\n\n\n換門\n選中\n開門\n換門贏\n\n\n換門\n開門\n選中\n換門贏\n\n\n\n\n從上表可以清楚看出，換門之後贏的機會是$\\frac{2}{3}$，不換門則是$\\frac{1}{3}$。\n直覺想法錯誤想法-遲到法有些人會問：當我從三道門選完之後，主持人打開了一扇門。這時候我請另外一個場外人來看現在的局面：兩扇門關閉，一扇門打開是山羊，那這時候這個局外人選中的機會不就是$\\frac{1}{2}$？\n這個推論其實是正確的，以一個局外人看到的情況與機率確實是$\\frac{1}{2}$，但這樣的思考前提是錯誤的，因為這位局外人並沒有參與一開始三門的選擇！條件機率有一個重要的概念，也就是一個事件的機率會隨著情境的不同（提供訊息的改變）而可能會有所改變，這就是一個很明顯的例子\n幫助理解的思考方法\n1990 年 9 月 9 日，瑪麗蓮‧沃斯‧薩萬特 (Marilyn vos Savant) 在《繽紛遊行》(Parade) 的「請問瑪麗蓮」專欄中，回答讀者提出的三門問題，沃斯‧薩萬特是金氏世界紀錄最高智商 228 的人，她認為選擇換的勝算比較大。為了說服讀者，她請大家想像有 1,000,000 扇門，她說：\n你選擇 1 號門，而主持人知道門後有什麼，他總是避開有獎的那扇門，除了 777,777 號門外，把別的門都打開了。這時你會毫不猶豫地換到另一扇門，是吧?」\n\n從N道門中選擇其中一道門中獎機率$\\frac{1}{N}$，不中獎的機率為$\\frac{N-1}{N}$，也就是說有$\\frac{N-1}{N}$的機率汽車在另外$N-1$道門中。這時候主持人幫你一個大忙，他打開了其中沒有汽車的$N-2$道門，不就是幫助你剔除了不可能選中的情況，也就代表把$\\frac{N-1}{N}$的中獎機率集中在剩下的那一扇門中！\n因此可以得到結論：在$N$門問題中，假設主持人總共會打開$N-2$道門，那換門中獎的機率會是$\\frac{N-1}{N}$，不換門中獎則是$\\frac{1}{N}$\n程式實作：以C++模擬如果上面的東西都無法說服你，那就來寫一個程式模擬吧！寫程式最重要的就是要證明模擬是正確的，因此會印出若干組結果看看是否合理！這個程式會亂數幫觀眾選一扇門（隨機選），與中獎的門（也是隨機選），接著主持人打開門後會剩下觀眾選的與一個還沒有被開的門\n主持人打開N-2道門（剩2道門做選擇）我們取$N=3$ 做例子（當然也可以隨意輸入），第一個3表示門的數量，接下來的100000表示模擬次數\n印出前五次的模擬情況作觀察，這個程式在印出未中獎時，換門中獎的事件加一；反之，印出中獎時，不換門中獎的事件加一，模擬結果符合預期！\n如果共有10道門，一樣符合預期，換門中獎機率落在$\\frac{9}{10}$左右\n主持人打開K道門（剩N-K道門做選擇）如果給個變化題，主持人想說不要對觀眾那麼好，在未被觀眾選中的$N-1$ 道門中開啟K道後面有羊的門。我們知道會有$\\frac{N-1}{N}$的機率會在不是觀眾選的另外$N-1$道門中，但在這$N-1$道門中因為打開了$K$道門，剩下$N-1-K$道門可以選擇，因此可以列出以下式子：\n\\frac{N-1}{N}\\times \\frac{1}{N-K-1}=\\frac{N-1}{N^2-NK-1}這就是換門中獎的機率！\n我們可以將換門中獎的機率扣掉不換門中獎的機率：\n\\begin{split}\\frac{1}{N}\\cdot \\frac{N-1}{N-K-1}-\\frac{1}{N} &=\\frac{1}{N}(\\frac{N-1}{N-K-1}-1) \\\\&= \\frac{1}{N}\\cdot\\frac{K}{N-K-1}\\end{split}已知$N-K\\geq2$ 且$K\\geq0$，因此無論開多少門（甚至不開），換門的中獎機率永不小於不換門的機率！\n以上為設定9個門，主持人打開5道門，執行一百萬次的結果。根據上面的公式，我們預期會有$\\frac{8}{27}\\cong 0.2963$的機率換了會中獎，符合模擬的結果\n有a輛車，主持人開K道門這就比較簡單了，原本只有1輛車，變成a輛車自然中獎的機率就會變a倍，套用上面的公式，換門中獎機率：\n\\frac{a\\cdot(N-1)}{N^2-NK-1}程式碼#include &lt;bits/stdc++.h&gt;using namespace std;int selected_door,selected[1000000],make_change=0,keep=0,N,M,open;int main()&#123;    cin&gt;&gt;N&gt;&gt;open&gt;&gt;M; //輸入門的數量N，主持人開門數open，模擬次數M    srand((unsigned)time(NULL));    for(int i=0;i&lt;M;i++)&#123;            //執行M次        selected_door = rand()%N;    //選擇一個門放汽車        for(int j=0;j&lt;N;j++)&#123;          if(j==selected_door)selected[j]=1;          else selected[j]=0;        &#125;        int audience_selected = rand()%N; //觀眾選擇一個門        for(int j=0,ind=0;j&lt;open;ind++)&#123; //將K扇門打開          if(ind!=audience_selected &amp;&amp; ind!=selected_door)&#123;              selected[ind]=2;              j++;          &#125;        &#125;        int change_door = 0; //要換到的門        vector&lt;int&gt;vec; //可以換的選擇        vec.clear();        for(int j=0;j&lt;N;j++)&#123;          if(j!=audience_selected &amp;&amp; selected[j]!=2)&#123;              vec.push_back(j);          &#125;        &#125;        int vec_size = vec.size();        change_door = vec[(rand()%vec_size)];        if(change_door == selected_door)make_change++; //紀錄換而贏的次數        else if(audience_selected == selected_door)keep++; //紀錄不換而贏的次數        if(i&lt;4)&#123;          cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;次模擬&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;觀眾選擇：&quot;&lt;&lt;audience_selected+1&lt;&lt;&quot; 號門&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;中獎的門為：&quot;&lt;&lt;selected_door+1&lt;&lt;&quot; 號門&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;沒有被主持人打開的門：&quot;;          for(int j=0;j&lt;vec_size;j++)cout&lt;&lt;vec[j]+1&lt;&lt;&quot;號門,&quot;;          cout&lt;&lt;endl&lt;&lt;&quot;觀眾選擇要換的門為：&quot;&lt;&lt;change_door+1&lt;&lt;&quot; 號門&quot;&lt;&lt;endl;          if(audience_selected == selected_door)cout&lt;&lt;&quot;不換門中獎&quot;&lt;&lt;endl;          else if(change_door == selected_door)cout&lt;&lt;&quot;換門中獎&quot;&lt;&lt;endl;          else cout&lt;&lt;&quot;換門不換門皆不會中獎&quot;&lt;&lt;endl;          cout&lt;&lt;endl;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(5);    //印出機率    cout&lt;&lt;&quot;不換門贏的機率：&quot;&lt;&lt;(double)keep/M&lt;&lt;endl;    cout&lt;&lt;&quot;換了門贏的機率：&quot;&lt;&lt;(double)make_change/M&lt;&lt;endl;&#125;\n警察抓酒鬼問題這個問題可以用來比較一下三門問題：\n\n某酒鬼有90%的日子都會出去喝酒，喝酒只隨機去固定的三家酒吧。今天警察找了其中兩家酒吧都沒有找到酒鬼。問：酒鬼在第三家酒吧的機率？\n\n我們假設事件$A_1$為酒鬼喝酒的機率、$A_2$為酒鬼在家的機率，$B_1$為酒鬼在前兩個酒吧被抓的機率、$B_2$為酒鬼沒有在前兩個酒吧被抓的機率\n我們要找的是酒鬼沒有在前兩個酒吧被抓的條件下喝酒的機率，可以套用貝氏定理：\n\\begin{split}P(A_1|B_2)&=\\frac{P(A_1\\cap B_2)}{P(B_2)}\\\\&=\\frac{P(A_1)\\cdot P(B_2|A_1)}{P(A_1)\\cdot P(B_2|A_1)+{P(A_2)\\cdot P(B_2|A_2)}}\\\\&=\\frac{\\frac{9}{10}\\times\\frac{1}{3}}{\\frac{9}{10}\\cdot\\frac{1}{3}+\\frac{1}{10}\\times 1} \\\\&=\\frac{3}{4}=0.75\\end{split}正解是75%，也可以顯而易見的用$\\frac{30\\%}{30\\%+10\\%}=75\\%$得到答案\n這題想要討論的是，在三門問題中，主持人是知道哪一些門是沒有汽車的，所以故意打開；但是在這個問題中，警察是不知道哪一個酒吧有酒鬼，兩題本身的前提就不同，不能拿來互相解釋\n結論在分析完三門問題、程式實際模擬和比較其他題目之後，得到一個結論：三門問題中主持人並不是亂選，而是把沒有車的那些門打開，這跟平常直覺的機率想法是不同的！\n雖然對大多數人的直覺反應而言，選擇換門與不換門似乎中獎的機率是相同的，但經過上述一連串利用貝氏定理的討論與歸納後，證實了反而換門才是最明智的選擇。「人的認知有兩種，一是先驗的古典機率，一是經驗的機率，前者會干擾後者；鴿子只有後者，在蒙提霍爾問題上，高人一籌。人其實是聰明反被聰明誤。」(曾志朗，2012)\n","categories":["數學筆記"],"tags":["數學","2021暑期筆記"]},{"title":"最短路徑（Shortest Path Problem）","url":"/path1/","content":"今年是2021，資芽的二階主題跟2020上的有很多的差別，因此會利用暑假把2020的東西也補一補！\n課程內容路徑與權重\n$G=(V,E)$\n尋找最短路徑權重和最小\n無帶權：BFS直接做(or DFS)\n有帶權最短路徑\n\n\nFloyd-Warshall：全點對最短路徑(All Pairs)\n不支援負環\n\n想法：DP轉移（三個迴圈中點、起點、終點依序鬆弛）\n\n$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$\n如果改寫成定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路\n則轉移：$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$\n因此中間點k必須在最外層（不過有論文指出順序顛倒一樣可以得到正確解）\n優點：實作容易，缺點：時間 $O(v^3)$ 、無法處理負環（可處理負邊）\n\nDijkstra’s：單點源最短路徑\n優點：時間 $O(E+V^2)$、無法處理負邊\n\n想法：Greedy（和DP）\n\n維護：1. 未拜訪的節點集合$U$ 2. $d[i]$ 目前起點到 $i$ 最短路 3. 目前考慮節點 $p$\n重複以下動作直到u為空：\n對於所有與 $p$ 連接的節點 $q$，$d[q] = min(d[q],d[p]+weight[p][q])$\n當 $p$ 相鄰節點都走過：在 $u$ 中移除 $p$\n將 $p$ 更新成U中離起點距離最短的點 $min(d[j])$\n\n\n可以變成 $O((E+V)logV)$-&gt;邊較為稀疏的圖時有利（使用priority_queue）\n不能處理負邊，因為 $d[i]$ 較小的處理完之後就不會再更動了，加入負邊可能更小\n拿距離最小的點 $k$ 去更新其他點，不能保證更新後其他點一定是最短路\n上一步走完 $k$ 連接所有邊後，從集合 $U$ 中移除，因為沒有負邊， $k$ 必定是最短路\n\nBellman-Ford：單點源最短路徑\n可以處理負環\n\n時間：$O(VE)$\n\n想法：Relax鬆弛\n一條邊 $\\delta(u,v)$ 滿足 $dis[v] = min(dis[v],dis[u]+weight[u][v])$\n對每一條邊進行鬆弛，因為鬆弛沒有按照最短路順序，因此要做V-1次\n此為暴力作法\n執行V-1次的worst case：\n剛好跟最短路徑的順序相反\n每次 Relax 後只能優化單一子路徑\n共有V個頂點，需要有V-1 條子路徑，每一次一條\n檢查負環：做完之後卻有滿足$d[v] &gt; d[u]+w(u,v)$ ，表示有負環\n\n\n\n優化：SPFA(Shortest Path Faster Algorithm)\n每次只relax更新過的點\n\n使用queue優化，有點像BFS過程\n\n1.把起點 Push 到 Queue\n2.從 Queue 裡 Pop 出一筆資料\n3.該筆資料的所有邊進行 Relax\n4.有更新到的頂點再 Push 到 Queue\n5.重複步驟 2 ~ 4，直到 Queue 為空\n\n\n時間：$O(VE)$ -&gt;worst case，期望 $O(KE)$ ，K大概是2吧（反正挺快的）\n\nDAG Shortest Path首先對所有點進行拓墣排序，花上時間 $O(V+E)$，接著對每一條邊進行鬆弛，時間$O(E)$，因此總時間複雜度是 $O(V+E)$。這個時間複雜度是很快的，但相對的限制也非常多，除了不能有負邊與負環之外，更不能有正環在其中，否則不能進行拓墣排序（在之前筆記進階圖論（一））有提到，也就是這一中圖必須是DAG(Directed Acyclic Graph)！\n一個有趣的應用：PERT\n最短路徑樹\n紀錄predecessor(樹父節點唯一)\n\n起點到每個點的最短路徑都唯一的話，那把這些路徑疊起來會變成一棵樹\n\n樹：每一點都有唯一來源（最短路）\n\n最短路徑比較最短路徑問題共有以下求解方式（當然還有一堆），整理比較圖：\n負環上表中的可以處理負環的SPFA和Bellman-Ford是以什麼樣的方式處理？（遇到負環權重應該是$-\\infty$）上方所謂負環是指下圖這種情況（當出發點為s，終點為t求最短路徑的問題），因為沒有經過負環，因此 $\\delta(s,t)$ 可以被SPFA和Bellman-Ford求出正確的最短路徑為1。我們可以利用從終點回朔最短路徑（利用predecessor紀錄）看是否有重複經過的點，如果有則表示途中有經過負環！\n\n至於其他的算法，都會求出不正確的數值！\n\n            Floyd warshall這個演算法是處理全點對的最短路徑，如果有負環，那一定有任兩點的最短距離是錯誤的。不過我們一樣可以利用Floyd-Warshall演算法判斷圖中是否有負環，只要檢查每一個點走到自己的距離是否為負 ，即$dis[i][i]","categories":["C++進階主題","最短路徑"],"tags":["2021暑期筆記","2020資訊之芽"]},{"title":"最近點對：詳解4種不同複雜度之算法","url":"/pair/","content":"\n題目敘述給定二維平面上 $n$ 個點，每一點都有座標 $(x_i,y_i)$ ，求出最近的點對之歐幾里德距離為多少？$dis(p_i,p_j) = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$\n\n平面最近點對有好多種實作方式，從最差的暴力枚舉、稍微優化的掃描線演算法、到分治與隨機，有4種不同的時間複雜度。利用TIOJ 1500這一題最近點對的裸題，來實測各種不同複雜度下所需要的執行時間。\n暴力枚舉時間複雜度：$O(N^2)$Submission時間：TLE,10440\n\n暴力$O(n^2)$將所有點進行枚舉，因為值域是 $n≤50000$ ，平方枚舉會有TLE的問題。\n程式碼#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\n掃描線算法時間複雜度：Worst Case $O(N^2)$Submission時間：AC,1668\n這一種作法是改善過後的暴力枚舉，利用計算幾何中掃描線的概念，先將所有點依照x座標進行排序（y座標隨意）。接著想像一條從左往右掃的掃描線，對於每一條掃描線看右邊的點，如果當前最近點對距離為 $d$，因此只要遇上x座標差距大於 $d$ 的點時，即可繼續下一輪的枚舉。\n加上排序的關係，其時間複雜度至少為 $O(n\\log n)$，但這種掃描線的方式無法有效過濾所有點都在相同的x座標上的情況，因此最差的時間複雜度會退化成 $O(n^2)$ ，不過聽說平均的狀況下是很快的！\n\n上圖為掃描線執行最近點對的一個示意圖，黑線為掃描線，$d$ 為掃描線左邊所有點的最近點對距離，我們只要每一輪枚舉這個點與右邊x座標差在 $d$ 以內的所有點，即可進行下一輪的更新！\n程式碼#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p,p+n);        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                if(p[j].x &gt; p[i].x + d)break;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\n掃描線算法（優化後）時間複雜度：$O(N\\log N)$Submission時間：AC,148\n原本以為上面的掃描線就是他的極限了，沒想到上面的worst case還可以透過set優化成 $O(n\\log n)$！簡單來說，方法一樣是想像一條掃描線由左而右，一樣照上面的想法，把x座標差大於d的點排除，之後利用set二分搜找出y座標在範圍內的點進行枚舉更新答案。\n\n將點輸入並且排序，X座標為主，Y座標為輔。\n使用set，並以Y座標為排序基準（pair的首項），以儲存第 $i$ 點的左方、水平距離小於等於d的點。\n右掃描線依序窮舉各點作為右端點。　(1) Erase與右端點水平距離大於d的點們（左掃描線右移）　(2) 用二分搜找出與第 $i$ 點垂直距離小於d的點，並嘗試更新　(3) 將第 $i$ 點加入set中。\n\n\n程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define ld long double#define N 200005#define x first#define y second#define pii pair&lt;int,int&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;vector&lt;pii&gt; p;set&lt;pii&gt; s;ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    IOS;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    while(cin&gt;&gt;n)&#123;        p.assign(n,&#123;0,0&#125;);        for(int i = 0;i &lt; n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        s.clear();        s.insert(&#123;p[0].y,p[0].x&#125;);        int l = 0;ld ans = 5e18;        for(int i = 1;i &lt; n;i++)&#123;            int d = ceil(ans);            while(l &lt; i &amp;&amp; p[l].x &lt; p[i].x - d)&#123;                s.erase(&#123;p[l].y,p[l].x&#125;);                l++;            &#125;            auto it_l = s.lower_bound(&#123;p[i].y - d,0&#125;);            auto it_r = s.upper_bound(&#123;p[i].y + d,0&#125;);            for(auto it = it_l;it != it_r;it++)&#123;                ans = min(ans,dis(&#123;it-&gt;y,it-&gt;x&#125;,p[i]));            &#125;            s.insert(&#123;p[i].y,p[i].x&#125;);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n分治算法時間複雜度：$O(N\\log N)$Submission時間：AC,196\n\n分治做最近點對的基本想法，先將所有點依照x座標排序，利用遞迴得到分割點左右兩邊所有點的最短距離（兩點並不會跨過中間分隔線），枚舉所有會橫跨兩側且有可能更新最短距離的點對。\n\n從兩半邊的遞迴得到目前的最近點對距離 $d = min(d_l,d_r)$ ，將分隔線附近x座標差距小於$d$的點通通都枚舉一遍。可能會有一個疑問，我們是不是可以縮小枚舉的範圍，否則點的數量可能會太多導致複雜度爆炸？除了x座標可以做點的篩選之外，在枚舉的過程中，我們會利用將所有點對y座標排序，將y座標直線距離大於 $d$ 的情況剔除，所剩下真的需要枚舉點也只會剩下常數個，因此可以放心枚舉。\n複雜度分析： 腦海中想像遞迴樹的長相，會發現每一層都需要都需要對y座標進行排序，時間為$O(n\\log n)$ ，每一次都將n的值除以2，因此共有$O(\\log n)$ 層，總共的時間複雜度為 $O(n\\log^2n)$。（不過實際上應該會比這個快，因為並不是要對所有點都進行排序）。\nT(n) = 2T(\\frac{n}{2})+O(n\\log n) = O(n\\log^2n)如果要做得更快，可以在y座標排序的地方稍微動動手腳。既然每一層都要對y座標進行排序，排序好的東西再排序一次其實沒有什麼意義，因此就可以用）合併排序（merge sort）的方式，將所有已經排序好的兩個左右序列進行$O(n)$的合併（可以用std::merge()完成），如此一來，就不須要每一層花到 $O(n\\log n)$ 的ㄕˊ間進行排序，使總複雜度降低為 $O(n\\log n)$！\nT(n) = 2T(\\frac{n}{2})+O(n) = O(n\\log n)程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 50002#define INF1 100000000#define INF 5e18#define FOR(i,n) for(int i=0;i&lt;n;i++)#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;#define pdd pair&lt;double,double&gt;using namespace std;int n;vector&lt;pii&gt; p,temp;void init()&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    temp.clear();    p.assign(n,&#123;0,0&#125;);&#125;bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125;double dis(pii a,pii b)&#123;    double x1 = a.x-b.x,y1 = a.y-b.y;    return sqrt(x1 * x1 + y1 * y1);&#125;//區間[l,r]double solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l+r)/2,mid_pos = p[mid].x;;    double ans = min(solve(l,mid),solve(mid+1,r));        temp.assign((r-l+1),&#123;0,0&#125;);    merge(        p.begin() + l, p.begin() + mid + 1,        p.begin() + mid + 1, p.begin() + r + 1,        temp.begin(), cmp    );    rep(i, l, r)p[i] = temp[i-l];    temp.clear();    rep(i, l, r)&#123;        if(abs(p[i].x - mid_pos) &lt;= ans)&#123;            temp.push_back(p[i]);        &#125;    &#125;    int len = temp.size();    rep(i, 0, len-1)&#123;        rep(j, i+1, len-1)&#123;            ans = min(ans, dis(temp[i],temp[j]));            if(abs(temp[i].y-temp[j].y) &gt; ans)                break;        &#125;    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        init();        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        double ans = solve(0,n-1);        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n隨機算法時間複雜度：期望 $O(N)$Submission時間：AC,488\n\n用隨機算法做最近點對的期望複雜度是 $O(n)$ ，也就是說如果一開始進行的Random_shuffle有做好的話，期望可以在線性時間解決這個問題。基本的想法如下：\n\n將最近點對距離設為d，初始為第一、二個點之間的距離\n將每一個點的座標塞入以 $\\frac{d}{2}$ 為邊長的網格中\n將點加入網格中，查看要加入的網格是否已經有點在其中\n一個網格不可容納兩個點，否則必須更新最近點對的距離\n在更新最近點對距離之後，將前面的點的網格座標以新的$d$進行更新\n\n這個算法用到隨機的因子，因此如果在一開始有將所有點進行均勻的打散的話，可以做到期望複雜度 $O(n)$。\n複雜度分析：考慮加入第i+1個點時出現新的最近點對，發生的機率為：在$C_2^{i+1}$個配對中跟i+1個點產生最近點對共有i種可能因此機率為$\\frac{2}{i+1}$。\n當機率發生的時候，必須將所有的點都刪掉重新來一遍（r變小，重新推入i+1個點），需要付出$O(i+1)$的時間，相乘起來加入每一個點期望的複雜度為$O(1)$，因此總時間複雜度為$O(n)$。\n程式碼#include &lt;bits/stdc++.h&gt;#define int long long int#define ld long double#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define INF 1000000000LL#define swift 1000000000using namespace std;int n;ld r,d,ans;int dx[25] = &#123;-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2&#125;;int dy[25] = &#123;-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2&#125;;unordered_map&lt;int, int&gt; m;void solve();inline void init();void solve();bool insert(int,int,int);inline double dis(int,int);inline int Grid(int);struct node&#123;    int x,y,ind;&#125;point[N];//函式實作inline void init()&#123;    m.clear();    cout&lt;&lt;fixed&lt;&lt;setprecision(6);&#125;inline int Grid(int ind)&#123; //input網格座標    int x = point[ind].x/r;    int y = point[ind].y/r;    return x*INF+y;&#125;inline ld dis(node a,node b)&#123;    ld x = a.x-b.x,y = a.y-b.y;    return sqrt(x*x+y*y);&#125;void solve()&#123;    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));    for(int ind = 2;ind &lt; n;ind++)&#123;        int x = point[ind].x/r,y = point[ind].y/r,better=0;        for(int i=0;i&lt;25;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            auto it = m.find(nx*INF+ny);            if(it!=m.end())&#123;                double distance = dis(point[it-&gt;second],point[ind]);                if(distance&lt;d)&#123;                    better = 1;                    ans = dis(point[it-&gt;second],point[ind]);                    d = distance;                    r = d/2;                &#125;            &#125;        &#125;        if(better)&#123;            m.clear();            for(int i=0;i&lt;=ind;i++)m.insert(make_pair(Grid(i),i));        &#125;        else&#123;            m.insert(make_pair(Grid(ind), ind));        &#125;    &#125;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        init();        for(int i=0;i&lt;n;i++)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            x+=swift;y+=swift;            point[i].x = x;point[i].y = y;        &#125;        random_shuffle(point, point+n);        int smalln = sqrt(n);        ans = dis(point[0],point[1]);        d = dis(point[0], point[1]);        for(int i=0;i&lt;=smalln;i++)&#123;            for(int j=i+1;j&lt;=smalln;j++)&#123;                d = min(d,dis(point[i], point[j]));                ans = min(ans,dis(point[i],point[j]));            &#125;        &#125;        r = d/2;        solve();        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n相關題目\nNEOJ 最近點對\nTIOJ 最遠點對\n\n","categories":["C++進階主題","最近點對"],"tags":["分治法","暑假筆記"]},{"title":"[題解]NEOJ 393 百慕達三角洲","url":"/path2-2/","content":"百慕達三角洲\n題目連結\n\n題目大意：給定一張長n寬m的矩形圖，由”#”和”.”組成，給定起點$(x_1,y_1)$以及終點$(x_2,y_2)$，必須最小化經過”.”的次數，求最少需幾過幾次。\n\n當下看到這一個題目的想法，就是跟處理一般的圖論題目一樣，將邊用vector儲存起來，將經過”.”的權重設為很大的一個數字，這樣用Dijkstra做一次最短路徑就可以找出經過”.”最小化的次數了！\n以下是MLE的Submission吃了開心的MLE，如果當成一般的圖在處理，不管是在 $dis$ 開long long的處裡，或是開了一個vector陣列儲存邊，都非常的消耗空間。因此，我詢問了一下電神這一題的想法，他說我的想法用Dijkstra是正確的，不過在設定邊權的部分可以直接用0跟1代替，而且可以用queue去輔助實作BFS（要說它也可以是Dijkstra的另一種比較簡單的版本）。\n\n這題也就是所謂0-1 BFS (Shortest Path in a Binary Weight Graph)，或是這裡0-1 BFS，想法可以說是Dijkstra跟BFS的綜合（其實它跟SPFA也很相似）。以下是實作步驟：\n\n建立雙向的佇列(deque)，等等要存放被relax過的點，初始放入起點\n每一次從deque前方pop出一點，對那一點相鄰的所有點進行鬆弛\n如果被鬆弛時的邊權重為0，將點push dequeue的前方\n否則當鬆弛時的邊權重為1，將點push dequeue的後方\n重複執行2-4步驟直到deque為空\n\n當我們一直利用deque最前端的元素進行鬆弛，因為我們將邊權為0的元素放入最前端，用距離最小的那些點進行鬆弛，每一個點最多會被鬆弛一次，因此總時間複雜度為$O(V+E)$，比起用Dijktra直接做$O((V+E)\\log V)$快了許多（此演算法之所以正確是因為其中一邊的權重是0，不管0接到誰他的權重也都是0，有點像「從最小層逐漸擴展」的概念）！\n\n            小問題（出處這裡）Can we apply the same trick if our edge weights can only be 0 and x (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and x+1 (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and y (x,y &gt;= 0) ?解答YES,NO,NO\n          \n這題之所以可行是因為有一邊的權重是0，當點皆以權重為0串再一起時，他會是最短的，使用最短去更新接下來的點，因此第一題是正確的！但第二題與第三題是錯誤的，考慮以下點與邊的情況：\n\n當我依照01BFS的方法不斷去用x更新其他的點，更新完之後會發現點1到點3的最短路徑應該是x+1，到時候又要再重新Relax一次，複雜度會爆炸喔（比SPFA可能還慘，因為當點三利用兩個x更新完之後，用它來做跟3所有相鄰的點，做完卻發現$(1,3)$有更短的距離，又必須重新全部更新一次！）總結來說，他只是用於只有兩種邊的情況，且其中一邊必須為0。\n\n\n            比較一下記憶體用量最主要還是時間複雜度的比較，不過既然空間已經爆了，時間也沒法比了QQMLE#define N 2005#define N2 4000005int n,m,q,predecessor[N2],dis[N2];bool visit[N2],maze[N2];vector&lt;pii&gt;edge[N2];AC#define N 2003int n,m,dis[N][N];bool visit[N][N],maze[N][N];\n          \n以下是使用deque實作01BFS的AC code：\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 2003#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N],maze[N][N];void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    memset(visit,0,sizeof(visit));    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    deque&lt;pii&gt;deq;    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    memset(dis,0x3f3f3f3f,sizeof(dis));    dis[s1][s2] = 0;    deq.push_back(&#123;s1,s2&#125;);    while(!deq.empty())&#123;        int x = deq.front().first,y = deq.front().second;        deq.pop_front();        for(int i=0;i&lt;4;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;                        if(dis[nx][ny] &gt; dis[x][y]+maze[nx][ny])&#123;                dis[nx][ny] = dis[x][y]+maze[nx][ny];                if(maze[nx][ny]==0)deq.push_front(&#123;nx,ny&#125;);                else deq.push_back(&#123;nx,ny&#125;);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e1][e2]&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]NEOJ 431 江神與他的小火車","url":"/path2-3/","content":"江神與他的小火車\n題目連結\n\n題目大意已知有N個點以及M條邊，總共有Q筆詢問，每筆詢問有$\\delta(a,b)$，表示新增一條由 $a$ 指向 $b$ 的邊（其權重為1），對每一筆詢問輸出從點 $1$ 到點 $N$ 的最短距離。\n\n\n我們知道如果有用新加進來的邊 $\\delta(a,b)$，則路徑可以被拆解成 $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$。其中，我們可以用Dijkstra 一次尋找1到任何點的最短距離，那要如何處理路徑 $\\delta(b,n)$ 呢？這就是單一目的最短距離問題，我們可以將所有的邊逆序，將終點做一次Dijkstra尋找最短路，這時候我們就可以用 $O(1)$ 的時間回答每一筆詢問，總時間複雜度：預處理$O((V+E)\\log V)$，詢問 $O(Q)$。\n\n            測資小問題有一筆測資如下，藍線是給定的路徑與權重，紅色是新加入的邊，如果按照上面 $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$ 我們可以計算出從起點到終點的最短距離為：$2+1+4 = 7$，很明顯兩點之間的最短距離是 $5$ ，但因為原本作法會經過一條$\\delta (B,C)$ 的重邊，造成算出來的距離是比較大的！這時候我們只要對最短路徑長度取min即可，也就是說在這種情況加入這一條邊並不會影響最短路徑的長度！測資（1,2,3分別對應A,B,C）：6 5 11 2 12 3 13 4 14 5 15 6 13 2\n          \n接下來是程式碼，之後如果遇到最短路徑的題目，一般來說會避免使用SPFA（除非有負邊），為了要避免最糟的時間複雜度，因此會使用Dijkstra來處理最短路徑問題！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,q;bool visit[N];vector&lt;pii&gt; edge[2][N];//edge[0]-&gt;normal,edge[1]-&gt;oppositevector&lt;int&gt; Dijkstra(int start,int end,bool is_nor)&#123;    memset(visit,0,sizeof(visit));    vector&lt;int&gt; dis(n+2,1e16);        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;        dis[start] = 0;    pq.push(&#123;0,start&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                visit[cur] = 1;        for(auto i : edge[is_nor][cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur] + weight)&#123;                dis[next] = dis[cur] + weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    return dis;&#125;void solve()&#123;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=0;i&lt;m;i++)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[0][a].push_back(&#123;b,w&#125;);        edge[1][b].push_back(&#123;a,w&#125;);    &#125;        vector&lt;int&gt; normal,opposite;    normal = Dijkstra(1,n,0);    opposite = Dijkstra(n,1,1);        while(q--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        cout&lt;&lt;min(normal[a]+opposite[b]+1,normal[n])&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]TIOJ 1641 貨物運送計劃","url":"/path2-4/","content":"貨物運送計劃\n題目連結\n\n題目敘述給定N個點M條邊，第i條邊有方邊率$C_i$，假設目前運送貨物重量p經過此邊，代表經過邊i會需要多增加 $p\\times C_i$ 的重量。給定起點、終點，求到達終點時最少的貨物重量為多少。\n\n換種說法，題目要求的是每經過一條邊，就要乘上某一個數，要求到終點最小的重量。下圖是題目範例測資：\n$\\delta(1,2)\\to\\delta(2,3)$，所付出的代價是$(1\\times (1+1))\\times (2+1)=6$。如果是$\\delta(1,3)$ 的話直接$1\\times (4+1)=5$，可以觀察到，遇到邊就需要將原本的數字乘上$C_i+1$。\n我們可以透過將邊權取 $\\log$ 之後，就可以利用Dijkstra進行最短路徑的計算，因為取 $\\log$ 後的加減運算等同於原本的乘法運算，只要最後把算出來的答案次方即可！\n這一題的輸出要求科學記號（為了要避免浮點數誤差），以下程式碼來達成（要求小數點後兩位，同時次方部分要求整數3位）：\nprintf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);\n程式碼的部分，透過$edge$存完所有的取完 $\\log$ 之後的邊，進行Dijkstra，輸出最短路徑（以科學記號表示）即可！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s,t;double dis[N];bool visit[N];vector&lt;pid&gt; edge[N];void solve()&#123;    memset(visit,0,sizeof(visit));        scanf(&quot;%lld %lld %lld %lld&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=0;i&lt;m;i++)&#123;        int a,b;double c;scanf(&quot;%lld %lld %lf&quot;,&amp;a,&amp;b,&amp;c);        edge[a].push_back(&#123;b,(double)log10(c+1)&#125;);    &#125;    fill(dis,dis+n+2,1e16);        priority_queue&lt;pdi,vector&lt;pdi&gt;,greater&lt;pdi&gt;&gt; pq;    dis[s] = 0.0;    pq.push(&#123;0,s&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;        visit[cur] = 1;                for(auto i:edge[cur])&#123;            int next = i.first;            double w = i.second;            if(dis[next] &gt; dis[cur]+w)&#123;                dis[next] = dis[cur]+w;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    double ans = dis[t];    int x = floor(ans);    ans-=x;        printf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);&#125;signed main()&#123;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]NEOJ 391 可魚果運輸問題","url":"/path2-1/","content":"可魚果運輸問題\n題目連結Dijkstra’s AlgorithmSPFA這一題的來源是NPSC2013的題目，題目大意如下：\n\n有n個城市m個運輸方案，每個方案 $P_i$ 會從一個固定的起始城市 $A_i$ 運送東西到另一個固定的終點城市 $B_i$，每運輸一件物品，就必須付 $C_i$ 價錢。若用方案 $P_i$ 運輸了超過 $D_i$ 件物品，多出來的部份每件物品收 $C_i’$ 元。共要運輸 $f$ 物品。求起點 $s$ 到終點 $e$ 的最短路徑。\n\n當運輸總量超過 $D_i$ 件物品，表示可以使用更小的邊權重去計算接下來的費用。這時候我們可以了解到一個性質，如果我把全部的物品全部集中在一條路徑運送，因為送的越多，相對的在費用上就可能產生優惠，比分散多條路徑的運送花費來的小。因為總共要運送 $f$ 件物品，因此會將邊的權重設定為當 $f$ 件物品都經過這一條邊時，所要花費的價格。\n有了邊以及價格之後，便可開始進行最短路徑的演算法。因為題目範圍 $N≤100$ ，因此用Dijkstra’s 或是 SPFA 都可以做（Bellman-Ford就先不要XD）。\nDijkstra’s Algorithm這篇有一篇論文是Dijkstra在針對最短路徑寫的論文（也就是以他名字命名的演算法論文），這篇只有三頁耶！以下是「演算法導論」這本書中演算法的虛擬碼：\nDIJKSTRA(G, w, s)  1  INITIALIZE-SINGLE-SOURCE(G, s)  2    S &lt;- Ø  3    Q &lt;- V[G]  4    while Q ≠ Ø  5        do u &lt;- EXTRACT-MIN(Q)  6            S &lt;- S ∪ &#123;u&#125;  7            for each vertex v ∈ Adj[u]  8                do RELAX(u,v,w)\n其中集合 $S$ 在程式碼中代表的是visit，而集合 $Q$ 因為要操作取出最小元素的動作，因此會用priority_queue實現，以heap來進行 $O(\\log n)$ 的插入以及取出。\n這裡面使用$visit$判斷是否在集合 $S$ 中，但我們可以發現，如果在priority_queue中有兩個點的存在，第一個點處理完被加入集合 $S$ 中之後，第二次再次被拿出來進行處理時就不會有任何相鄰的點再一次被處理，這是因為第一次與第二次更新所使用的 $dis[cur]$ 是一樣的。因此，當一個點已經在visit中（也就是在集合 $s$ 中），我們可以直接換下一個點去執行（不過如果忘了visit也是沒差啦）。\n\n            複雜度分析以下分析一下演算法時間複雜度，總共有兩個時間複雜度，取決於使用何種資料結構來實作。1. 時間複雜度 $O(V^2+E)$首先是每一個點執行 $V$ 次對每一個相鄰的點進行更新，每一輪執行 $O(V)$ 尋找目前距離 $dis$ 最小的點。總共有 $E$ 條邊需要更新，因此最後要把 $E$ 再加上去。這樣總複雜度就會 $V\\times O(V)+O(E) = O(V^2+E)$。此實作方式一般在稠密的圖中會有比較好的表現。2. 時間複雜度 $O((V+E)\\log V)$這一題在 $O(n)$ 爆搜尋找改用heap去優化，因此複雜度就會是一樣執行V 輪利用 $O(logV)$ 找到距離 $dis$ 最小的點，同時將更新後的點放進heap中，我們知道放入heap的複雜度也是 $O(\\log n)$，因此複雜度就會變成 $O(V\\log V)+O(E\\log V) = O((V+E)\\log V)$。此實作方式一般在稀疏的圖中會有比較好的表現，從 $V$ 與 $E$ 的大小估計可以大致發現。\n          \n以下是程式法的實作，最需要注意的地方是pair的first跟second儲存的東西。在存圖時會使用（點,權重）搭配vector；而在priority_queue中，因為要對權重進行比較，因此會用（權重,點），需要特別注意別搞混了!\n\n            Priority_Queue實作細節預設的priority_queue會pop出目前heap中最大的元素（預設是less&lt;&gt;函數），如果要實作一個min heap 的話要使用greater&lt;&gt;函數，同時第二個傳進函數的參數要用一個vector！priority_queue &lt;Type, vector&lt;Type&gt;, ComparisonType &gt; min_heap;priority_queue &lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;   \n          \n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //存圖    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //城市數n、方案數m、s起、e終、f箱數    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //一條由a連到b的邊，權重c，流量超過d，則改權重c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //Dijkstra    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;    //(距離,點)    pq.push(&#123;0,s&#125;);    dis[s] = 0;        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;                        if(dis[cur]+weight&lt;dis[next])&#123;                dis[next] = dis[cur]+weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;        visit[cur] = 1;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nShortest Path Faster Algorithm(SPFA)這是一個使用queue最佳化的Bellman-Ford演算法，基本的使用方式跟BFS幾乎相同，在Bellman-Ford對邊進行更有效率的鬆弛(relaxation)。以下一樣是「演算法導論」中Bellman-Ford的虛擬碼：\nBELLMAN-FORD(G,w,s)  1    INITIALIZE-SINGLE-SOURCE(G,s)  2    for i &lt;- 1 to |V[G]|-1  3        do for each edge (u,v)∈ E[G]  4            do RELAX(u,v,w)  5    for each edge (u,v)∈ E[G]  6        do if d[v] &gt; d[u]+w(u,v)  7            then return FALSE  8    return TRUE\n以下是SPFA的虛擬碼，如果節點有被實際鬆弛過，且節點不在queue中（同樣元素在queue中出現兩次沒有意義，因為只要確保有在queue中等會會被更新到就好，到它的最短距離不會被改變），便將此節點推入queue中。裡面存的是帶進行鬆弛的節點們，也就是被剛剛更新過的節點。我們可以利用$visit[ ]$來 $O(1)$ 判斷節點是否有在queue中！\n有進行判斷是否在queue中的（比較省空間一點）：沒有進行判斷的，有被更新過就塞進去：\nShortest-Path-Faster-Algorithm(G, s)  1    for each vertex v ≠ s in V(G)  2        d(v) := ∞  3    d(s) := 0  4    offer s into Q  5    while Q is not empty  6        u := poll Q  7        for each edge (u, v) in E(G)  8            if d(u) + w(u, v) &lt; d(v) then  9                d(v) := d(u) + w(u, v) 10                if v is not in Q then 11                    offer v into Q\nSPFA有一個問題，他可以被出題目的人設計測資去卡這種算法，使時間複雜度變成糟糕的$O(V^2)$，因此一般來說會實作Dijkstra而非SPFA！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //存圖    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //城市數n、方案數m、s起、e終、f箱數    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //一條由a連到b的邊，權重c，流量超過d，則改權重c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //SPFA        queue&lt;int&gt; que;    que.push(s);    dis[s] = 0;    visit[s] = 1;        while(!que.empty())&#123;        int cur = que.front();        que.pop();        visit[cur] = 0;                //pop出來將狀態改成不在queue中        for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur]+weight)&#123;                dis[next] = dis[cur]+weight;                if(!visit[next])que.push(next);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]TIOJ 1096 E.漢米頓的麻煩","url":"/path2-5/","content":"E.漢米頓的麻煩\n題目連結\n他題目時不時提到漢米頓，是多愛漢米頓XDD（這一題跟漢米頓根本沒關係）\n\n題目大意在一張n(n≤100)個點的圖中，尋找路徑長度最短的環\n\n那就用Floyd-Warshall找最小的環就好！\n\n            Floyd-Warshall這就是dp的作法，用 $O(N^3)$ 的時間進行轉移，就能得到全點對的最短路徑。這邊有一個重要的轉移順序，也就是中點-起點-終點進行轉移，如果把dp展開就會發現中點必須在最外層進行轉移：定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路徑，則轉移式變成：d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])每一個k+1都是由k轉移而來，仰賴k的點的配對，因此必須最先轉移中點k的部分！（不過順序顛倒也不會怎樣啦，上面「課程內容」的地方有寫到）\n          \n同樣這一份code也可以判斷有沒有負環，只要ans小於0的話代表有負環（有的話距離是不能用的喔，因為Floyd-Warshall不能處理負環，但負邊是可以處理的）\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 101#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,dp[N][N];void solve()&#123;    memset(dp,0x3f3f3f3f,sizeof(dp));    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            int temp;cin&gt;&gt;temp;            if(temp!=0)dp[i][j] = temp;        &#125;    &#125;    for(int k=0;k&lt;n;k++)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)&#123;        ans = min(ans,dp[i][i]);    &#125;    if(ans == INT_MAX)cout&lt;&lt;-1&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        solve();    &#125;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]TIOJ 1028 旅遊規劃問題","url":"/path2-6/","content":"旅遊規劃問題\n題目連結Submission這一題 $n≤13$ 大概就是位元dp來完成（狀態壓縮），定義 $dp[i][j]$ 為現在在點i上，拜訪過點集j的最短距離（j中不包含點i）。這裡使用到了同層轉移的技巧，也就是利用j中的點，對相同狀態下不在i中的點進行更新。\n點集j中在狀態i下為起點，用Dijkstra對不在i中的其他點進行更新，最後的答案即為$dp[s][S-(1&lt;&lt;s)]$。\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m;vector&lt;pii&gt; edge[N];int dis[N],dp[N][1&lt;&lt;N],pre[N][1&lt;&lt;N];bool visit[N];//定義dp[i][j]為現在在點i，拜訪過點集合j（i不在點集j中）signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    rep(i,1,m)&#123;                                 //讀入m條邊        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    int S = 0,start = -1;cin&gt;&gt;m;                //S為待拜訪的所有點集合    rep(i,1,m)&#123;        int temp;cin&gt;&gt;temp;        S = S|(1&lt;&lt;temp);        if(start == -1)start = temp;    &#125;        rep(i,0,n)rep(j,0,(1&lt;&lt;n))dp[i][j] = INF;    rep(i,0,n)dp[i][0] = 0;        for(int i=1;i&lt;(1&lt;&lt;n);i++)&#123;        if(i == (S &amp; i))&#123;                       //在集合i中的點在S一定要有            priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;            fill(dis,dis+n,INF);                //將dis初始為無限大，做Dijkstra            memset(visit,0,sizeof(visit));            for(int j=0;j&lt;n;j++)&#123;                if(i&amp;(1&lt;&lt;j))&#123;                   //從有在i中的點向不在的點做Dijkstra                    dis[j] = dp[j][i^(1&lt;&lt;j)];   //目前在j，經過拜訪了點集i（不包含點j）                    pq.push(&#123;dis[j],j&#125;);        //利用在i中的點對其他點進行更新                &#125;            &#125;            while(!pq.empty())&#123;                int cur = pq.top().second;                pq.pop();                visit[cur] = 1;                for(auto k : edge[cur])&#123;                    int v = k.first,w = k.second;                    if(i&amp;(1&lt;&lt;v))continue;                    if(dis[v] &gt; dis[cur]+w)&#123;                        dis[v] = dis[cur] + w;                        pre[v][i] = cur;        //紀錄點v在狀態i下由cur轉移                        pq.push(&#123;dis[v],v&#125;);                    &#125;                    else if(dis[v] == dis[cur]+w &amp;&amp; pre[v][i] &gt; cur)&#123;                        pre[v][i] = cur;                    &#125;                &#125;            &#125;            for(int j=0;j&lt;n;j++)&#123;               //對於不在點集i中的點進行更新                if(i &amp; (1 &lt;&lt; j))continue;                dp[j][i] = dis[j];              //同層狀態轉移，更新dp[j][i]            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;Minimum travel distance: &quot;&lt;&lt;dp[start][S^(start)]&lt;&lt;endl;    cout&lt;&lt;&quot;Travel route:&quot;;    int cur = start;S = S^(1&lt;&lt;start);    while(true)&#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;cur;        if(!S)break;        cur = pre[cur][S];        if(S&amp;(1&lt;&lt;cur))S = (S^(1&lt;&lt;cur));         //經過的點不一定是指定的觀光點    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]Codeforces 543B: Destroying Roads","url":"/path2-7/","content":"Codeforces 543B: Destroying Roads\n題目連結Submission\n\n題目大意給定N個點M條無向邊，每一邊權重都是1，以及兩筆資料，由三個數$(x,y,w)$ 構成，代表起點為x、終點為x、要在w距離內從起點走到終點。試問最多可以拔掉幾條邊同時滿足以上兩個資料所描述的特性？\n\n這一題蠻有趣的，首先他的邊權重都是1，因此我們可以直接用BFS尋找最短路徑，並且點第一次拜訪到時的就是該點的最短距離（BFS一層一層擴展）。\n\n            第一個想法：錯誤想法我先將兩個起點與終點的最短路徑都找出來，把將過的邊都標上不能移除，將其他的邊全部拔掉。問題點：固然找到的是最短路徑，但不代表可以最大化拔除邊的數量。因為題目要求兩點只要符合最短距離 $w$ 即可，因此每一個配對其實不用符合是最短路徑的情況（如下圖）！目標是在題目要求的限度內最大化重複的邊，使能夠被拔除的邊最大化！上圖紅色線段是$\\delta(1,7)$的最短路徑、褐色是線段$\\delta(3,6)$的最短路徑、黑色線段是皆以最短路徑之下可以被拔除的邊。但是如果將路徑$\\delta(3,6)$換成是$(3,2)\\to(2,4)\\to(4,5)\\to(5,6)$，被拔除的邊可以增過為三條。\n          \n這一題最重要的關鍵就是以$O(V^2)$枚舉所有點對（距離長度可以直接換算成邊的數量），可以先用$O(V(V+E)$的時間對每一個點用進行BFS，如此一來總複雜度即為$O(V^2+VE)$，所幸題目給定總共的邊數不會超過3000條，因此是可以在時間限制內完成枚舉。\n\n            枚舉路徑 $\\delta(i,j)$ 為共同邊的時候，必須考慮起點與終點的方向，同時考慮從 $i\\to j$ 以及從 $j\\to i$ 兩個方向。以下圖為例，當枚舉都使用相同的起點以及終點，會讓下圖的 $(3,4)$ 被重複計算！\n          \n以下是AC程式碼：\n#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 3005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s1,e1,w1,s2,e2,w2,dis[N][N];bool visit[N];vector&lt;int&gt; edge[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    cin&gt;&gt;s1&gt;&gt;e1&gt;&gt;w1&gt;&gt;s2&gt;&gt;e2&gt;&gt;w2;    memset(dis,0x3f3f3f3f,sizeof(dis));        for(int i=1;i&lt;=n;i++)&#123;        memset(visit,0,sizeof(visit));        queue&lt;int&gt;que;        que.push(i);        visit[i] = 1;        dis[i][i] = 0;        while(!que.empty())&#123;            int cur = que.front();            que.pop();            for(auto j:edge[cur])&#123;                if(visit[j])continue;                dis[i][j] = dis[i][cur]+1;                visit[j] = 1;                que.push(j);            &#125;        &#125;    &#125;    if(dis[s1][e1]&gt;w1||dis[s2][e2]&gt;w2)&#123;        cout&lt;&lt;-1&lt;&lt;endl;        return 0;    &#125;    int ans = dis[s1][e1]+dis[s2][e2];    //O(n^2)枚舉所有共同邊    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[s2][i]+dis[i][j]+dis[j][e2]&lt;=w2)                ans = min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[s2][i]+dis[j][e2]);            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[e2][i]+dis[i][j]+dis[j][s2]&lt;=w2)                ans=min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[e2][i]+dis[j][s2]);                    &#125;    &#125;    cout&lt;&lt;m-ans&lt;&lt;endl;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]TIOJ 2180 勇者冒險(Adventure)","url":"/path2-8/","content":"TIOJ 2180 勇者冒險 (Adventure)\n題目連結Submission\n\n題目敘述給定一個地圖共 $R\\times C$ 行，接著會有 $M$ 行每一行都有一個座標和等級，代表經過這個座標需要多少等級才能通過。問從特定起點到終點所需要的最低的等級為多少。\n\n這題蠻特別的，他用到了Dijkstra中每一次都找最小的去更新，同時因為要求的是路徑上最大的等級為何，因此也用到了類似BFS的手法去擴展每一個座標。\n因為題目保證至少會有一條路徑通往起點與終點，同時我們每一次從queue拿出來的都是目前等級最低的點，因此如果碰到終點就可以確定這一條路線一定是需要等級最小的一條路徑！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int s1,s2,e1,e2;int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;void Dijkstra()&#123;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return;            &#125;            if(mp[nx][ny] == -1)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,-1,sizeof(mp));    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    Dijkstra();&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"[題解]最小花費的航空之旅","url":"/path2-9/","content":"最小花費的航空之旅\n\n題目敘述：給定很多種連接城市間的聯票，要求從起始站搭乘，可以在中途任意站下車，但下車以後就不能再次上車。輸入的第一行為一個正整數 n (1 ≤ n ≤ 20)，即聯票的種類數。以下 n 行每航為一個聯票的資訊，其中第一個整數為聯票的價格，然後是聯票上城市的數目。\n接下來為一個行程單的資訊，其中第一個正整數為行程單上的城市數目k（包括起始城市，2 ≤ k ≤ 10），以及這些城市的編號（按順序列出）。\n輸出最小花費和對應的方案的其中一組解。\n\n這一題是APCS Class的其中一題，難度頗高，因為他要找最短的路徑，同時增加了可以在任意站下車的條件。首先我們要維護每一個聯票的資訊，它的價值、起點、編號以及經過的城市。接著，我們考慮所有從起點出發的聯票，將每一種聯票上的每一個經過的城市都加入queue中。\n跟上一題一樣，當我們每一次都從cost最小的點下手，在轉移的過程中如果將所有的點都走訪一遍，則他的路徑必定是最短的，因為每一次的更新都是從花費最小的路徑去轉移。\n\n            使用自定義比較函數放入Priority_queue中Priority_queue中的比較函數需要使用到struct或class包覆的比較函數，若要回傳cost的最小值，則必須以大於來寫（有點像預設是pop出最大值，使用的卻是less的比較函數）struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;&#125;;\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,k,visit[20];struct Ticket&#123;    int id,cost;    vector&lt;int&gt; next_city;    //陣列ticket[i]存以i為起點&#125;;vector&lt;Ticket&gt; ticket[30];          //ticket[i] 起點為i的聯票struct node&#123;    int cost,cur_pos,visit_pos;    vector&lt;int&gt; used_ticket;    //cur_pos現在所在位置、visit_pos在行程單上位置&#125;;struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;    //讓priority_queue可以pop出最小的cost的路徑&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;        vector&lt;int&gt; temp;        rep(j,1,num-1)&#123;            int k;cin&gt;&gt;k;            temp.push_back(k);        &#125;        ticket[s].push_back(&#123;i,cost,temp&#125;);    &#125;    cin&gt;&gt;k;    rep(i,1,k)cin&gt;&gt;visit[i];        for(auto i : ticket[visit[1]])&#123;         //行程第一個起點的聯票起點        int p = 1;        for(auto j : i.next_city)&#123;            if(p &lt; k &amp;&amp; j == visit[p+1])p++;            pq.push(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);//            cout&lt;&lt;&quot;一開始聯票：&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    &#125;    while(!pq.empty())&#123;        node cur = pq.top();        pq.pop();        if(cur.visit_pos == k)&#123;            cout&lt;&lt;&quot;Cost = &quot;&lt;&lt;cur.cost&lt;&lt;&quot;, Tickets used: &quot;                &lt;&lt;cur.used_ticket[0];            for(int i=1;i&lt;cur.used_ticket.size();i++)                cout&lt;&lt;&quot;, &quot;&lt;&lt;cur.used_ticket[i];            cout&lt;&lt;endl;            break;        &#125;        for(auto i : ticket[cur.cur_pos])&#123;            vector&lt;int&gt; vec(cur.used_ticket);            vec.push_back(i.id);                //將現在使用的第i聯票推入            int p = cur.visit_pos;            for(auto j : i.next_city)&#123;                if(p &lt; k &amp;&amp; j == visit[p+1])p++;                pq.push(&#123;cur.cost+i.cost,j,p,vec&#125;);            &#125;        &#125;    &#125;&#125;\n","categories":["最短路徑題解"],"tags":["題解","最短路徑"]},{"title":"七橋問題、最短路徑問題及其延伸","url":"/path3/","content":"這篇文章的主題有以下：\n\n歐拉路徑、迴路（七橋問題）\n漢米頓路徑、迴路\n最短路徑演算法（Dijkstra,Bellman-Ford,Floyd-Warshall）\n旅行業務員問題（TSP）\n\n\n歐拉路徑、迴路（七橋問題）問題簡介\n七橋問題的描述是：該如何在所有橋都只能走一遍的前提下，把這個地方所有的橋都走遍（每條邊洽經過一次）？\n由數學歸納法得證，我們只要統計每個點的度數並記錄奇點的個數，只要大於二則不存在歐拉路徑。\n實作程序1. 判斷奇點個數，若奇點個數k：\n\nk &gt; 2，那麼無解\nk = 2，則選擇其中一個奇點作為起點\nk = 0，則選擇任意一個點作為起點\n\n2. DFS 執行下列步驟若當前節點還有尚未走過的邊，那麼拜訪該邊，並在拜訪完後輸出該邊，否則離開當前結點\n3. 若還有節點尚未拜訪，則無解4. 否則輸出順序即為一組解\n程式碼實作#include &lt;bits/stdc++.h&gt;#define N 501using namespace std;int n,Edge[N][N],ans[1025],ind = 0;void DFS(int cur)&#123;    for(int i=1;i&lt;=500;i++)&#123;        if(Edge[cur][i])&#123;            Edge[cur][i]--;Edge[i][cur]--;            DFS(i);        &#125;    &#125;    ans[ind++] = cur;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(Edge, 0, sizeof(Edge));    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        Edge[a][b]++;        Edge[b][a]++;    &#125;    int start = 1;                //開始的節點編號    for(int i=1;i&lt;=500;i++)&#123;        int sum = 0;        for(int j=1;j&lt;=500;j++)&#123;            sum+=Edge[i][j];        &#125;        if(sum%2!=0)&#123;             //找到第一個度數為奇數的節點            start = i;            break;        &#125;    &#125;    DFS(start);    for(int i=ind-1;i&gt;=0;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;&#125;\n旅行業務員問題（TSP）與漢米頓路徑問題描述\n漢米頓路徑是類似於歐拉路徑，但每一條邊恰好經過一次的限制變成點恰好經過一次，但此問題的難度比歐拉迴路高上好幾倍，為一個NP-Complete的問題。\n\n旅行商務員問題則是描述平面上n個城市，是否存在一條路徑將每一個點恰好走過一次後回到出發點。此問題為一個漢米頓迴路問題的經典問題。\n題目連結第一次寫TSP(Traveling Salesman Problem)，題目敘述如下：\n\n給定一系列城市和每對城市之間的距離，求解存取每一座城市一次並回到起始城市的最短迴路。\n\n實作程序我們透過位元的動態規劃，可以將原本$o(n!)$的時間複雜度變成以$O(n^2\\cdot 2^n)$的複雜度解決這個問題。\n這是一個已經被證明$NP-Hard$ 的問題，暴力作法是要檢查所有路徑的情況，因為共有n個點，每一個點又連接n-1個點，繼續下去總共會有N!種情況，因此複雜度為$O(n!)$。總共的點數共有n個，根據多邊形的邊數公式可以知道一共有$\\frac{n^2-n}{2}$條邊，每一條邊都有各自的距離。如果改用DP做，時間複雜度可以壓到時間複雜度$O(n^2\\cdot2^n)$，比$O(n!)$還優秀！這一題用到的是DP優化中的狀態壓縮，具體的實作細節如下：\n\n            位元運算在這一題需要用到位元運算，用16個bit表示每一個點有沒有被走訪過。用這樣的表示方法可以讓code更為節儉，也就是狀態壓縮的概念。左移運算子(&lt;&lt;)這一題會一直反覆被用到，1&lt;&lt;t代表把1往左移動t單位，用10進位表示就是$2^t$。每往左移動一格，數字就會變成原來的兩倍！狀態壓縮將十進位整數s以二進位表示，會得到一串01字串，假設s=10，則 $s = 1010_{(2)}$。以這題來說，這樣的字串我們可以用來表示第4和第2個點已經被拜訪，而第3跟第1個點還沒有被拜訪。\n          \n定義定義 $dp[n][s]$ 表示目前在第n點上，s為走過的點（狀態壓縮）的最短距離\n轉移式$dp[n][s] = min(dp[i][s-(1&lt;&lt;n)]+dis[i][n])$, for all i such that s&amp;(1&lt;&lt;i)!=0\n這個轉移式很有意思，因為s代表了每一個點是否有被走過，當我要更新dp[n][s]時，我要確保此時的狀態s中的點n必須為1。同時，因為1&lt;&lt;i用二進位表示只有第i位會是1其他都是0，做and運算就看s的第i位決定結果。\n對於每一個i必須確保第i點在狀態s中有被造訪，因此有了後面的條件。另外轉移式中的s-(1&lt;&lt;N)是把第n個點從未造訪的狀態轉移。\n邊界$dp[0][1] = 0,\\quad dp[i][j]= \\infty$\n距離的預設狀態為無限大，第一個點的初始狀態是最短距離0\n實作小細節迴圈順序在轉移的過程中，迴圈的第一層必須是狀態，第二層才是城市。如果顛倒過來的話，會導致前面的城市在狀態還沒有被更新的時候就已經失去了之後被更新的機會，因此城市的迴圈必須放在第二層！\n求答案因為我們要求的是回到原點的最短距離，因此在全部轉移完成之後，利用一個迴圈把回去原點的路的距離加上去，求得最小值。\n程式碼#include &lt;bits/stdc++.h&gt;#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,dis[20][20];cin&gt;&gt;n;    memset(dis,0,sizeof(dis));        for(int i=0;i&lt;n-1;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            cin&gt;&gt;dis[i][j];            dis[j][i] = dis[i][j];        &#125;    &#125;        int dp[N][66000],m = 1&lt;&lt;n;    memset(dp,0x3f3f3f3f,sizeof(dp));    dp[0][1] = 0;   //將0點到自己的距離設為1        //O(n^2 2^n)    for(int i=0;i&lt;m;i++)&#123;            //i表示2^n每一種狀態        for(int j=0;j&lt;n;j++)&#123;        //j表示城市            if(!(i&amp;(1&lt;&lt;j)))continue; //j城市要是被造訪過的狀態            for(int k=0;k&lt;n;k++)&#123;    //可以到的所有點中的狀態                if(i &amp; 1&lt;&lt;k)&#123;        //確保轉移過去的有被造訪過                    dp[j][i] = min(dp[j][i],dp[k][i-(1&lt;&lt;j)]+dis[j][k]);                &#125;            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)ans = min(ans,dp[i][m-1]+dis[i][0]);    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n最短路徑演算法Floyd-Warshall：全點對最短路徑(All Pairs)\n不支援負環\n\n想法：DP轉移（三個迴圈中點、起點、終點依序鬆弛）\n\n$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$\n如果改寫成定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路\n則轉移：$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$\n因此中間點k必須在最外層（不過有論文指出順序顛倒一樣可以得到正確解）\n優點：實作容易，缺點：時間 $O(v^3)$ 、無法處理負環（可處理負邊）\n\nDijkstra’s：單點源最短路徑\n優點：時間 $O(E+V^2)$、無法處理負邊\n\n想法：Greedy（和DP）\n\n維護：1. 未拜訪的節點集合$U$ 2. $d[i]$ 目前起點到 $i$ 最短路 3. 目前考慮節點 $p$\n重複以下動作直到u為空：\n對於所有與 $p$ 連接的節點 $q$，$d[q] = min(d[q],d[p]+weight[p][q])$\n當 $p$ 相鄰節點都走過：在 $u$ 中移除 $p$\n將 $p$ 更新成U中離起點距離最短的點 $min(d[j])$\n\n\n可以變成 $O((E+V)logV)$-&gt;邊較為稀疏的圖時有利（使用priority_queue）\n不能處理負邊，因為 $d[i]$ 較小的處理完之後就不會再更動了，加入負邊可能更小\n拿距離最小的點 $k$ 去更新其他點，不能保證更新後其他點一定是最短路\n上一步走完 $k$ 連接所有邊後，從集合 $U$ 中移除，因為沒有負邊， $k$ 必定是最短路\n\nDIJKSTRA(G, w, s)    INITIALIZE-SINGLE-SOURCE(G, s)      S &lt;- Ø      Q &lt;- V[G]      while Q ≠ Ø          do u &lt;- EXTRACT-MIN(Q)              S &lt;- S ∪ &#123;u&#125;              for each vertex v ∈ Adj[u]                  do RELAX(u,v,w)\nBellman-Ford：單點源最短路徑\n可以處理負環\n\n時間：$O(VE)$\n\n想法：Relax鬆弛\n一條邊 $\\delta(u,v)$ 滿足 $dis[v] = min(dis[v],dis[u]+weight[u][v])$\n對每一條邊進行鬆弛，因為鬆弛沒有按照最短路順序，因此要做V-1次\n此為暴力作法\n執行V-1次的worst case：\n剛好跟最短路徑的順序相反\n每次 Relax 後只能優化單一子路徑\n共有V個頂點，需要有V-1 條子路徑，每一次一條\n檢查負環：做完之後卻有滿足$d[v] &gt; d[u]+w(u,v)$ ，表示有負環\n\n\n\nBELLMAN-FORD(G,w,s)      INITIALIZE-SINGLE-SOURCE(G,s)      for i &lt;- 1 to |V[G]|-1          do for each edge (u,v)∈ E[G]              do RELAX(u,v,w)      for each edge (u,v)∈ E[G]          do if d[v] &gt; d[u]+w(u,v)              then return FALSE      return TRUE\n優化：SPFA(Shortest Path Faster Algorithm)\n每次只relax更新過的點\n\n使用queue優化，有點像BFS過程\n\n1.把起點 Push 到 Queue\n2.從 Queue 裡 Pop 出一筆資料\n3.該筆資料的所有邊進行 Relax\n4.有更新到的頂點再 Push 到 Queue\n5.重複步驟 2 ~ 4，直到 Queue 為空\n\n\n時間：$O(VE)$ -&gt;worst case，期望 $O(KE)$ ，K大概是2吧（反正挺快的）\n\nShortest-Path-Faster-Algorithm(G, s)      for each vertex v ≠ s in V(G)          d(v) := ∞      d(s) := 0      offer s into Q      while Q is not empty          u := poll Q          for each edge (u, v) in E(G)              if d(u) + w(u, v) &lt; d(v) then                  d(v) := d(u) + w(u, v)                 if v is not in Q then                     offer v into Q\nDAG Shortest Path首先對所有點進行拓墣排序，花上時間 $O(V+E)$，接著對每一條邊進行鬆弛，時間$O(E)$，因此總時間複雜度是 $O(V+E)$。這個時間複雜度是很快的，但相對的限制也非常多，除了不能有負邊與負環之外，更不能有正環在其中，否則不能進行拓墣排序（在之前筆記進階圖論（一）有提到，也就是這一中圖必須是DAG(Directed Acyclic Graph)！\n一個有趣的應用：PERT\n延伸筆記\n最短路徑問題\n進階圖論（一）\n最短路徑例題\n\n","categories":["數學筆記"],"tags":["數學","離散數學","多元選修"]},{"title":"最短路徑例題（Shortest Path Problem）","url":"/path2/","content":"題目目錄\n可魚果運輸問題\n百慕達三角洲\n江神與他的小火車\n貨物運送計劃\nE.漢米頓的麻煩\n旅遊規劃問題\nCodeforces 543B: Destroying Roads\n\n\n可魚果運輸問題題目連結Dijkstra’s AlgorithmSPFA這一題的來源是NPSC2013的題目，題目大意如下：\n\n有n個城市m個運輸方案，每個方案 $P_i$ 會從一個固定的起始城市 $A_i$ 運送東西到另一個固定的終點城市 $B_i$，每運輸一件物品，就必須付 $C_i$ 價錢。若用方案 $P_i$ 運輸了超過 $D_i$ 件物品，多出來的部份每件物品收 $C_i’$ 元。共要運輸 $f$ 物品。求起點 $s$ 到終點 $e$ 的最短路徑。\n\n當運輸總量超過 $D_i$ 件物品，表示可以使用更小的邊權重去計算接下來的費用。這時候我們可以了解到一個性質，如果我把全部的物品全部集中在一條路徑運送，因為送的越多，相對的在費用上就可能產生優惠，比分散多條路徑的運送花費來的小。因為總共要運送 $f$ 件物品，因此會將邊的權重設定為當 $f$ 件物品都經過這一條邊時，所要花費的價格。\n有了邊以及價格之後，便可開始進行最短路徑的演算法。因為題目範圍 $N≤100$ ，因此用Dijkstra’s 或是 SPFA 都可以做（Bellman-Ford就先不要XD）。\nDijkstra’s Algorithm這篇有一篇論文是Dijkstra在針對最短路徑寫的論文（也就是以他名字命名的演算法論文），這篇只有三頁耶！以下是「演算法導論」這本書中演算法的虛擬碼：\nDIJKSTRA(G, w, s)  1  INITIALIZE-SINGLE-SOURCE(G, s)  2    S &lt;- Ø  3    Q &lt;- V[G]  4    while Q ≠ Ø  5        do u &lt;- EXTRACT-MIN(Q)  6            S &lt;- S ∪ &#123;u&#125;  7            for each vertex v ∈ Adj[u]  8                do RELAX(u,v,w)\n其中集合 $S$ 在程式碼中代表的是visit，而集合 $Q$ 因為要操作取出最小元素的動作，因此會用priority_queue實現，以heap來進行 $O(\\log n)$ 的插入以及取出。\n這裡面使用$visit$判斷是否在集合 $S$ 中，但我們可以發現，如果在priority_queue中有兩個點的存在，第一個點處理完被加入集合 $S$ 中之後，第二次再次被拿出來進行處理時就不會有任何相鄰的點再一次被處理，這是因為第一次與第二次更新所使用的 $dis[cur]$ 是一樣的。因此，當一個點已經在visit中（也就是在集合 $s$ 中），我們可以直接換下一個點去執行（不過如果忘了visit也是沒差啦）。\n\n            複雜度分析以下分析一下演算法時間複雜度，總共有兩個時間複雜度，取決於使用何種資料結構來實作。1. 時間複雜度 $O(V^2+E)$首先是每一個點執行 $V$ 次對每一個相鄰的點進行更新，每一輪執行 $O(V)$ 尋找目前距離 $dis$ 最小的點。總共有 $E$ 條邊需要更新，因此最後要把 $E$ 再加上去。這樣總複雜度就會 $V\\times O(V)+O(E) = O(V^2+E)$。此實作方式一般在稠密的圖中會有比較好的表現。2. 時間複雜度 $O((V+E)\\log V)$這一題在 $O(n)$ 爆搜尋找改用heap去優化，因此複雜度就會是一樣執行V 輪利用 $O(logV)$ 找到距離 $dis$ 最小的點，同時將更新後的點放進heap中，我們知道放入heap的複雜度也是 $O(\\log n)$，因此複雜度就會變成 $O(V\\log V)+O(E\\log V) = O((V+E)\\log V)$。此實作方式一般在稀疏的圖中會有比較好的表現，從 $V$ 與 $E$ 的大小估計可以大致發現。\n          \n以下是程式法的實作，最需要注意的地方是pair的first跟second儲存的東西。在存圖時會使用（點,權重）搭配vector；而在priority_queue中，因為要對權重進行比較，因此會用（權重,點），需要特別注意別搞混了!\n\n            Priority_Queue實作細節預設的priority_queue會pop出目前heap中最大的元素（預設是less&lt;&gt;函數），如果要實作一個min heap 的話要使用greater&lt;&gt;函數，同時第二個傳進函數的參數要用一個vector！priority_queue &lt;Type, vector&lt;Type&gt;, ComparisonType &gt; min_heap;priority_queue &lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;   \n          \n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //存圖    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //城市數n、方案數m、s起、e終、f箱數    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //一條由a連到b的邊，權重c，流量超過d，則改權重c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //Dijkstra    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;    //(距離,點)    pq.push(&#123;0,s&#125;);    dis[s] = 0;        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;                        if(dis[cur]+weight&lt;dis[next])&#123;                dis[next] = dis[cur]+weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;        visit[cur] = 1;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nShortest Path Faster Algorithm(SPFA)這是一個使用queue最佳化的Bellman-Ford演算法，基本的使用方式跟BFS幾乎相同，在Bellman-Ford對邊進行更有效率的鬆弛(relaxation)。以下一樣是「演算法導論」中Bellman-Ford的虛擬碼：\nBELLMAN-FORD(G,w,s)  1    INITIALIZE-SINGLE-SOURCE(G,s)  2    for i &lt;- 1 to |V[G]|-1  3        do for each edge (u,v)∈ E[G]  4            do RELAX(u,v,w)  5    for each edge (u,v)∈ E[G]  6        do if d[v] &gt; d[u]+w(u,v)  7            then return FALSE  8    return TRUE\n以下是SPFA的虛擬碼，如果節點有被實際鬆弛過，且節點不在queue中（同樣元素在queue中出現兩次沒有意義，因為只要確保有在queue中等會會被更新到就好，到它的最短距離不會被改變），便將此節點推入queue中。裡面存的是帶進行鬆弛的節點們，也就是被剛剛更新過的節點。我們可以利用$visit[ ]$來 $O(1)$ 判斷節點是否有在queue中！\n有進行判斷是否在queue中的（比較省空間一點）：沒有進行判斷的，有被更新過就塞進去：\nShortest-Path-Faster-Algorithm(G, s)  1    for each vertex v ≠ s in V(G)  2        d(v) := ∞  3    d(s) := 0  4    offer s into Q  5    while Q is not empty  6        u := poll Q  7        for each edge (u, v) in E(G)  8            if d(u) + w(u, v) &lt; d(v) then  9                d(v) := d(u) + w(u, v) 10                if v is not in Q then 11                    offer v into Q\nSPFA有一個問題，他可以被出題目的人設計測資去卡這種算法，使時間複雜度變成糟糕的$O(V^2)$，因此一般來說會實作Dijkstra而非SPFA！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //存圖    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //城市數n、方案數m、s起、e終、f箱數    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //一條由a連到b的邊，權重c，流量超過d，則改權重c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //SPFA        queue&lt;int&gt; que;    que.push(s);    dis[s] = 0;    visit[s] = 1;        while(!que.empty())&#123;        int cur = que.front();        que.pop();        visit[cur] = 0;                //pop出來將狀態改成不在queue中        for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur]+weight)&#123;                dis[next] = dis[cur]+weight;                if(!visit[next])que.push(next);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n百慕達三角洲題目連結\n\n題目大意：給定一張長n寬m的矩形圖，由”#”和”.”組成，給定起點$(x_1,y_1)$以及終點$(x_2,y_2)$，必須最小化經過”.”的次數，求最少需幾過幾次。\n\n當下看到這一個題目的想法，就是跟處理一般的圖論題目一樣，將邊用vector儲存起來，將經過”.”的權重設為很大的一個數字，這樣用Dijkstra做一次最短路徑就可以找出經過”.”最小化的次數了！\n以下是MLE的Submission吃了開心的MLE，如果當成一般的圖在處理，不管是在 $dis$ 開long long的處裡，或是開了一個vector陣列儲存邊，都非常的消耗空間。因此，我詢問了一下電神這一題的想法，他說我的想法用Dijkstra是正確的，不過在設定邊權的部分可以直接用0跟1代替，而且可以用queue去輔助實作BFS（要說它也可以是Dijkstra的另一種比較簡單的版本）。\n\n這題也就是所謂0-1 BFS (Shortest Path in a Binary Weight Graph)，或是這裡0-1 BFS，想法可以說是Dijkstra跟BFS的綜合（其實它跟SPFA也很相似）。以下是實作步驟：\n\n建立雙向的佇列(deque)，等等要存放被relax過的點，初始放入起點\n每一次從deque前方pop出一點，對那一點相鄰的所有點進行鬆弛\n如果被鬆弛時的邊權重為0，將點push dequeue的前方\n否則當鬆弛時的邊權重為1，將點push dequeue的後方\n重複執行2-4步驟直到deque為空\n\n當我們一直利用deque最前端的元素進行鬆弛，因為我們將邊權為0的元素放入最前端，用距離最小的那些點進行鬆弛，每一個點最多會被鬆弛一次，因此總時間複雜度為$O(V+E)$，比起用Dijktra直接做$O((V+E)\\log V)$快了許多（此演算法之所以正確是因為其中一邊的權重是0，不管0接到誰他的權重也都是0，有點像「從最小層逐漸擴展」的概念）！\n\n            小問題（出處這裡）Can we apply the same trick if our edge weights can only be 0 and x (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and x+1 (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and y (x,y &gt;= 0) ?解答YES,NO,NO\n          \n這題之所以可行是因為有一邊的權重是0，當點皆以權重為0串再一起時，他會是最短的，使用最短去更新接下來的點，因此第一題是正確的！但第二題與第三題是錯誤的，考慮以下點與邊的情況：\n\n當我依照01BFS的方法不斷去用x更新其他的點，更新完之後會發現點1到點3的最短路徑應該是x+1，到時候又要再重新Relax一次，複雜度會爆炸喔（比SPFA可能還慘，因為當點三利用兩個x更新完之後，用它來做跟3所有相鄰的點，做完卻發現$(1,3)$有更短的距離，又必須重新全部更新一次！）總結來說，他只是用於只有兩種邊的情況，且其中一邊必須為0。\n\n\n            比較一下記憶體用量最主要還是時間複雜度的比較，不過既然空間已經爆了，時間也沒法比了QQMLE#define N 2005#define N2 4000005int n,m,q,predecessor[N2],dis[N2];bool visit[N2],maze[N2];vector&lt;pii&gt;edge[N2];AC#define N 2003int n,m,dis[N][N];bool visit[N][N],maze[N][N];\n          \n以下是使用deque實作01BFS的AC code：\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 2003#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N],maze[N][N];void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    memset(visit,0,sizeof(visit));    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    deque&lt;pii&gt;deq;    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    memset(dis,0x3f3f3f3f,sizeof(dis));    dis[s1][s2] = 0;    deq.push_back(&#123;s1,s2&#125;);    while(!deq.empty())&#123;        int x = deq.front().first,y = deq.front().second;        deq.pop_front();        for(int i=0;i&lt;4;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;                        if(dis[nx][ny] &gt; dis[x][y]+maze[nx][ny])&#123;                dis[nx][ny] = dis[x][y]+maze[nx][ny];                if(maze[nx][ny]==0)deq.push_front(&#123;nx,ny&#125;);                else deq.push_back(&#123;nx,ny&#125;);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e1][e2]&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n江神與他的小火車題目連結\n\n題目大意已知有N個點以及M條邊，總共有Q筆詢問，每筆詢問有$\\delta(a,b)$，表示新增一條由 $a$ 指向 $b$ 的邊（其權重為1），對每一筆詢問輸出從點 $1$ 到點 $N$ 的最短距離。\n\n\n我們知道如果有用新加進來的邊 $\\delta(a,b)$，則路徑可以被拆解成 $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$。其中，我們可以用Dijkstra 一次尋找1到任何點的最短距離，那要如何處理路徑 $\\delta(b,n)$ 呢？這就是單一目的最短距離問題，我們可以將所有的邊逆序，將終點做一次Dijkstra尋找最短路，這時候我們就可以用 $O(1)$ 的時間回答每一筆詢問，總時間複雜度：預處理$O((V+E)\\log V)$，詢問 $O(Q)$。\n\n            測資小問題有一筆測資如下，藍線是給定的路徑與權重，紅色是新加入的邊，如果按照上面 $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$ 我們可以計算出從起點到終點的最短距離為：$2+1+4 = 7$，很明顯兩點之間的最短距離是 $5$ ，但因為原本作法會經過一條$\\delta (B,C)$ 的重邊，造成算出來的距離是比較大的！這時候我們只要對最短路徑長度取min即可，也就是說在這種情況加入這一條邊並不會影響最短路徑的長度！測資（1,2,3分別對應A,B,C）：6 5 11 2 12 3 13 4 14 5 15 6 13 2\n          \n接下來是程式碼，之後如果遇到最短路徑的題目，一般來說會避免使用SPFA（除非有負邊），為了要避免最糟的時間複雜度，因此會使用Dijkstra來處理最短路徑問題！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,q;bool visit[N];vector&lt;pii&gt; edge[2][N];//edge[0]-&gt;normal,edge[1]-&gt;oppositevector&lt;int&gt; Dijkstra(int start,int end,bool is_nor)&#123;    memset(visit,0,sizeof(visit));    vector&lt;int&gt; dis(n+2,1e16);        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;        dis[start] = 0;    pq.push(&#123;0,start&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                visit[cur] = 1;        for(auto i : edge[is_nor][cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur] + weight)&#123;                dis[next] = dis[cur] + weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    return dis;&#125;void solve()&#123;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=0;i&lt;m;i++)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[0][a].push_back(&#123;b,w&#125;);        edge[1][b].push_back(&#123;a,w&#125;);    &#125;        vector&lt;int&gt; normal,opposite;    normal = Dijkstra(1,n,0);    opposite = Dijkstra(n,1,1);        while(q--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        cout&lt;&lt;min(normal[a]+opposite[b]+1,normal[n])&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n貨物運送計劃題目連結\n\n題目敘述給定N個點M條邊，第i條邊有方邊率$C_i$，假設目前運送貨物重量p經過此邊，代表經過邊i會需要多增加 $p\\times C_i$ 的重量。給定起點、終點，求到達終點時最少的貨物重量為多少。\n\n換種說法，題目要求的是每經過一條邊，就要乘上某一個數，要求到終點最小的重量。下圖是題目範例測資：\n$\\delta(1,2)\\to\\delta(2,3)$，所付出的代價是$(1\\times (1+1))\\times (2+1)=6$。如果是$\\delta(1,3)$ 的話直接$1\\times (4+1)=5$，可以觀察到，遇到邊就需要將原本的數字乘上$C_i+1$。\n我們可以透過將邊權取 $\\log$ 之後，就可以利用Dijkstra進行最短路徑的計算，因為取 $\\log$ 後的加減運算等同於原本的乘法運算，只要最後把算出來的答案次方即可！\n這一題的輸出要求科學記號（為了要避免浮點數誤差），以下程式碼來達成（要求小數點後兩位，同時次方部分要求整數3位）：\nprintf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);\n程式碼的部分，透過$edge$存完所有的取完 $\\log$ 之後的邊，進行Dijkstra，輸出最短路徑（以科學記號表示）即可！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s,t;double dis[N];bool visit[N];vector&lt;pid&gt; edge[N];void solve()&#123;    memset(visit,0,sizeof(visit));        scanf(&quot;%lld %lld %lld %lld&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=0;i&lt;m;i++)&#123;        int a,b;double c;scanf(&quot;%lld %lld %lf&quot;,&amp;a,&amp;b,&amp;c);        edge[a].push_back(&#123;b,(double)log10(c+1)&#125;);    &#125;    fill(dis,dis+n+2,1e16);        priority_queue&lt;pdi,vector&lt;pdi&gt;,greater&lt;pdi&gt;&gt; pq;    dis[s] = 0.0;    pq.push(&#123;0,s&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;        visit[cur] = 1;                for(auto i:edge[cur])&#123;            int next = i.first;            double w = i.second;            if(dis[next] &gt; dis[cur]+w)&#123;                dis[next] = dis[cur]+w;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    double ans = dis[t];    int x = floor(ans);    ans-=x;        printf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);&#125;signed main()&#123;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nE.漢米頓的麻煩題目連結\n他題目時不時提到漢米頓，是多愛漢米頓XDD（這一題跟漢米頓根本沒關係）\n\n題目大意在一張n(n≤100)個點的圖中，尋找路徑長度最短的環\n\n那就用Floyd-Warshall找最小的環就好！\n\n            Floyd-Warshall這就是dp的作法，用 $O(N^3)$ 的時間進行轉移，就能得到全點對的最短路徑。這邊有一個重要的轉移順序，也就是中點-起點-終點進行轉移，如果把dp展開就會發現中點必須在最外層進行轉移：定義 $dp[k][i][j]$ 為點 $i$ 走到點 $j$ ，只能經過前k個點的最短路徑，則轉移式變成：d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])每一個k+1都是由k轉移而來，仰賴k的點的配對，因此必須最先轉移中點k的部分！（不過順序顛倒也不會怎樣啦，上面「課程內容」的地方有寫到）\n          \n同樣這一份code也可以判斷有沒有負環，只要ans小於0的話代表有負環（有的話距離是不能用的喔，因為Floyd-Warshall不能處理負環，但負邊是可以處理的）\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 101#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,dp[N][N];void solve()&#123;    memset(dp,0x3f3f3f3f,sizeof(dp));    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            int temp;cin&gt;&gt;temp;            if(temp!=0)dp[i][j] = temp;        &#125;    &#125;    for(int k=0;k&lt;n;k++)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)&#123;        ans = min(ans,dp[i][i]);    &#125;    if(ans == INT_MAX)cout&lt;&lt;-1&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        solve();    &#125;&#125;\n旅遊規劃問題題目連結Submission這一題 $n≤13$ 大概就是位元dp來完成（狀態壓縮），定義 $dp[i][j]$ 為現在在點i上，拜訪過點集j的最短距離（j中不包含點i）。這裡使用到了同層轉移的技巧，也就是利用j中的點，對相同狀態下不在i中的點進行更新。\n點集j中在狀態i下為起點，用Dijkstra對不在i中的其他點進行更新，最後的答案即為$dp[s][S-(1&lt;&lt;s)]$。\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m;vector&lt;pii&gt; edge[N];int dis[N],dp[N][1&lt;&lt;N],pre[N][1&lt;&lt;N];bool visit[N];//定義dp[i][j]為現在在點i，拜訪過點集合j（i不在點集j中）signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    rep(i,1,m)&#123;                                 //讀入m條邊        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    int S = 0,start = -1;cin&gt;&gt;m;                //S為待拜訪的所有點集合    rep(i,1,m)&#123;        int temp;cin&gt;&gt;temp;        S = S|(1&lt;&lt;temp);        if(start == -1)start = temp;    &#125;        rep(i,0,n)rep(j,0,(1&lt;&lt;n))dp[i][j] = INF;    rep(i,0,n)dp[i][0] = 0;        for(int i=1;i&lt;(1&lt;&lt;n);i++)&#123;        if(i == (S &amp; i))&#123;                       //在集合i中的點在S一定要有            priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;            fill(dis,dis+n,INF);                //將dis初始為無限大，做Dijkstra            memset(visit,0,sizeof(visit));            for(int j=0;j&lt;n;j++)&#123;                if(i&amp;(1&lt;&lt;j))&#123;                   //從有在i中的點向不在的點做Dijkstra                    dis[j] = dp[j][i^(1&lt;&lt;j)];   //目前在j，經過拜訪了點集i（不包含點j）                    pq.push(&#123;dis[j],j&#125;);        //利用在i中的點對其他點進行更新                &#125;            &#125;            while(!pq.empty())&#123;                int cur = pq.top().second;                pq.pop();                visit[cur] = 1;                for(auto k : edge[cur])&#123;                    int v = k.first,w = k.second;                    if(i&amp;(1&lt;&lt;v))continue;                    if(dis[v] &gt; dis[cur]+w)&#123;                        dis[v] = dis[cur] + w;                        pre[v][i] = cur;        //紀錄點v在狀態i下由cur轉移                        pq.push(&#123;dis[v],v&#125;);                    &#125;                    else if(dis[v] == dis[cur]+w &amp;&amp; pre[v][i] &gt; cur)&#123;                        pre[v][i] = cur;                    &#125;                &#125;            &#125;            for(int j=0;j&lt;n;j++)&#123;               //對於不在點集i中的點進行更新                if(i &amp; (1 &lt;&lt; j))continue;                dp[j][i] = dis[j];              //同層狀態轉移，更新dp[j][i]            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;Minimum travel distance: &quot;&lt;&lt;dp[start][S^(start)]&lt;&lt;endl;    cout&lt;&lt;&quot;Travel route:&quot;;    int cur = start;S = S^(1&lt;&lt;start);    while(true)&#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;cur;        if(!S)break;        cur = pre[cur][S];        if(S&amp;(1&lt;&lt;cur))S = (S^(1&lt;&lt;cur));         //經過的點不一定是指定的觀光點    &#125;    cout&lt;&lt;endl;&#125;\nCodeforces 543B: Destroying Roads題目連結Submission\n\n題目大意給定N個點M條無向邊，每一邊權重都是1，以及兩筆資料，由三個數$(x,y,w)$ 構成，代表起點為x、終點為x、要在w距離內從起點走到終點。試問最多可以拔掉幾條邊同時滿足以上兩個資料所描述的特性？\n\n這一題蠻有趣的，首先他的邊權重都是1，因此我們可以直接用BFS尋找最短路徑，並且點第一次拜訪到時的就是該點的最短距離（BFS一層一層擴展）。\n\n            第一個想法：錯誤想法我先將兩個起點與終點的最短路徑都找出來，把將過的邊都標上不能移除，將其他的邊全部拔掉。問題點：固然找到的是最短路徑，但不代表可以最大化拔除邊的數量。因為題目要求兩點只要符合最短距離 $w$ 即可，因此每一個配對其實不用符合是最短路徑的情況（如下圖）！目標是在題目要求的限度內最大化重複的邊，使能夠被拔除的邊最大化！上圖紅色線段是$\\delta(1,7)$的最短路徑、褐色是線段$\\delta(3,6)$的最短路徑、黑色線段是皆以最短路徑之下可以被拔除的邊。但是如果將路徑$\\delta(3,6)$換成是$(3,2)\\to(2,4)\\to(4,5)\\to(5,6)$，被拔除的邊可以增過為三條。\n          \n這一題最重要的關鍵就是以$O(V^2)$枚舉所有點對（距離長度可以直接換算成邊的數量），可以先用$O(V(V+E)$的時間對每一個點用進行BFS，如此一來總複雜度即為$O(V^2+VE)$，所幸題目給定總共的邊數不會超過3000條，因此是可以在時間限制內完成枚舉。\n\n            枚舉路徑 $\\delta(i,j)$ 為共同邊的時候，必須考慮起點與終點的方向，同時考慮從 $i\\to j$ 以及從 $j\\to i$ 兩個方向。以下圖為例，當枚舉都使用相同的起點以及終點，會讓下圖的 $(3,4)$ 被重複計算！\n          \n以下是AC程式碼：\n#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 3005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s1,e1,w1,s2,e2,w2,dis[N][N];bool visit[N];vector&lt;int&gt; edge[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    cin&gt;&gt;s1&gt;&gt;e1&gt;&gt;w1&gt;&gt;s2&gt;&gt;e2&gt;&gt;w2;    memset(dis,0x3f3f3f3f,sizeof(dis));        for(int i=1;i&lt;=n;i++)&#123;        memset(visit,0,sizeof(visit));        queue&lt;int&gt;que;        que.push(i);        visit[i] = 1;        dis[i][i] = 0;        while(!que.empty())&#123;            int cur = que.front();            que.pop();            for(auto j:edge[cur])&#123;                if(visit[j])continue;                dis[i][j] = dis[i][cur]+1;                visit[j] = 1;                que.push(j);            &#125;        &#125;    &#125;    if(dis[s1][e1]&gt;w1||dis[s2][e2]&gt;w2)&#123;        cout&lt;&lt;-1&lt;&lt;endl;        return 0;    &#125;    int ans = dis[s1][e1]+dis[s2][e2];    //O(n^2)枚舉所有共同邊    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[s2][i]+dis[i][j]+dis[j][e2]&lt;=w2)                ans = min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[s2][i]+dis[j][e2]);            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[e2][i]+dis[i][j]+dis[j][s2]&lt;=w2)                ans=min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[e2][i]+dis[j][s2]);                    &#125;    &#125;    cout&lt;&lt;m-ans&lt;&lt;endl;&#125;\nTIOJ 2180 勇者冒險 (Adventure)題目連結Submission\n\n題目敘述給定一個地圖共 $R\\times C$ 行，接著會有 $M$ 行每一行都有一個座標和等級，代表經過這個座標需要多少等級才能通過。問從特定起點到終點所需要的最低的等級為多少。\n\n這題蠻特別的，他用到了Dijkstra中每一次都找最小的去更新，同時因為要求的是路徑上最大的等級為何，因此也用到了類似BFS的手法去擴展每一個座標。\n因為題目保證至少會有一條路徑通往起點與終點，同時我們每一次從queue拿出來的都是目前等級最低的點，因此如果碰到終點就可以確定這一條路線一定是需要等級最小的一條路徑！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int s1,s2,e1,e2;int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;void Dijkstra()&#123;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return;            &#125;            if(mp[nx][ny] == -1)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,-1,sizeof(mp));    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    Dijkstra();&#125;\n最小花費的航空之旅\n題目敘述：給定很多種連接城市間的聯票，要求從起始站搭乘，可以在中途任意站下車，但下車以後就不能再次上車。輸入的第一行為一個正整數 n (1 ≤ n ≤ 20)，即聯票的種類數。以下 n 行每航為一個聯票的資訊，其中第一個整數為聯票的價格，然後是聯票上城市的數目。\n接下來為一個行程單的資訊，其中第一個正整數為行程單上的城市數目k（包括起始城市，2 ≤ k ≤ 10），以及這些城市的編號（按順序列出）。\n輸出最小花費和對應的方案的其中一組解。\n\n這一題是APCS Class的其中一題，難度頗高，因為他要找最短的路徑，同時增加了可以在任意站下車的條件。首先我們要維護每一個聯票的資訊，它的價值、起點、編號以及經過的城市。接著，我們考慮所有從起點出發的聯票，將每一種聯票上的每一個經過的城市都加入queue中。\n跟上一題一樣，當我們每一次都從cost最小的點下手，在轉移的過程中如果將所有的點都走訪一遍，則他的路徑必定是最短的，因為每一次的更新都是從花費最小的路徑去轉移。\n\n            使用自定義比較函數放入Priority_queue中Priority_queue中的比較函數需要使用到struct或class包覆的比較函數，若要回傳cost的最小值，則必須以大於來寫（有點像預設是pop出最大值，使用的卻是less的比較函數）struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;&#125;;\n          \n以下是AC Code：\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,k,visit[20];struct Ticket&#123;    int id,cost;    vector&lt;int&gt; next_city;    //陣列ticket[i]存以i為起點&#125;;vector&lt;Ticket&gt; ticket[30];          //ticket[i] 起點為i的聯票struct node&#123;    int cost,cur_pos,visit_pos;    vector&lt;int&gt; used_ticket;    //cur_pos現在所在位置、visit_pos在行程單上位置&#125;;struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;    //讓priority_queue可以pop出最小的cost的路徑&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;        vector&lt;int&gt; temp;        rep(j,1,num-1)&#123;            int k;cin&gt;&gt;k;            temp.push_back(k);        &#125;        ticket[s].push_back(&#123;i,cost,temp&#125;);    &#125;    cin&gt;&gt;k;    rep(i,1,k)cin&gt;&gt;visit[i];        for(auto i : ticket[visit[1]])&#123;         //行程第一個起點的聯票起點        int p = 1;        for(auto j : i.next_city)&#123;            if(p &lt; k &amp;&amp; j == visit[p+1])p++;            pq.push(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);//            cout&lt;&lt;&quot;一開始聯票：&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    &#125;    while(!pq.empty())&#123;        node cur = pq.top();        pq.pop();        if(cur.visit_pos == k)&#123;            cout&lt;&lt;&quot;Cost = &quot;&lt;&lt;cur.cost&lt;&lt;&quot;, Tickets used: &quot;                &lt;&lt;cur.used_ticket[0];            for(int i=1;i&lt;cur.used_ticket.size();i++)                cout&lt;&lt;&quot;, &quot;&lt;&lt;cur.used_ticket[i];            cout&lt;&lt;endl;            break;        &#125;        for(auto i : ticket[cur.cur_pos])&#123;            vector&lt;int&gt; vec(cur.used_ticket);            vec.push_back(i.id);                //將現在使用的第i聯票推入            int p = cur.visit_pos;            for(auto j : i.next_city)&#123;                if(p &lt; k &amp;&amp; j == visit[p+1])p++;                pq.push(&#123;cur.cost+i.cost,j,p,vec&#125;);            &#125;        &#125;    &#125;&#125;\n","categories":["C++進階主題","最短路徑"],"tags":["2021暑期筆記","2020資訊之芽"]},{"title":"九宮格匡列機率討論","url":"/quarantine/","content":"最近推出了新的隔離政策，班上只要有人確診，他位置附近的九宮格內的人都必須被匡列。雖然這個隔離方式本來就怪怪的，不過我們還是可以針對被隔離的機率做一些小小的計算！\n為了計算方便，都是限制在正方形的座位排列下，對9人、16人、25人或36人的情況做討論，且每一個人確診機會是相同的。這篇文章總共分為三個部分，首先是在固定確診人數下，討論不同位置的隔離機率。接著是討論確診人數與全班都被隔離的機率關係。最後，要討論的是讓全班停課所需最少人數的期望值。\n\n一、不同座位的隔離機率問題描述：某班有36個同學，座位是6x6的方格排列，試問當班上有4個同學確診，不需要被隔離的機率有多少？\n問題觀察與推導一開始看到題目可能會遇到一個大問題，在不同座位的確診者被隔離的人數也就不同。以下圖為例，坐在角落只需要匡列三個人，而坐在靠邊以及中間的人若確診則需要匡列五人以及八人，換句話說，做靠邊或角落的人比起中間的人越不容易被匡列隔離。接下來針對不同位置分別進行討論。\n\n座位在角落情況我們將坐在角落而不被匡列的機率設為$P_c$。此人被匡列的情況可以分為三種，也就是他周圍三個位置分別有一、二或三人確診，針對這三種情形我們可以列出以下算式：\nP_c = 1 - \\frac{C^3_1C^{32}_3+C^3_2C^{32}_2+C^3_3C^{32}_1}{C^{35}_4}\\approx 0.6868從他隔壁的3個位置取一到三個位置作為確診者，剩下的確診者從 $36-4=32$ 個位置任選其中幾個。\n座位靠邊、中間情況這兩種情況的機率$P_e,P_m$也可以用一樣的方式算出來，但其實有點麻煩因為有四種情況要列出來。偶然發現，其實用反面作法還蠻麻煩的，用正面做其實快很多！只要附近的位置數量扣掉，讓剩下的位置安排確診者，取一次C就完成了！\nP_e = \\frac{C^{30}_4}{C^{35}_4} \\approx 0.5234中間$P_m$的情況：\nP_m = \\frac{C^{27}_4}{C^{35}_4} \\approx 0.3352有了$P_c,P_e,P_m$之後，對於原題隨機位置下的機率，由於每一個位置出現的機率相等，便可透過各個位置的數量進行加權平均，得到隨機情況下的機率。\n\\begin{align}P &= \\frac{1}{36}(4P_c+16P_e+16P_m)\\\\\n&\\approx 0.4579\\end{align}程式機率計算程式碼連結模擬結果連結\n一開始在還沒有想出問題的解之前，想說先用程式暴力驗證看看機率為何。總共的組數是 $C^{36}_4 = 58905$ 種情況，透過枚舉每一種情況健康的人數，算出在一個人沒有確診情況下不被匡列隔離的機率。\n\n隨機坐不被匡機率：0.457898 ,次數：58905\n\n看到這個結果可以大概推知，當班上有四個人確診，則班上的人其實有超過一半的機會要被隔離。這就讓我進一步思考到，班上座位有些跟周圍接觸到的人較多、有些較少，那這些是否會影響到被匡列的機率？由於每一個人確診的機會是一樣的，因此就把情況分為三種，分別是角落、靠邊以及中間，而相同情況下接觸的人數是一樣多的，隨便取一個位置進行觀察即可。\n由於要排除自己確診的情況，總共的組合數會是 $C^{35}_4 = 52360$，不被匡列的機率如下：\n\n坐角落不被匡機率：0.686784 ,次數：52360坐靠邊不被匡機率：0.523396 ,次數：52360坐中間不被匡機率：0.335180 ,次數：52360\n\n\n如上圖，分別挑位置是(1,1),(2,3),(2,4)的人進行觀察，不用匡列機率則是以健康人數（上圖H）除上非確診人數（上圖H+Q）。\n二、確診人數與全班隔離機率3x3排列情況4x4排列情況程式碼連結\n轉換一下問題的面向，我們把確診者的數量當作其中一個變因，試著討論確診人數與全班隔離的機率關係。對於一個有$n$人的班級，總共的排列數為$2^n$，我們將全班都會被隔離的情況挑出來，統計其數量。\n3x3排列情況下圖橫坐標為確診人數，縱座標為對應的組數，灰色則是該確診人數的組合數。可以發現到，當人數增加，其全班隔離的組數呈現先增後減的趨勢，而對應到的全班被隔離的機率（紅與灰長度比）隨確診人數漸增。折線圖的部分則代表在相同確診人數下全班被隔離組數佔組合數的比例。\n\n期望值：在全班被匡列的情況下，此情況的確診人數的期望值為：4.88249人\n4x4排列情況\n\n期望值：在全班被匡列的情況下，此情況的確診人數的期望值為：8.5333人\n5x5排列情況\n期望值：在全班被匡列的情況下，此情況的確診人數的期望值為：13.1412人\n程式具體的實作細節是將每一種情況進行狀態壓縮，存在一個int裡面，然後對每一個bit進行枚舉。在人數為$n$人的情況下，複雜度為$2^n$。這樣的複雜度在枚舉36人的情況會需要10幾個小時才能跑完。嘗試使用dfs進行剪枝，減少實際判斷的次數，不過效果不盡理想，可能還是要針對複雜度的部分進行優化才行。\n三、讓全班停課所需最少人數期望值程式碼連結\n第二部分是將所有可能造成全班被匡列的情況都找出來，但這並不是「讓全班停課所需最少人數的期望值」，因為它的前提被限制在所有人都全班都被匡列的前提之下，且會有很多情況是要被扣除掉的。要找出最少人數的期望值，我們將每一個位置的確診狀況進行遞迴，直到一種組合能以最少人數的情況下讓全班隔離。到了那種情況之後，接下來不管怎麼安排接下來的位置，也一定能讓全班被匡列。\n\n如上圖，我們要統計的就是每一個能讓全班被隔離的狀態x，所包含的確診人數。以下是統計最少確診人數對應到讓全班被隔離的組數。\n3x3排列情況\n最少人數期望值：3.74667人\n4x4排列情況\n最少人數期望值：7.17143人\n5x5排列情況\n最少人數期望值：11.8351人\n結論上面放的幾張長條圖以及折線圖都放在下方參考資料中，每一張都是高畫質(dpi=1000)！關於上面第二、三部分，其實原本是想要求「最少人數期望值」，畫出並且統計完第二部分的內容後，才發現結果比想像中的還要高（超過一半的人數），細究之後才發現兩者之間的區別。\n在程式方面，原本的$2^n$的枚舉複雜度實在有點高，想說可以利用遞迴進行剪枝，但實測下來速度並沒有快多少，必須要想辦法優化才能對更多人的情況進行枚舉。另外，延伸部分可以針對確診的順序進行討論，也就是讓每一個人依照不同的先後順序確診，並在確診的當天移除該被匡列的人，讓剩下的人進行下一輪模擬。\n參考資料圖片、程式碼檔案\n我的Github\n","categories":["數學筆記"],"tags":["數學","機率","高二下筆記"]},{"title":"三維空間中的反射定律模擬","url":"/reflection/","content":"簡介上週補習班開始教「平面方程式」，有一題範例感覺特別的酷，題目如下：\n\n空間坐標系中，有一平面鏡E，一雷射光線經過點$A(1,-1,2)$射向鏡面E上的點$B(0,1,0)$，反射又經過點$C(4,-3,2)$，試求平面E的方程式為何？\n\n解法大概就是利用菱形對角線平分的概念求出平面方程式！由這一題延伸，我想看看當改變已知平面的各項參數時，反射光的向量會有怎麼樣的變化，於是就嘗試用VPython模擬出來！\n\n\n\n反射定律及數學平面的情況很好理解，入射角等於反射角，但當來到三維時，除了角度一樣之外，這三個向量還必須在同一個平面上：\n\n原題我們是利用已知的$\\overrightarrow{BA},\\overrightarrow{BC}$，利用菱形邊長相等且平分夾角的性質，將長度調整成一樣之後相加即可求出平面的法向量，進一步求得反射的平面：\n\n要利用$\\overrightarrow{BA}$以及平面方程式逆推反射光向量，在確認法向量的方向向量之後，將平面法向量的長度設為$|\\vec{n}| = 2\\overline{AB}\\cos\\theta$，由$\\vec n = \\overrightarrow{BA}+\\overrightarrow{BC}$即可推得與$\\overrightarrow{BA}$長度相同的$\\overrightarrow{BC}$！\n\n綜合以上，令反射平面方程式為$ax+by+cz = 0$，$\\vec n = (a,b,c)$，入射角為$\\theta$，則：\n\\begin{split}\\overrightarrow{BC} &= \\frac{2|\\overrightarrow{BA}|\\cos\\theta}{|\\vec n|}\\vec n - \\overrightarrow{BA}\n\\\\&=\\frac{2|\\overrightarrow{BA}|(\\vec n\\cdot\\overrightarrow{BA})}{|\\vec n|^2\\,\\overrightarrow{BA}}\\vec n - \\overrightarrow{BA}\\end{split}模擬及程式碼使用說明模擬連結他會要求輸入發射源的$x,y,z$座標，完成後可以利用鍵盤’A,S’鍵調整平面$ax+by+cz=0$上$a$的大小（A變大、S變小），$b$則是’B,N’鍵、$c$是’C,V’鍵。\n\n利用以上的公式，我們建立各個物件、包含各個座標軸、反射平面以及入射反射光。模擬中兩個黃色的箭頭代表入射光及反射光的向量，灰色箭頭則是平面的法向量。\n計算計算夾角用到內積算夾角的餘弦$\\cos\\theta = \\frac{\\vec a\\cdot\\vec b}{|\\vec a||\\vec b|}$，算內積函式如下：\ndef dt(a,b):    return a.x*b.x+a.y*b.y+a.z*b.z\n接著就是計算$|\\vec n|$的長度sz，對$\\vec n$取單位向量後乘上長度，並設為平面的法向量，將$\\vec n$與入射光向量相減得到反射光向量\nsz = 2 * mag(ball.pos) * dt(plane.up,ball.pos) / (mag(plane.up)*mag(ball.pos))n = norm(plane.up) * szplane.up = vec(a,b,c)normal.axis = narr_out.axis = n - ball.pos\n完整程式碼GlowScript 3.2 VPythonx = int(input(&quot;x = &quot;))y = int(input(&quot;y = &quot;))z = int(input(&quot;z = &quot;))a = 0b = 1c = 0scene = canvas(width=1000, height=500,center = vector(0,0,0),range = max(x,max(y,z))+10) #設定畫面def dt(a,b):    return a.x*b.x+a.y*b.y+a.z*b.zplane = box(pos=vector(0,0,0),length=20, height=0.1, width=10)arrx = arrow(pos=vector(-10,0,-5), axis=vector(20,0,0), shaftwidth=0.1, color=color.red)arry = arrow(pos=vector(-10,0,-5), axis=vector(0,20,0), shaftwidth=0.1, color=color.blue)arrz = arrow(pos=vector(-10,0,-5), axis=vector(0,0,20), shaftwidth=0.1, color=color.green)ball = sphere(pos=vector(x,y,z),radius=0.5,color = color.red)arr_in = arrow(pos=ball.pos, axis=plane.pos-ball.pos, shaftwidth=0.5, color=color.yellow)arr_out = arrow(pos=vec(0,0,0), axis=vector(0,0,0), shaftwidth=0.5, color=color.yellow)normal = arrow(pos=vec(0,0,0), shaftwidth=0.1, color=color.white)label_a = label(pos=vec(max(x,max(y,z))+10,10,0), box = 0 ,height = 20, color = color.green)label_b = label(pos=vec(max(x,max(y,z))+10,5,0), box = 0 ,height = 20, color = color.green)label_c = label(pos=vec(max(x,max(y,z))+10,0,0), box = 0 ,height = 20, color = color.green)while True:    rate(10)    label_a.text = &#x27;&#123;&#125;&#123;:.1f&#125;&#x27;.format(&#x27;a = &#x27;,a)    label_b.text = &#x27;&#123;&#125;&#123;:.1f&#125;&#x27;.format(&#x27;b = &#x27;,b)    label_c.text = &#x27;&#123;&#125;&#123;:.1f&#125;&#x27;.format(&#x27;c = &#x27;,c)        ev = scene.waitfor(&#x27;click keydown&#x27;)    if ev.key == &#x27;A&#x27;or ev.key == &#x27;a&#x27;:a += 0.1    if ev.key == &#x27;B&#x27;or ev.key == &#x27;b&#x27;:b += 0.1    if ev.key == &#x27;C&#x27;or ev.key == &#x27;c&#x27;:c += 0.1        if ev.key == &#x27;S&#x27;or ev.key == &#x27;s&#x27;:a -= 0.1    if ev.key == &#x27;N&#x27;or ev.key == &#x27;n&#x27;:b -= 0.1    if ev.key == &#x27;V&#x27;or ev.key == &#x27;v&#x27;:c -= 0.1        sz = 2 * mag(ball.pos) * dt(plane.up,ball.pos) / (mag(plane.up)*mag(ball.pos))    n = norm(plane.up) * sz        plane.up = vec(a,b,c)    normal.axis = n        arr_out.axis = n - ball.pos\n延伸內容既然有反射勢必有折射定律的模擬，牽扯到不同介質的折射率以及角度的計算$n_1\\sin\\theta_1 = n_2\\sin\\theta_2$，之後可以嘗試寫一個模擬試試！\n","categories":["程式模擬"],"tags":["數學","VPYTHON","模擬"]},{"title":"非線性調分公式的相關性質","url":"/score/","content":"\n作者：徐上雲、peienwu\n\n一、簡介在許多考試中由於在出題時難度無法掌握，故常出現集體分數過低或過高的現象。當分數過低時常會以整體調整分數的方式使集體分數回歸到正常值，或使及格比例合乎預期。如今常見的調分方式有許多種，而每一種調分方式各有優缺點，對整體分數的影響力也各異。我想嘗試將常見的幾種調整分數方式進行比對，探討每一種方式的意義、使分數的分佈狀況、優缺點。\n\n二、問題說明今有一張試卷假設滿分為100，最低分為0分。且落在0到100中的每個分數皆有機會得到。\n探討以下三種常見的調整分數的方式：\n（一）線性調整y=ax+b欲使滿分仍維持$100$，將$0$分調整為$b$分。將分數以線性關係$y=ax+b$分佈。如若希望不論原始分數為何，調整後皆可及格，最低分$0$調整為$60$分，滿分維持$100$分。則公式為：$y=0.4x+60$。\n\n求當今天設定不同最低分數值(b)時，分數調整後之狀況。\n\n（二）將原始分數開根號後乘以10另一種常見的調整分數分數為將原始分數開根號後乘以$10$。\n\n探討為何最常見的調整分數方式為開根號乘以$10$？\n若開立方根後乘以某數$k_3$，使滿分仍為$100$，探討調整後分數分佈狀況。\n若開$n$次方根乘以某數$k_n$，使滿分仍為$100$，探討調整後分數分佈狀況。\n求當開$n$次方根乘以某數$k_n$，使滿分仍為$100$時，原始分數應為何才能加到最多分？\n\n（三）將原始分數取log後乘以一常數使滿分仍為100\n今以底數為$n$，將原始分數取$\\log_a$後乘以某數$p$，使滿分仍為$100$分。探討調整後分數分佈狀況。\n\n三、探討方式做以下三張圖，進行比較：\n\n調整後分數：畫出原始分數及調整分數後之分數變動關係。(代號：$A$)\n調分比率：調整後分數相較於原始分數提高了幾倍，公式＝調整後分數/原始分數。(代號：$B$)，因分母不可為$0$故不計算$0$分之調分比率。\n多得分數：調整後分數較原始分數加了幾分，公式＝調整後分數-原始分數。(代號：$C$)\n\n四、問題解決（一）線性調整y=ax+b1. 公式：$f(x)=y=ax+b, f(0)=b,f(100)=100$2. 設定不同狀況調整後最低可得到分$(b)$當最低分為$b=60$分，$a=0.4$，公式：$y=0.4x+60$，依此類推。\n\n\n\n\nb\n公式\n\n\n\n\n60\ny=0.4x+60\n\n\n50\ny=0.5x+50\n\n\n40\ny=0.6x+40\n\n\n30\ny=0.7x+30\n\n\n20\ny=0.8x+20\n\n\n10\ny=0.9x+10\n\n\n\n\n3. 以原始分數1-100分，畫出圖表\n\n\n（二）將原始分數開根號後乘以101. 公式：$y=f(x)=10\\sqrt{x}$2. 以原始分數為$1-100$分，畫出圖表\n\n\n多得到分數呈現一有最大值的曲線，代表在$1-100$中有某一得分之人獲益最大，能加到最多分，比對得到之數據可發現當原始分數為$25$分時，最划算，可多得到最多分數。\n3. 此情況可探討當次方根數提高後乘以某數，使滿分仍為$100$當次方根為三次方根，需乘以某數$k_3$，使滿分仍為為$100$。計算$k_3=\\frac{100}{100^{1/3}}=100^{2/3}\\approx 21.5443469$。公式：$y=f(x)=x^{1/3}$以原始分數為$1-100$，畫出圖表。\n\n\n\n多得到分數呈現一有最大值的曲線，代表在$1-100$中有某一得分之人獲益最大，能加到最多分，比對得到之數據可發現當原始分數為$19$分時，最划算，可多得到最多分數。\n4. 將此情形推廣到更高次方根，求出今為n次方根後，kn為何？通式：$k_n\\cdot(100^{1/n})=100,k_n=100^{\\frac{n-1}{n}}$\n\n由上圖可知k值為將無窮接近$100$。\n5. 用$2-8$次方根，畫出以原始分數為$1-100$分的圖表。圖中$s$為次方根數\n\n\n6. 求出不同次方根中，能得到最多分數的原始分數為何？在二次方根中，原始分數為25，可以加到最多分。在三次方根中，原始分數為19，可以加到最多分。設當n次方根時，原始分數為x，可以加到最多分。計算n與x之關係：\n\\begin{split}f'(x) &= \\frac{d}{dx}(k_n\\cdot x^{1/n}-x) = 0\n\\\\&\\Rightarrow \\frac{d}{dx}(100^{\\frac{n-1}{n}}\\cdot x^{1/n}-x) = 0\n\\\\&\\Rightarrow \\frac{1}{n}\\cdot 100^{\\frac{n-1}{n}} = x^{\\frac{n-1}{n}}\n\\\\&\\Rightarrow x = 100\\cdot n^{\\frac{-n}{n-1}}\n\\end{split}\n圖中可見，橫軸為次分根數，縱軸為最大獲益的原始分數。三次方根時準確的值並非$19$，而是$19.245$。以$x$的一般式計算三次方根時最大獲益的原始分數。\n\\begin{split}x &= 100\\cdot n^{\\frac{-3}{3-1}}\n\\\\&\\approx 19.245\n\\end{split}7. 不同的次方根與加最多分數的關係由上述可知，當帶入$x = 100\\cdot n^{\\frac{-n}{n-1}}$ 會有加分的最大值。於是，我們可以將其帶入上方公式計算出不同的$n$與加最多分數的關係。\n\\begin{split}f(x) &=100^{\\frac{n-1}{n}}\\cdot x^{\\frac{1}{n}}-x,\\ x = 100\\cdot n^{\\frac{-n}{n-1}}\n\\\\&\\Rightarrow 100(n^{\\frac{-1}{n-1}}-n^{\\frac{-n}{n-1}})\n\\end{split}可得一個新的公式$h(x)$，代表不同的次方根對應的加分的最大值。此函數是一個單調遞增函數，函數值隨著$n$增加有遞增的情形。\nh(x) = 100(n^{\\frac{-1}{n-1}}-n^{\\frac{-n}{n-1}})\n（三）將原始分數取log後乘以一常數使滿分仍為100通式：設原始分數為$x$, $y=f(x)=p\\log_ax,  f(100)=100, a&gt;0$\n1. 以原始分數為1-100，畫出圖表\n\n\n我們發現，不論底數a值為何，得出結果均相同，因此想探討為什麼底數對所得到的曲線不會有影響，如下。\n2. 以一般式描述多得到之分數，探討為何不論a值為何，得出結果均相同\\begin{split}f(x) &= p\\log_ax-x\n\\\\&= (\\frac{100}{\\log_a100})\\log_ax-x\n\\\\&=100\\frac{\\log_ax}{\\log_a100}-x\n\\\\&=50\\log_{10}x-x\n\\end{split}發現在過程中底數a會被換底後取代，最終結果無a的影響，故不論底數a值為何，得出之曲線均相同。\n3. 算出原始分數為何可以多得到分數最多\\begin{split}f'(x) &= \\frac{d}{dx}(50\\log_{10}x-x) = 0\n\\\\&\\Rightarrow \\frac{50}{\\ln(10)x}=1\n\\\\&\\Rightarrow x = \\frac{50}{\\ln(10)}\\approx 21.7147\n\\end{split}發現當原始分數約為21.7147時，可加到最多分數。\n（四）最低及格分數之非線性調分1. 次方調整計算公式根據以上的定義，對於分數為$x$的人，調整後的分數$f(x)$滿足：\nf(x) = k_n\\cdot x^{\\frac{1}{n}}, \\ k_n = 100^{\\frac{n-1}{n}}以開二次方根來計算，則考36分的人可以恰好及格。我們想要利用原始分數跟目標分數，來計算需要開幾次方。假設考$b$分的人經過調整後為$a$分（及格的話$a = 60$），所開的次方數為$n$次，帶入上方公式，分項整理過後有以下關係：\nn = g(a,b)= \\frac{2-\\log b}{2-\\log a}2. 以原始分數1-100畫出調整後分數圖形下圖為$a = 60,b = 45$，$n \\approx 1.563$ 調整前後分數的圖形。\n3. 最低及格分數b與次方數n的關係由第一點的公式，我們可以觀察到，要將越低的分數調整到及格，所開的次方數$n$就必須越大，函數$g(a,b)$圖形如下圖，橫軸是原始分數$b$，縱軸是分數$b$若要調整到及格（60分）所需要開的次方數$n$。一樣可以發現到，當原始分數為36分時，開2次方根就會對應的函數值。\n\n五、結果討論（一） 線性調分聽起來很公平，每個人都可以依照一定比例加分，但在實際做出加分比率圖後發現實際上$0-20$分之加分比率遠超過其他分數族群。對於中偏前段之高分族群極為不利。不過，若想要提升及格比率，非線性調分不失為一個十分有效的方式。\n（二） 開特定次方根根後乘以一常數之結果可看出，若開$n$次方根，$n$越大能加到最多分到分數$x$隨之下降，符合公式 $x = 100\\cdot n^{\\frac{-n}{n-1}}$。\n（三） 加最多分隨著開的次方數n增加而遞增，其最大的加分數符合公式$h(x) = 100(n^{\\frac{-1}{n-1}}-n^{\\frac{-n}{n-1}})$\n（四） 若想要將一個分數為$b\\ (b&lt;60)$的人調整分數到及格，若分數$b$越小，所需要的次方數就必須越大，符合公式$n=\\frac{2-\\log b}{2-\\log a}$。\n（五） 經過log後乘以一常數之結果，發現不論底數為何，均不影響最終結果，因為底數可經由換底公式消除。\n（六） log組中發現原分數為1者，調分後會變成0分，理應修正。使原始分數為1分之人至少不要呈現扣分的情況。\n看了次方根和log兩組的曲線後趨勢變化有點相近，可以將兩張圖疊合再一起做比較。可見log組的曲線相較次方根組之變化趨勢，如下圖：\n\n六、未來展望之後可以做出以假設全班原始分數為常態分佈，假設在不同的平均分數下，模擬出全班調分後之結果，計算及格比率。可以作為未來進行調分的依據。調整分數者可先行設定這次考試可能之平均及希望及格比率為何後，選定一種方式進行調分。\n","categories":["數學筆記"],"tags":["數學","調分公式"]},{"title":"線段樹（Segment Tree）","url":"/seg1/","content":"今年是2021，資芽的二階主題跟2020上的有很多的差別，因此會利用暑假把2020的東西也補一補！\n課程內容儲存線段樹很多人都用陣列來實作，空間$O(n)$，在處理樹的左右節點也十分的方便。如果以1-base來儲存陣列這棵線段樹，左右節點可以用以下的index來表示。線段樹有一個優點就是它可以用儲存完滿二元樹的方式來儲存，雖然它不一定是完滿但會是平衡的一棵樹。左節點：$2n$，右節點$2n+1$。\n空間大小一般來說線段樹的陣列會開$seg[4\\times n]$，由以下證明得到的結果：\n\n            對於一個有$2^k$的葉節點數的一棵樹，總共的節點共有 $\\sum_{i=0}^k 2^i = 2^{k+1}-1$ 個節點。若今天陣列共有n個元素，則代表葉節點共有$2^{\\lceil \\log_2 n\\rceil}$ 個，總節點數量共有$2^{\\lceil \\log_2 n\\rceil+1}-1$ 個。假設$n = 2^k+p,0≤p≤2^k$，則帶入前面公式 $2^{\\lceil \\log_2 n\\rceil}=2^{k+1}$，根據前面推得的總節點數可以知道為 $2^{k+2}-1$，其值恆小於$4n$，因此開$4n$的陣列一定可以容納整個線段樹。\n          \n由以上推倒可以知道一般都會開$seg[4\\times n]$，但是如果n剛好是二的冪次，其實只會用到$2n$的空間，有一半會被浪費掉，不過沒差，因為多開總比少開來得好！懶標線段樹程式碼連結，懶標這東西實在折磨人，學長寫的一個堪稱不用下推的懶標程式碼，結果他是錯的！！！害我Debug超久，可惡這是學長的query程式碼，可以看到他回傳的是$(r-l)\\times lazy[cur]$，這是錯誤的，因為不一定左右兩子樹都會被全部加上懶標的值（可能只會有部分交集），但這份code卻直接加上去，會多算而WA，要注意！更改版，對區間取聯集應該就對了！\n實作部分這個版本是用struct實作，比起用陣列實作，這個版本更為方便閱讀，容易理解。為了方便索引值查詢左右子樹，使用1-base來儲存線段樹，同時利用一個struct儲存每一個節點。同時，每一個區間採用的是左閉右開 $[l,r)$，區間和的實作如下：\nstruct Node&#123;            //線段樹每一個節點    int val=0,tag=0,sz; //val原本的值、tag懶標、sz區間大小    int rv()&#123;           //回傳實際節點的值        return val+tag*sz;    &#125;&#125;seg[4*N];\n建立(Build)分別遞迴建立左右子樹，同時更新每一個節點的大小sz。因為是左閉右開，直接左右相減r-l即可完成更新。\nvoid build(int l,int r,int cur)&#123;    //建立線段樹    seg[cur].sz = r-l;              //更新節點的大小    if(r&lt;=l)return;                 //空區間回傳    if(r-l==1)&#123;                     //設定當前節點的值        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //分別遞迴建立左右子樹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = seg[2*cur].val+seg[2*cur+1].val;&#125;\n下推(push)懶標真是驚人的想法，在區間修改的時候以$O(logn)$在要修改的區間先懶標標記起來，等到要query的時候把懶標推下去，這樣可以確保區間修改的複雜度是$O(logn)$，同時query的時候順便下推，一來比較好實作、二來複雜度也不會有什麼改變， 因為下推的複雜度是$O(1)$。\n//把id的懶標在query的時候往下推void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //左子樹懶標更新    seg[2*id+1].tag += seg[id].tag; //右子樹懶標更新    seg[id].val = seg[id].rv();     //更新實際值    seg[id].tag = 0;                //往下推完之後設定為預設&#125;\n區間詢問(query)這裡的重點是下推，如果把懶標下推，可以確保區間修改的時間是$O(logn)$\n//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return 0;         //空集合直接回傳    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //包含在要詢問的範圍中，回傳實際值    push(cur);                                  //將懶標在遞迴下去的過程中下推    int mid = (l+r)/2;                          //遞迴查詢左右子樹    return query(cur*2,l,mid,ql,qr)+query(cur*2+1,mid,r,ql,qr);&#125;\n區點修改(modify)可以這樣理解，在區間修改中，透過遞迴完左右子樹拉上來的過程中，更新樹上較上方的節點的值（用懶標更新）。此時下方節點都還沒有被更新，等到query的時候會往下push順便把值也一起更新。\n//區間修改void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //將被完整包含的區間的懶標加上修改值        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //修改左右子樹    modify(cur*2+1,mid,r,ql,qr,val);        //遞迴完拉上來的過程中把上面的數值更新成有懶標的結果    seg[cur].val = seg[2*cur].rv()+seg[2*cur+1].rv();&#125;\n單點修改(modify)這一題沒有要求單點修改，所以以下是RMQ的單點修改。概念較為簡單，用$O(logn)$找到要修改的點，直接修改即可。\nvoid modify(int cur,int l,int r,int ind,int val)&#123;    if(r&lt;=l)return;    if(r-l==1 &amp;&amp; l==ind)&#123;        seg[cur]=val;        return;    &#125;    int mid = (l+r)/2;    if(ind&lt;mid)modify(cur*2,l,mid,ind,val);    else modify(cur*2+1,mid,r,ind,val);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;\n動態開點\n有一個長度是 $10^9$ 的序列，一開始裡面的元素都是$0$，有 $Q$ 筆操作，每一個操作是以下其中兩種：\n\n把之間的值都加上$v$\n詢問的區間和\n\n\n開這麼多點顯然會MLE，既然使用陣列型儲存線段樹會爆，因為這麼大的值域顯然有許多點是不會被使用到的，那就改成使用指標型來開這個線段樹，以下為每一個節點的架構：\nstruct Node&#123;    Node *l;    //指向左子樹    Node *r;    //指向右子樹    int val;    //維護區間和    &#125;;//注意struct裡面可有struct的指標，但不能有實體\n","categories":["C++進階主題","線段樹"],"tags":["2021暑假筆記","2020資訊之芽"]},{"title":"[題解]NEOJ 80 RMQ練習","url":"/seg2-1/","content":"RMQ練習\n題目連結RMQ = Range minimun query，也就是詢問一個區間的最小值。分析一下兩種不同作法的複雜度：\n            對於數列 $a_n$ 共n項，k筆詢問，每一次詢問區間$[l,r]$的最大、最小值1. 暴力做時間複雜度：詢問$O(n)$對於每一筆詢問都暴力搜索，最多掃過n個數字，時間複雜度$O(kn)$，對於數字大一點的情況就會TLE2. 分塊算法可以參見 這篇文章3. 線段樹時間複雜度：預處理 $O(n)$、詢問$O(logn)$首先是預處理建立線段樹，線段樹上約有$2n$個節點，因此空間複雜度是$O(n)$，也就表示預處理是$O(n)$，之後便可$O(logn)$查詢每一筆詢問。以下是各種操作複雜度：初始建構：所有節點恰會建構一次，每個節點 $O(1)$，配合節點樹可得為 $O(𝑛)$單點修改：該點的所有祖先節點都會被修改到，其他都不會被修改到，$𝑂(logn)$區間查詢：每筆詢問最多詢問到深度為 $O(logn)$ 的節點。在一次詢問中，每一層不會有超過2個節點被詢問，總複雜度為$𝑂(log𝑛)$4. 稀疏表(Sparse Table)時間複雜度：預處理 $O(nlogn)$、詢問$O(1)$參考 這篇文章\n          \n這一題就是基礎的要有支援區間查詢、單點修改的線段樹，也是最簡單的一種！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 1000000#define INF 1e9using namespace std;int seg[4 * N],arr[N],n,m;void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = arr[l];        return;    &#125;    int m = (l+r)/2;    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//單點修改void modify(int cur,int l,int r,int ind,int val)&#123;    if(r&lt;=l)return;    if(r-l==1 &amp;&amp; l==ind)&#123;        seg[cur]=val;        return;    &#125;    int mid = (l+r)/2;    if(ind&lt;mid)modify(cur*2,l,mid,ind,val);    else modify(cur*2+1,mid,r,ind,val);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return INF;    if(ql&lt;=l &amp;&amp; qr&gt;=r)&#123;        return seg[cur];    &#125;    int mid = (l+r)/2;    return min(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;int main()&#123;    ios;    cin&gt;&gt;m&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            modify(1,1,n+1,x+1,y);        &#125;        else if(p==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x+1,y+2);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["線段樹題解"],"tags":["題解","線段樹"]},{"title":"[題解]NEOJ 249 最大連續和？","url":"/seg2-2/","content":"最大連續和？\n題目連結這題題結果我是WA在INF太大可能會溢位的問題，把INF調整成 $5\\times 10^{14}$ 是差不多的\n這一題要維護區間最大連續和，跟dp的最大連續和差了「區間」兩字，整個實作的方式跟複雜度就不一樣了。DP的作法如果直接套用在這一題的話，複雜度約為：$O(QN)$，絕對會炸裂，因此只能用線段樹維護這個東西。\n\n            區間最大連續和在分治法的單元有提到分治法最重要的是假定左右兩側（對應過來就是兩子樹）是維護好的，也就是符合定義，要想的是要如何處理橫跨左右子樹的情況。要如何知道橫跨中間的最大值呢？這時候我們可以維護4個數值，來更新每一個線段樹上的節點的數值。總和(sum)$cur.sum = left.sum+right.sum$最大前綴和(lmax)$cur.lmax = max(left.lmax,left.sum+right.lmax)$最大後綴和(rmax)$cur.rmax = max(right.rmax,right.sum+left.rmax)$區間最大連續和(tmax)$cur.tmax = max(left.tmax,right.tmax,left.rmax+right.lmax)$\n          \n維護最大後綴跟最大前綴和（首跟末有被取到的情況），就可以$O(1)$ 維護每一個節點的區間最大連續和，複雜度：詢問$O(logn)$，因此總時間$O(Qlogn)$就可以AC了!\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 100005#define INF 500000000000000using namespace std;int arr[N],n,m;struct Node&#123;    int sum;    //區間總和    int lmax;   //最大前綴和    int rmax;   //最大後綴和    int tmax;   //區間連續最大和&#125;seg[N&lt;&lt;2];//求當下的區間連續最大和void modify(Node &amp;cur,Node &amp;left,Node &amp;right)&#123;    cur.sum = left.sum+right.sum;    cur.lmax = max(left.lmax,left.sum+right.lmax);    cur.rmax = max(right.rmax,right.sum+left.rmax);    cur.tmax = max(max(left.tmax,right.tmax),left.rmax+right.lmax);&#125;//建立線段樹：[l,r)void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = &#123;arr[l],arr[l],arr[l],arr[l]&#125;;        return;    &#125;    int mid = (l+r)/2;    build(l,mid,2*cur);    build(mid,r,2*cur+1);    modify(seg[cur],seg[2*cur],seg[2*cur+1]);&#125;//區間詢問：[l,r)Node query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return &#123;-INF,-INF,-INF,-INF&#125;;    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur];    int mid = (l+r)/2;    auto left = query(2*cur,l,mid,ql,qr);    auto right = query(2*cur+1,mid,r,ql,qr);    Node temp;    modify(temp,left,right);    return temp;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int l,r;cin&gt;&gt;l&gt;&gt;r;        auto ans = query(1,1,n+1,l,r+1);        cout&lt;&lt;max(ans.tmax,(long long)0)&lt;&lt;endl;    &#125;&#125;\n","categories":["線段樹題解"],"tags":["題解","線段樹"]},{"title":"[題解]NEOJ 367 RMQ˙改","url":"/seg2-4/","content":"RMQ˙改\n題目連結這一題是Range Maximum Query搭配區間加值，如果直接套用前面RMQ或是區間和的模板就輕鬆許多。這一題主要跟前面題目的不同在於它的sz要維護成1，有別於求區間和要乘上區間大小，每一個值不需要乘上區間大小，因此設成0。\n這題第二筆測資明顯就是要卡暴力解法。\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define int long longusing namespace std;const int INF = 1e14;struct Node&#123;            //線段樹每一個節點    int val=0,tag=0,sz=0; //val原本的值、tag懶標、sz區間大小    int rv()&#123;           //回傳實際節點的值        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //建立線段樹    seg[cur].sz = 1;                //更新節點的大小    if(r&lt;=l)return;                 //空區間回傳    if(r-l==1)&#123;                     //設定當前節點的值        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //分別遞迴建立左右子樹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = max(seg[2*cur].val,seg[2*cur+1].val);&#125;//把id的懶標在query的時候往下推void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //左子樹懶標更新    seg[2*id+1].tag += seg[id].tag; //右子樹懶標更新    seg[id].val = seg[id].rv();     //更新實際值    seg[id].tag = 0;                //往下推完之後設定為預設&#125;//區間修改void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //將被完整包含的區間的懶標加上修改值        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //修改左右子樹    modify(cur*2+1,mid,r,ql,qr,val);        //遞迴完拉上來的過程中把上面的數值更新成有懶標    seg[cur].val = max(seg[2*cur].rv(),seg[2*cur+1].rv());&#125;//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return -INF;      //空集合直接回傳    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //包含在要詢問的範圍中，回傳實際值    push(cur);                                  //將懶標在遞迴下去的過程中下推    int mid = (l+r)/2;                          //遞迴查詢左右子樹    return max(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["線段樹題解"],"tags":["題解","線段樹"]},{"title":"[題解]ZJ d799 區間求和","url":"/seg2-3/","content":"d799區間求和\n題目連結這一題要求兩個操作，區間加值跟區間查詢，這時候就必須用到懶標(lazy tags) 輔助求和。\n\n範例測資：101 2 3 4 5 6 7 8 9 1032 2 41 3 6 32 2 4\n\n左邊是整棵線段樹，右邊則是懶標，可以看到3要往下推，但學長的程式碼中並沒有執行這個步驟，這樣會導致query的時候發生錯誤。\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500005#define int long longusing namespace std;struct Node&#123;            //線段樹每一個節點    int val=0,tag=0,sz; //val原本的值、tag懶標、sz區間大小    int rv()&#123;           //回傳實際節點的值        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //建立線段樹    seg[cur].sz = r-l;              //更新節點的大小    if(r&lt;=l)return;                 //空區間回傳    if(r-l==1)&#123;                     //設定當前節點的值        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //分別遞迴建立左右子樹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = seg[2*cur].val+seg[2*cur+1].val;&#125;//把id的懶標在query的時候往下推void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //左子樹懶標更新    seg[2*id+1].tag += seg[id].tag; //右子樹懶標更新    seg[id].val = seg[id].rv();     //更新實際值    seg[id].tag = 0;                //往下推完之後設定為預設&#125;//區間修改void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //將被完整包含的區間的懶標加上修改值        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //修改左右子樹    modify(cur*2+1,mid,r,ql,qr,val);        //遞迴完拉上來的過程中把上面的數值更新成有懶標    seg[cur].val = seg[2*cur].rv()+seg[2*cur+1].rv();&#125;//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return 0;         //空集合直接回傳    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //包含在要詢問的範圍中，回傳實際值    push(cur);                                  //將懶標在遞迴下去的過程中下推    int mid = (l+r)/2;                          //遞迴查詢左右子樹    return query(cur*2,l,mid,ql,qr)+query(cur*2+1,mid,r,ql,qr);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);    cin&gt;&gt;m;        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["線段樹題解"],"tags":["題解","線段樹"]},{"title":"[題解]TIOJ 1224 矩形覆蓋面積計算","url":"/seg2-5/","content":"1224 . 矩形覆蓋面積計算\n題目連結Submission2:AC\n\n題意：給你平面上n個矩形，請求出它們覆蓋的總表面積。\n\n這一題所使用的技巧是掃描線以及線段樹，下圖中的水平藍色線即為掃描線，由y=0開始往上掃描，當遇到了矩形的邊，利用線段樹查詢區間內當前的矩形寬度，乘上兩掃描線的高度差即為面積。當然，掃描線也可以使用垂直方向的線段由左而右的掃描，實作細節是一樣的。\n\n線段樹維護方法一我們可以定義線段樹$seg[cur]$為區間$[l,r]$中有被矩形覆蓋的大小有多大，也就是圖中當前掃描線對應到的區域的寬度。這樣子維護有一個問題，當我們直接用$seg[cur]$儲存答案，我們在修改的時候沒有辦法確切知道這段區間被覆蓋的情況。\n下圖為一種模擬的情況，每一個區間的數字代表著非0的數字個數，也就是它的寬度。今天我們要對區間$[4,6]$加減值，將區間拆成$[4,4]$跟$[5,6]$，這時候區間$[3,4]$的數值是1，我們卻不知道到底是3還是4是有被覆蓋到的，必須要遞迴下去到葉節點才能得到完整的覆蓋情況，這時候每一次加減值的複雜就會提升到$O(n)$，因此不能以這種方式維護。\n\n方法二有別於第一種方法對$seg[id]$進行維護，我們可以多開一個區間 $tag$ 來紀錄被矩形覆蓋的情況。下圖有3個矩形，其中的數字代表每一塊區域被覆蓋的情況，這邊使用了$tag$來紀錄（他是附在區間上的，不會像圖中一樣的方式呈現）。tag的數值為非負整數，紀錄當前區間有多少矩形覆蓋在上面，用$tag$來輔助維護$seg[id]$可以在$O(logn)$的時間進行修改與查詢。\n\n以下程式碼是是 $tag$ 的轉移，當大的區間的tag值不為0，代表有一個矩形曾完整覆蓋這個區間，這時候可以直接回傳區間大小，否則即回傳左右節點的$sed[left],seg[right]$的數值。\n這邊定義$seg[id]$為：「考慮 id 的子孫們（不含 id 本身）的所有 tag 值，假設這些子孫只有被tag值作用過，共有多少非0的數字」。\nseg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)              +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);\n實作方法矩形維護首先是維護矩形的方法。我們一個矩形總共要維護四個東西：矩形左界x1、矩形右界x2、矩形上下界的y座標（分上下兩條），這兩條邊是下界或是上界val。為什麼要水平方向要分兩條討論？是因為下界代表進入，當掃描線掃到這一條邊的時候表示我們要新增區間 $[x1,x2)$ 進入線段樹；反之如果掃到了上界，則表示離開這個矩形，在線段樹中扣掉區間 $[x1,x2)$。\nstruct Node&#123;    //每一個矩陣分成上下兩條邊    int x1;     //矩形左界x1    int x2;     //矩形右界x2    int y;      //矩形y座標（分上下兩邊）    int val;    //val = ±1(進入代表1、離開代表-1)    &#125;arr[2*N];\n上下界我們利用val維護，當 $val=1$ 時表示是矩形的下界； $val=-1$ 則是矩形上界，這兩個搭配在一起剛好就可以用線段樹區間加值的方式進行操作！總共有 $n$ 個矩形，因此我們要掃描線總共掃描 $2n$ 條線段。\n線段樹一樣對值域（這題是1000000）的4倍開了線段樹，同時維護一個非負整數 $tag$ 表示區間被覆蓋的情況。當每一次修改完成之後，我們可以直接取用根節點 $seg[1]$ 的數值表示寬度（非0的個數）！\n//seg[i]表示i的左右兩子樹的區間非0的個數struct node&#123;    //建立線段樹    int val;    //維護非0個數    int tag;    //使用tag紀錄區間被覆蓋次數&#125;seg[4*M];\n接下來就是在程式執行的過程中將 $2n$ 條邊依照y座標進行排序 $O(nlogn)$，接著依序使用掃描線搭配線段樹的修改，計算矩形的面積。最後就是輸出加起來的答案。\n\n            Debug 小錯誤Submission1:WA可以看到有一筆測資過不了，95分QQQ後來debug之後發現到，因為我是對每一個矩形先輸入下界之後才是上界，當我在排序的過程中，上界有可能有機會跑到下界之前，造成 $tag$ 被扣到負的情況，但在定義中可以清楚知道 $tag$ 是非負整數造成錯誤。因此只要把排序的過程改成 stable_sort() 即可！stable_sort(arr,arr+(n&lt;&lt;1),cmp);\n          \n最後終於是程式碼的部分，以下：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define M 1000001#define lld long longusing namespace std;int n;struct Node&#123;    //每一個矩陣分成上下兩條邊    int x1;     //矩形左界x1    int x2;     //矩形右界x2    int y;      //矩形y座標（分上下兩邊）    int val;    //val = ±1(進入代表1、離開代表-1)    &#125;arr[2*N];//seg[i]表示i的左右兩子樹的區間非0的個數struct node&#123;    //建立線段樹    int val;    //維護非0個數    int tag;    //使用tag紀錄區間被覆蓋次數    &#125;seg[4*M];bool cmp(Node a, Node b)&#123;    return a.y&lt;b.y;&#125;//對區間[ql,qr)進行加值valvoid modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[cur].tag += val;        return;    &#125;    int mid = (l+r)/2;    modify(2*cur,l,mid,ql,qr,val);    modify(2*cur+1,mid,r,ql,qr,val);        //左右節點如有tag表示被完全覆蓋，直接加上區間大小，否則加上seg[左右子樹]    seg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)                  +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);&#125;int main()&#123;    ios;    memset(arr,0,sizeof(arr));    memset(seg,0,sizeof(seg));        cin&gt;&gt;n;                                   //依序輸入左右下上：x1,x2,y1,y2    for(int i=0;i&lt;(n&lt;&lt;1);i+=2)&#123;        int x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;y1&gt;&gt;y2;        arr[i] = (Node)&#123;x1,x2,y1,1&#125;;          //插入矩形下邊，帶入val = 1        arr[i+1] = (Node)&#123;x1,x2,y2,-1&#125;;       //上邊要val = -1    &#125;    stable_sort(arr,arr+(n&lt;&lt;1),cmp);          //依照y座標由小到大排序        int y0 = 0,val = 0;                       //有下而上的枚舉所有水平邊    lld ans = 0LL;                            //上一條y的座標，計算高，val為矩形結合起來的寬    for(int i=0;i&lt;(n&lt;&lt;1);i++)&#123;                //枚舉2n條y的邊        ans += (lld)(arr[i].y-y0)*val;        //計算面積（寬*高）        modify(1,0,M,arr[i].x1,arr[i].x2,arr[i].val);        y0 = arr[i].y;        val = seg[1].val;                     //修改後（下一輪）的矩陣寬度    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["線段樹題解"],"tags":["題解","線段樹"]},{"title":"線段樹例題（Segment Tree）","url":"/seg2/","content":"題目目錄\nNEOJ 80 RMQ練習\nNEOJ 249 最大連續和？\nZJ d799 區間求和\nNEOJ 367 RMQ˙改\nTIOJ 1224 矩形覆蓋面積計算\n\n\nRMQ練習題目連結RMQ = Range minimun query，也就是詢問一個區間的最小值。分析一下兩種不同作法的複雜度：\n            對於數列 $a_n$ 共n項，k筆詢問，每一次詢問區間$[l,r]$的最大、最小值1. 暴力做時間複雜度：詢問$O(n)$對於每一筆詢問都暴力搜索，最多掃過n個數字，時間複雜度$O(kn)$，對於數字大一點的情況就會TLE2. 分塊算法可以參見 這篇文章3. 線段樹時間複雜度：預處理 $O(n)$、詢問$O(logn)$首先是預處理建立線段樹，線段樹上約有$2n$個節點，因此空間複雜度是$O(n)$，也就表示預處理是$O(n)$，之後便可$O(logn)$查詢每一筆詢問。以下是各種操作複雜度：初始建構：所有節點恰會建構一次，每個節點 $O(1)$，配合節點樹可得為 $O(𝑛)$單點修改：該點的所有祖先節點都會被修改到，其他都不會被修改到，$𝑂(logn)$區間查詢：每筆詢問最多詢問到深度為 $O(logn)$ 的節點。在一次詢問中，每一層不會有超過2個節點被詢問，總複雜度為$𝑂(log𝑛)$4. 稀疏表(Sparse Table)時間複雜度：預處理 $O(nlogn)$、詢問$O(1)$參考 這篇文章\n          \n這一題就是基礎的要有支援區間查詢、單點修改的線段樹，也是最簡單的一種！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 1000000#define INF 1e9using namespace std;int seg[4 * N],arr[N],n,m;void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = arr[l];        return;    &#125;    int m = (l+r)/2;    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//單點修改void modify(int cur,int l,int r,int ind,int val)&#123;    if(r&lt;=l)return;    if(r-l==1 &amp;&amp; l==ind)&#123;        seg[cur]=val;        return;    &#125;    int mid = (l+r)/2;    if(ind&lt;mid)modify(cur*2,l,mid,ind,val);    else modify(cur*2+1,mid,r,ind,val);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return INF;    if(ql&lt;=l &amp;&amp; qr&gt;=r)&#123;        return seg[cur];    &#125;    int mid = (l+r)/2;    return min(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;int main()&#123;    ios;    cin&gt;&gt;m&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            modify(1,1,n+1,x+1,y);        &#125;        else if(p==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x+1,y+2);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n最大連續和？題目連結這題題結果我是WA在INF太大可能會溢位的問題，把INF調整成 $5\\times 10^{14}$ 是差不多的\n這一題要維護區間最大連續和，跟dp的最大連續和差了「區間」兩字，整個實作的方式跟複雜度就不一樣了。DP的作法如果直接套用在這一題的話，複雜度約為：$O(QN)$，絕對會炸裂，因此只能用線段樹維護這個東西。\n\n            區間最大連續和在分治法的單元有提到分治法最重要的是假定左右兩側（對應過來就是兩子樹）是維護好的，也就是符合定義，要想的是要如何處理橫跨左右子樹的情況。要如何知道橫跨中間的最大值呢？這時候我們可以維護4個數值，來更新每一個線段樹上的節點的數值。總和(sum)$cur.sum = left.sum+right.sum$最大前綴和(lmax)$cur.lmax = max(left.lmax,left.sum+right.lmax)$最大後綴和(rmax)$cur.rmax = max(right.rmax,right.sum+left.rmax)$區間最大連續和(tmax)$cur.tmax = max(left.tmax,right.tmax,left.rmax+right.lmax)$\n          \n維護最大後綴跟最大前綴和（首跟末有被取到的情況），就可以$O(1)$ 維護每一個節點的區間最大連續和，複雜度：詢問$O(logn)$，因此總時間$O(Qlogn)$就可以AC了!\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 100005#define INF 500000000000000using namespace std;int arr[N],n,m;struct Node&#123;    int sum;    //區間總和    int lmax;   //最大前綴和    int rmax;   //最大後綴和    int tmax;   //區間連續最大和&#125;seg[N&lt;&lt;2];//求當下的區間連續最大和void modify(Node &amp;cur,Node &amp;left,Node &amp;right)&#123;    cur.sum = left.sum+right.sum;    cur.lmax = max(left.lmax,left.sum+right.lmax);    cur.rmax = max(right.rmax,right.sum+left.rmax);    cur.tmax = max(max(left.tmax,right.tmax),left.rmax+right.lmax);&#125;//建立線段樹：[l,r)void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = &#123;arr[l],arr[l],arr[l],arr[l]&#125;;        return;    &#125;    int mid = (l+r)/2;    build(l,mid,2*cur);    build(mid,r,2*cur+1);    modify(seg[cur],seg[2*cur],seg[2*cur+1]);&#125;//區間詢問：[l,r)Node query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return &#123;-INF,-INF,-INF,-INF&#125;;    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur];    int mid = (l+r)/2;    auto left = query(2*cur,l,mid,ql,qr);    auto right = query(2*cur+1,mid,r,ql,qr);    Node temp;    modify(temp,left,right);    return temp;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int l,r;cin&gt;&gt;l&gt;&gt;r;        auto ans = query(1,1,n+1,l,r+1);        cout&lt;&lt;max(ans.tmax,(long long)0)&lt;&lt;endl;    &#125;&#125;\nd799區間求和題目連結這一題要求兩個操作，區間加值跟區間查詢，這時候就必須用到懶標(lazy tags) 輔助求和。\n\n範例測資：101 2 3 4 5 6 7 8 9 1032 2 41 3 6 32 2 4\n\n左邊是整棵線段樹，右邊則是懶標，可以看到3要往下推，但學長的程式碼中並沒有執行這個步驟，這樣會導致query的時候發生錯誤。\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500005#define int long longusing namespace std;struct Node&#123;            //線段樹每一個節點    int val=0,tag=0,sz; //val原本的值、tag懶標、sz區間大小    int rv()&#123;           //回傳實際節點的值        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //建立線段樹    seg[cur].sz = r-l;              //更新節點的大小    if(r&lt;=l)return;                 //空區間回傳    if(r-l==1)&#123;                     //設定當前節點的值        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //分別遞迴建立左右子樹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = seg[2*cur].val+seg[2*cur+1].val;&#125;//把id的懶標在query的時候往下推void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //左子樹懶標更新    seg[2*id+1].tag += seg[id].tag; //右子樹懶標更新    seg[id].val = seg[id].rv();     //更新實際值    seg[id].tag = 0;                //往下推完之後設定為預設&#125;//區間修改void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //將被完整包含的區間的懶標加上修改值        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //修改左右子樹    modify(cur*2+1,mid,r,ql,qr,val);        //遞迴完拉上來的過程中把上面的數值更新成有懶標    seg[cur].val = seg[2*cur].rv()+seg[2*cur+1].rv();&#125;//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return 0;         //空集合直接回傳    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //包含在要詢問的範圍中，回傳實際值    push(cur);                                  //將懶標在遞迴下去的過程中下推    int mid = (l+r)/2;                          //遞迴查詢左右子樹    return query(cur*2,l,mid,ql,qr)+query(cur*2+1,mid,r,ql,qr);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);    cin&gt;&gt;m;        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\nRMQ˙改題目連結這一題是Range Maximum Query搭配區間加值，如果直接套用前面RMQ或是區間和的模板就輕鬆許多。這一題主要跟前面題目的不同在於它的sz要維護成1，有別於求區間和要乘上區間大小，每一個值不需要乘上區間大小，因此設成0。\n這題第二筆測資明顯就是要卡暴力解法。\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define int long longusing namespace std;const int INF = 1e14;struct Node&#123;            //線段樹每一個節點    int val=0,tag=0,sz=0; //val原本的值、tag懶標、sz區間大小    int rv()&#123;           //回傳實際節點的值        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //建立線段樹    seg[cur].sz = 1;                //更新節點的大小    if(r&lt;=l)return;                 //空區間回傳    if(r-l==1)&#123;                     //設定當前節點的值        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //分別遞迴建立左右子樹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = max(seg[2*cur].val,seg[2*cur+1].val);&#125;//把id的懶標在query的時候往下推void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //左子樹懶標更新    seg[2*id+1].tag += seg[id].tag; //右子樹懶標更新    seg[id].val = seg[id].rv();     //更新實際值    seg[id].tag = 0;                //往下推完之後設定為預設&#125;//區間修改void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //將被完整包含的區間的懶標加上修改值        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //修改左右子樹    modify(cur*2+1,mid,r,ql,qr,val);        //遞迴完拉上來的過程中把上面的數值更新成有懶標    seg[cur].val = max(seg[2*cur].rv(),seg[2*cur+1].rv());&#125;//區間詢問int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return -INF;      //空集合直接回傳    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //包含在要詢問的範圍中，回傳實際值    push(cur);                                  //將懶標在遞迴下去的過程中下推    int mid = (l+r)/2;                          //遞迴查詢左右子樹    return max(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n1224 . 矩形覆蓋面積計算題目連結Submission2:AC\n\n題意：給你平面上n個矩形，請求出它們覆蓋的總表面積。\n\n這一題所使用的技巧是掃描線以及線段樹，下圖中的水平藍色線即為掃描線，由y=0開始往上掃描，當遇到了矩形的邊，利用線段樹查詢區間內當前的矩形寬度，乘上兩掃描線的高度差即為面積。當然，掃描線也可以使用垂直方向的線段由左而右的掃描，實作細節是一樣的。\n\n線段樹維護方法一我們可以定義線段樹$seg[cur]$為區間$[l,r]$中有被矩形覆蓋的大小有多大，也就是圖中當前掃描線對應到的區域的寬度。這樣子維護有一個問題，當我們直接用$seg[cur]$儲存答案，我們在修改的時候沒有辦法確切知道這段區間被覆蓋的情況。\n下圖為一種模擬的情況，每一個區間的數字代表著非0的數字個數，也就是它的寬度。今天我們要對區間$[4,6]$加減值，將區間拆成$[4,4]$跟$[5,6]$，這時候區間$[3,4]$的數值是1，我們卻不知道到底是3還是4是有被覆蓋到的，必須要遞迴下去到葉節點才能得到完整的覆蓋情況，這時候每一次加減值的複雜就會提升到$O(n)$，因此不能以這種方式維護。\n\n方法二有別於第一種方法對$seg[id]$進行維護，我們可以多開一個區間 $tag$ 來紀錄被矩形覆蓋的情況。下圖有3個矩形，其中的數字代表每一塊區域被覆蓋的情況，這邊使用了$tag$來紀錄（他是附在區間上的，不會像圖中一樣的方式呈現）。tag的數值為非負整數，紀錄當前區間有多少矩形覆蓋在上面，用$tag$來輔助維護$seg[id]$可以在$O(logn)$的時間進行修改與查詢。\n\n以下程式碼是是 $tag$ 的轉移，當大的區間的tag值不為0，代表有一個矩形曾完整覆蓋這個區間，這時候可以直接回傳區間大小，否則即回傳左右節點的$sed[left],seg[right]$的數值。\n這邊定義$seg[id]$為：「考慮 id 的子孫們（不含 id 本身）的所有 tag 值，假設這些子孫只有被tag值作用過，共有多少非0的數字」。\nseg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)              +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);\n實作方法矩形維護首先是維護矩形的方法。我們一個矩形總共要維護四個東西：矩形左界x1、矩形右界x2、矩形上下界的y座標（分上下兩條），這兩條邊是下界或是上界val。為什麼要水平方向要分兩條討論？是因為下界代表進入，當掃描線掃到這一條邊的時候表示我們要新增區間 $[x1,x2)$ 進入線段樹；反之如果掃到了上界，則表示離開這個矩形，在線段樹中扣掉區間 $[x1,x2)$。\nstruct Node&#123;    //每一個矩陣分成上下兩條邊    int x1;     //矩形左界x1    int x2;     //矩形右界x2    int y;      //矩形y座標（分上下兩邊）    int val;    //val = ±1(進入代表1、離開代表-1)    &#125;arr[2*N];\n上下界我們利用val維護，當 $val=1$ 時表示是矩形的下界； $val=-1$ 則是矩形上界，這兩個搭配在一起剛好就可以用線段樹區間加值的方式進行操作！總共有 $n$ 個矩形，因此我們要掃描線總共掃描 $2n$ 條線段。\n線段樹一樣對值域（這題是1000000）的4倍開了線段樹，同時維護一個非負整數 $tag$ 表示區間被覆蓋的情況。當每一次修改完成之後，我們可以直接取用根節點 $seg[1]$ 的數值表示寬度（非0的個數）！\n//seg[i]表示i的左右兩子樹的區間非0的個數struct node&#123;    //建立線段樹    int val;    //維護非0個數    int tag;    //使用tag紀錄區間被覆蓋次數&#125;seg[4*M];\n接下來就是在程式執行的過程中將 $2n$ 條邊依照y座標進行排序 $O(nlogn)$，接著依序使用掃描線搭配線段樹的修改，計算矩形的面積。最後就是輸出加起來的答案。\n\n            Debug 小錯誤Submission1:WA可以看到有一筆測資過不了，95分QQQ後來debug之後發現到，因為我是對每一個矩形先輸入下界之後才是上界，當我在排序的過程中，上界有可能有機會跑到下界之前，造成 $tag$ 被扣到負的情況，但在定義中可以清楚知道 $tag$ 是非負整數造成錯誤。因此只要把排序的過程改成 stable_sort() 即可！stable_sort(arr,arr+(n&lt;&lt;1),cmp);\n          \n最後終於是程式碼的部分，以下：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define M 1000001#define lld long longusing namespace std;int n;struct Node&#123;    //每一個矩陣分成上下兩條邊    int x1;     //矩形左界x1    int x2;     //矩形右界x2    int y;      //矩形y座標（分上下兩邊）    int val;    //val = ±1(進入代表1、離開代表-1)    &#125;arr[2*N];//seg[i]表示i的左右兩子樹的區間非0的個數struct node&#123;    //建立線段樹    int val;    //維護非0個數    int tag;    //使用tag紀錄區間被覆蓋次數    &#125;seg[4*M];bool cmp(Node a, Node b)&#123;    return a.y&lt;b.y;&#125;//對區間[ql,qr)進行加值valvoid modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[cur].tag += val;        return;    &#125;    int mid = (l+r)/2;    modify(2*cur,l,mid,ql,qr,val);    modify(2*cur+1,mid,r,ql,qr,val);        //左右節點如有tag表示被完全覆蓋，直接加上區間大小，否則加上seg[左右子樹]    seg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)                  +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);&#125;int main()&#123;    ios;    memset(arr,0,sizeof(arr));    memset(seg,0,sizeof(seg));        cin&gt;&gt;n;                                   //依序輸入左右下上：x1,x2,y1,y2    for(int i=0;i&lt;(n&lt;&lt;1);i+=2)&#123;        int x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;y1&gt;&gt;y2;        arr[i] = (Node)&#123;x1,x2,y1,1&#125;;          //插入矩形下邊，帶入val = 1        arr[i+1] = (Node)&#123;x1,x2,y2,-1&#125;;       //上邊要val = -1    &#125;    stable_sort(arr,arr+(n&lt;&lt;1),cmp);          //依照y座標由小到大排序        int y0 = 0,val = 0;                       //有下而上的枚舉所有水平邊    lld ans = 0LL;                            //上一條y的座標，計算高，val為矩形結合起來的寬    for(int i=0;i&lt;(n&lt;&lt;1);i++)&#123;                //枚舉2n條y的邊        ans += (lld)(arr[i].y-y0)*val;        //計算面積（寬*高）        modify(1,0,M,arr[i].x1,arr[i].x2,arr[i].val);        y0 = arr[i].y;        val = seg[1].val;                     //修改後（下一輪）的矩陣寬度    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["C++進階主題","線段樹"],"tags":["2021暑假筆記","2020資訊之芽"]},{"title":"[題解]NEOJ 19 大善人老闆救濟東南亞兒童","url":"/sprout1-2-1/","content":"大善人老闆救濟東南亞兒童\n題目連結這一題很熟悉，在去年9月剛開學的資讀學長有講過，結果那時候根本聽不懂QQ但現在來看，這一題就是模擬stack ，很基礎的題目可以用queue (也可以不用)配上stack，分別模擬Station 跟B站 的情況\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        stack&lt;int&gt;s;        queue&lt;int&gt;q;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;arr[i];            q.push(arr[i]);        &#125;                for(int i=0;i&lt;n;i++)&#123;            s.push(i+1);//push 進station            while(!s.empty()&amp;&amp;!q.empty()&amp;&amp;s.top()==q.front())&#123;                s.pop();q.pop();            &#125;        &#125;        if(s.empty()&amp;&amp;q.empty())cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 20 中國人排隊問題","url":"/sprout1-2-2/","content":"中國人排隊問題\n題目連結這一題有一個條件有點難維護，就是如果同一團體的人要排隊而隊中已經有同一團人在裡面時，他就要排在團裡面最後一個位置因此要用iterator 陣列指向每個團隊的末端之類的好好維護細節可以減少debug 的時間！\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt = 1;int main()&#123;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;&quot;Line #&quot;&lt;&lt;cnt&lt;&lt;endl;        int arr[1000005],gt[1005];//紀錄在哪一個團體當中        memset(arr, 0, sizeof(arr));        memset(gt, 0, sizeof(gt));        for(int i=1;i&lt;=n;i++)&#123;            int k;cin&gt;&gt;k;            for(int j=0;j&lt;k;j++)&#123;                int temp;cin&gt;&gt;temp;                arr[temp] = i;            &#125;        &#125;        list&lt;int&gt; ls;        list&lt;int&gt;::iterator it[1005];//指向第i個團體的尾端        while(true)&#123;            string s;int cur;            cin&gt;&gt;s;            if(s[0]==&#x27;E&#x27;)&#123;                cin&gt;&gt;cur;                int i = arr[cur];                if(i&gt;0)&#123;                    if(gt[i]==0)&#123;                        ls.push_back(cur);                        it[i] = --ls.end();                    &#125;                    else&#123;                        it[i] = ls.insert(++it[i],cur);                    &#125;                    gt[i]++;                &#125;                else ls.push_back(cur);            &#125;            else if(s[0]==&#x27;D&#x27;)&#123;                int i = ls.front();                if(arr[i]&gt;0)gt[arr[i]]--;                cout&lt;&lt;ls.front()&lt;&lt;endl;                ls.pop_front();            &#125;            else break;        &#125;        cnt++;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 21 陸行鳥大賽車","url":"/sprout1-2-3/","content":"陸行鳥大賽車\n題目連結這一題我嘗試了兩個方法第一個方法：用vector 紀錄名次，但就是會TLE ，原因：需要O(N)找到當前的車車在第幾名，如果遭受攻擊，也要用O(N)來erase vector的元素，結果長這樣：講師說：不要用vector 的erase ，因為他會耗費O(N)的時間\n第二個方法：用一個struct 的陣列，裡面包了每一台車的資訊包含他的名次，這樣就可以用O(1)更改每一台車的名次，算是第一個算法的優化\n#include &lt;bits/stdc++.h&gt;using namespace std;int N,M;struct node&#123;    int player_id;    node *next,*prev;    node()&#123;        next = NULL;        prev = NULL;    &#125;&#125;;node *player[100005];signed main()&#123;    ios    cin&gt;&gt;N&gt;&gt;M;    for(int i=0;i&lt;=N+2;i++)&#123;        player[i] = new node();        player[i]-&gt;player_id = i;    &#125;    for(int i=1;i&lt;=N+2;i++)&#123;        player[i]-&gt;prev = player[i-1];        player[i]-&gt;next = player[i+1];    &#125;//初始化設定    for(int i=0;i&lt;M;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(a==0)&#123;            player[b]-&gt;prev-&gt;next = player[b]-&gt;next;            player[b]-&gt;next-&gt;prev = player[b]-&gt;prev;        &#125;//編號b的車車被消滅        else&#123;            if(!player[b]-&gt;prev-&gt;prev)continue;            int pp,p,n;            pp = player[b]-&gt;prev-&gt;prev-&gt;player_id;            p = player[b]-&gt;prev-&gt;player_id;            n = player[b]-&gt;next-&gt;player_id;                        player[pp]-&gt;next = player[b];            player[b]-&gt;prev = player[pp];            player[b]-&gt;next = player[p];            player[p]-&gt;next = player[n];            player[n]-&gt;prev = player[p];            player[p]-&gt;prev = player[b];        &#125;//交換名次的部分，不過應該有方法可以更簡單    &#125;    stack&lt;int&gt; s;    int ind = N+1;    while(player[ind]-&gt;prev!=NULL)&#123;        if(ind!=N+1)&#123;            s.push(player[ind]-&gt;player_id);        &#125;        ind = player[ind]-&gt;prev-&gt;player_id;    &#125;    while(!s.empty()&amp;&amp;s.size()!=1)&#123;        cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;        s.pop();    &#125;    cout&lt;&lt;s.top()&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 513 超大螢幕設置","url":"/sprout1-2-4/","content":"超大螢幕設置\n題目連結講師在課堂上有講解這個題目的算法，就是對每個「大樓」（剛剛看才知道）分別往左往右看（單調隊列），看到第一個小於自己就停止單調隊列問了講師之後，參照他的寫法，用vector 儲存「位置的index」而不要用pair ，明顯增加了程式碼的易讀性！\n這是用pair 版本：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    vector&lt;pair&lt;int,int&gt;&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        vec.push_back(make_pair(temp, i+1));    &#125;    int ans[n+5][2];    stack&lt;pair&lt;int, int&gt;&gt; p;    p.push(vec[0]);        for(int i=1;i&lt;n;i++)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][0] = i-p.top().second+1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][0] = n-p.top().second+1;        p.pop();    &#125;    p.push(vec[n-1]);        for(int i=n-2;i&gt;=0;i--)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][1] = p.top().second-i-1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][1] = p.top().second;        p.pop();    &#125;        int total = 0;    for(int i=0;i&lt;n;i++)&#123;        int sum =0;        sum = vec[i].first*(ans[i][0]+ans[i][1]-1);        total = max(total,sum);    &#125;    cout&lt;&lt;total&lt;&lt;endl;&#125;\n而這個是用講師習慣的作法，明顯短了很多：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    int arr[n+5],lft[n+5],rht[n+5];    memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    vector&lt;int&gt; stk(1,0);        for(int i=1;i&lt;=n;i++)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        lft[i] = i-stk.back();        stk.push_back(i);    &#125;    while(!stk.empty())stk.pop_back();        stk.push_back(n+1);        for(int i=n;i&gt;=1;i--)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        rht[i] = stk.back()-i-1;        stk.push_back(i);    &#125;    int ans[n+5];    for(int i=1;i&lt;=n;i++)&#123;        ans[i-1] = arr[i]*(lft[i]+rht[i]);    &#125;    cout&lt;&lt;*max_element(ans,ans+n)&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 22 檸檬汽水傳說（NPSC）","url":"/sprout1-2-5/","content":"檸檬汽水傳說（NPSC）\n題目連結這題我覺得很難！一開始想說維護一個遞增的單調隊列，沒想到一直吃WA好吧，上網找答案結果是發現，題目很機車的需要處理相同元素的情況因為一排一樣的數字可以橫跨很多個數字，形成數對好不容易處理完之後上傳code 又吃WAdebug 了好久，才發現是因為第一個連續出現的數字好好處理因為第一個數字就算跟後面連續的數字相同也不能再跟前面構成任何數對！總算，經過好久好久，終於才AC ，真是得來不易！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n,t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        vector&lt;int&gt; s;                int ans = 0,cnt[1000005];        memset(cnt, 0, sizeof(cnt));//紀錄s當下該數出現次數        while(n--)&#123;            int k,top = s.size();cin&gt;&gt;k;                        while(!s.empty() &amp;&amp; s.back()&lt;k)&#123;                cnt[top--] = 0;                s.pop_back();                ans++;            &#125;            if(s.empty())s.push_back(k);            else&#123;                if(s.back()==k &amp;&amp; top&gt;1)&#123;                    cnt[top+1]+=cnt[top]+1;                    ans+=cnt[top+1];                &#125;                s.push_back(k);ans++;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 48 二元搜尋樹","url":"/sprout1-2-6/","content":"二元搜尋樹\n題目連結很特別的一題，原來BST 用中序遍歷就是排序好的數列！有了前序跟中序之後，就可以透過遞迴來還原整棵二元樹了！\n#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Node&#123;    Node *left;    Node *right;    int val;&#125;;Node* BinaryTree(int* preorder, int* inorder, int length)&#123;    if(length==0)return NULL;    Node *node = new Node;    node-&gt;val = *preorder;        int root_index = 0;    for(;root_index&lt;length;root_index++)&#123;        if(inorder[root_index]==*preorder)break;    &#125;    node-&gt;left = BinaryTree(preorder+1, inorder,root_index);    node-&gt;right = BinaryTree(preorder+root_index+1, inorder+root_index+1,length-root_index-1);    cout&lt;&lt;node-&gt;val&lt;&lt;endl;    return node;&#125;signed main()&#123;    int arr[2005],sorted[2005];    while(cin&gt;&gt;arr[n])&#123;        sorted[n] = arr[n];        n++;    &#125;    sort(sorted, sorted+n);    BinaryTree(arr, sorted, n);&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 293 樹重心","url":"/sprout1-2-7/","content":"樹重心\n題目連結超愛這一題，竟然可以用DFS 跑一次O(N)把所有的點的資訊全部求出來透過簡單的運算把看起來很複雜的題目很優美的解出來！\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;vector&lt;int&gt; Edge[100005];bool visit[100005];struct Node&#123;    int sum;//子節點總數（扣掉算父節點）    int maxn;//子數最大的那一個&#125;node[100005];int dfs(int id)&#123;    visit[id] = true;    int len = Edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = Edge[id][i];        if(visit[temp]==1)continue;        int t = dfs(temp);        node[id].sum += t;        node[id].maxn = max(node[id].maxn,t);    &#125;    return node[id].sum+1;&#125;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n;cin&gt;&gt;n;        memset(visit, 0, sizeof(visit));                for(int i=0;i&lt;n;i++)&#123;//initialize            Edge[i].clear();            node[i].maxn = node[i].sum = 0;        &#125;        for(int i=0;i&lt;n-1;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            Edge[a].push_back(b);            Edge[b].push_back(a);        &#125;        dfs(0);        int ans = n,index = 0;        for(int i=0;i&lt;n;i++)&#123;            int temp = max(node[i].maxn,n-node[i].sum-1);//子與父求慘度            if(temp&lt;ans)&#123;                index = i;                ans = temp;            &#125;        &#125;        cout&lt;&lt;index&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第一、二週：基礎資結、複雜度、樹","url":"/sprout1-2/","content":"第一次上課，原本想說會輕鬆的度過一個禮拜沒想到直接用單調隊列當作開場，讓第一個星期圍繞著stack 與queue的資結世界中但也很慶幸的，在第一週終於學會用很節簡的程式碼寫單調隊列第二週的內容則是複雜度分析P 與NP 問題真讓人一頭是大，雖然在競程中對於較複雜的複雜度問題很少派上用場不過還是蠻有趣的，只要證明P=NP就可以很多錢了！\n\n上課內容第一週主題：基礎資料結構（queue, stack, 單調隊列）第二週主題：複雜度分析、樹狀結構\n上機作業挑幾題比較有趣的\n大善人老闆救濟東南亞兒童題目連結這一題很熟悉，在去年9月剛開學的資讀學長有講過，結果那時候根本聽不懂QQ但現在來看，這一題就是模擬stack ，很基礎的題目可以用queue (也可以不用)配上stack，分別模擬Station 跟B站 的情況\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        stack&lt;int&gt;s;        queue&lt;int&gt;q;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;arr[i];            q.push(arr[i]);        &#125;                for(int i=0;i&lt;n;i++)&#123;            s.push(i+1);//push 進station            while(!s.empty()&amp;&amp;!q.empty()&amp;&amp;s.top()==q.front())&#123;                s.pop();q.pop();            &#125;        &#125;        if(s.empty()&amp;&amp;q.empty())cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    &#125;&#125;\n中國人排隊問題題目連結這一題有一個條件有點難維護，就是如果同一團體的人要排隊而隊中已經有同一團人在裡面時，他就要排在團裡面最後一個位置因此要用iterator 陣列指向每個團隊的末端之類的好好維護細節可以減少debug 的時間！\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt = 1;int main()&#123;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;&quot;Line #&quot;&lt;&lt;cnt&lt;&lt;endl;        int arr[1000005],gt[1005];//紀錄在哪一個團體當中        memset(arr, 0, sizeof(arr));        memset(gt, 0, sizeof(gt));        for(int i=1;i&lt;=n;i++)&#123;            int k;cin&gt;&gt;k;            for(int j=0;j&lt;k;j++)&#123;                int temp;cin&gt;&gt;temp;                arr[temp] = i;            &#125;        &#125;        list&lt;int&gt; ls;        list&lt;int&gt;::iterator it[1005];//指向第i個團體的尾端        while(true)&#123;            string s;int cur;            cin&gt;&gt;s;            if(s[0]==&#x27;E&#x27;)&#123;                cin&gt;&gt;cur;                int i = arr[cur];                if(i&gt;0)&#123;                    if(gt[i]==0)&#123;                        ls.push_back(cur);                        it[i] = --ls.end();                    &#125;                    else&#123;                        it[i] = ls.insert(++it[i],cur);                    &#125;                    gt[i]++;                &#125;                else ls.push_back(cur);            &#125;            else if(s[0]==&#x27;D&#x27;)&#123;                int i = ls.front();                if(arr[i]&gt;0)gt[arr[i]]--;                cout&lt;&lt;ls.front()&lt;&lt;endl;                ls.pop_front();            &#125;            else break;        &#125;        cnt++;    &#125;&#125;\n陸行鳥大賽車題目連結這一題我嘗試了兩個方法第一個方法：用vector 紀錄名次，但就是會TLE ，原因：需要O(N)找到當前的車車在第幾名，如果遭受攻擊，也要用O(N)來erase vector的元素，結果長這樣：講師說：不要用vector 的erase ，因為他會耗費O(N)的時間\n第二個方法：用一個struct 的陣列，裡面包了每一台車的資訊包含他的名次，這樣就可以用O(1)更改每一台車的名次，算是第一個算法的優化\n#include &lt;bits/stdc++.h&gt;using namespace std;int N,M;struct node&#123;    int player_id;    node *next,*prev;    node()&#123;        next = NULL;        prev = NULL;    &#125;&#125;;node *player[100005];signed main()&#123;    ios    cin&gt;&gt;N&gt;&gt;M;    for(int i=0;i&lt;=N+2;i++)&#123;        player[i] = new node();        player[i]-&gt;player_id = i;    &#125;    for(int i=1;i&lt;=N+2;i++)&#123;        player[i]-&gt;prev = player[i-1];        player[i]-&gt;next = player[i+1];    &#125;//初始化設定    for(int i=0;i&lt;M;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(a==0)&#123;            player[b]-&gt;prev-&gt;next = player[b]-&gt;next;            player[b]-&gt;next-&gt;prev = player[b]-&gt;prev;        &#125;//編號b的車車被消滅        else&#123;            if(!player[b]-&gt;prev-&gt;prev)continue;            int pp,p,n;            pp = player[b]-&gt;prev-&gt;prev-&gt;player_id;            p = player[b]-&gt;prev-&gt;player_id;            n = player[b]-&gt;next-&gt;player_id;                        player[pp]-&gt;next = player[b];            player[b]-&gt;prev = player[pp];            player[b]-&gt;next = player[p];            player[p]-&gt;next = player[n];            player[n]-&gt;prev = player[p];            player[p]-&gt;prev = player[b];        &#125;//交換名次的部分，不過應該有方法可以更簡單    &#125;    stack&lt;int&gt; s;    int ind = N+1;    while(player[ind]-&gt;prev!=NULL)&#123;        if(ind!=N+1)&#123;            s.push(player[ind]-&gt;player_id);        &#125;        ind = player[ind]-&gt;prev-&gt;player_id;    &#125;    while(!s.empty()&amp;&amp;s.size()!=1)&#123;        cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;        s.pop();    &#125;    cout&lt;&lt;s.top()&lt;&lt;endl;&#125;\n超大螢幕設置題目連結講師在課堂上有講解這個題目的算法，就是對每個「大樓」（剛剛看才知道）分別往左往右看（單調隊列），看到第一個小於自己就停止單調隊列問了講師之後，參照他的寫法，用vector 儲存「位置的index」而不要用pair ，明顯增加了程式碼的易讀性！\n這是用pair 版本：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    vector&lt;pair&lt;int,int&gt;&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        vec.push_back(make_pair(temp, i+1));    &#125;    int ans[n+5][2];    stack&lt;pair&lt;int, int&gt;&gt; p;    p.push(vec[0]);        for(int i=1;i&lt;n;i++)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][0] = i-p.top().second+1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][0] = n-p.top().second+1;        p.pop();    &#125;    p.push(vec[n-1]);        for(int i=n-2;i&gt;=0;i--)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][1] = p.top().second-i-1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][1] = p.top().second;        p.pop();    &#125;        int total = 0;    for(int i=0;i&lt;n;i++)&#123;        int sum =0;        sum = vec[i].first*(ans[i][0]+ans[i][1]-1);        total = max(total,sum);    &#125;    cout&lt;&lt;total&lt;&lt;endl;&#125;\n而這個是用講師習慣的作法，明顯短了很多：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    int arr[n+5],lft[n+5],rht[n+5];    memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    vector&lt;int&gt; stk(1,0);        for(int i=1;i&lt;=n;i++)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        lft[i] = i-stk.back();        stk.push_back(i);    &#125;    while(!stk.empty())stk.pop_back();        stk.push_back(n+1);        for(int i=n;i&gt;=1;i--)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        rht[i] = stk.back()-i-1;        stk.push_back(i);    &#125;    int ans[n+5];    for(int i=1;i&lt;=n;i++)&#123;        ans[i-1] = arr[i]*(lft[i]+rht[i]);    &#125;    cout&lt;&lt;*max_element(ans,ans+n)&lt;&lt;endl;&#125;\n檸檬汽水傳說（NPSC）題目連結這題我覺得很難！一開始想說維護一個遞增的單調隊列，沒想到一直吃WA好吧，上網找答案結果是發現，題目很機車的需要處理相同元素的情況因為一排一樣的數字可以橫跨很多個數字，形成數對好不容易處理完之後上傳code 又吃WAdebug 了好久，才發現是因為第一個連續出現的數字好好處理因為第一個數字就算跟後面連續的數字相同也不能再跟前面構成任何數對！總算，經過好久好久，終於才AC ，真是得來不易！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n,t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        vector&lt;int&gt; s;                int ans = 0,cnt[1000005];        memset(cnt, 0, sizeof(cnt));//紀錄s當下該數出現次數        while(n--)&#123;            int k,top = s.size();cin&gt;&gt;k;                        while(!s.empty() &amp;&amp; s.back()&lt;k)&#123;                cnt[top--] = 0;                s.pop_back();                ans++;            &#125;            if(s.empty())s.push_back(k);            else&#123;                if(s.back()==k &amp;&amp; top&gt;1)&#123;                    cnt[top+1]+=cnt[top]+1;                    ans+=cnt[top+1];                &#125;                s.push_back(k);ans++;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n二元搜尋樹題目連結很特別的一題，原來BST 用中序遍歷就是排序好的數列！有了前序跟中序之後，就可以透過遞迴來還原整棵二元樹了！\n#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Node&#123;    Node *left;    Node *right;    int val;&#125;;Node* BinaryTree(int* preorder, int* inorder, int length)&#123;    if(length==0)return NULL;    Node *node = new Node;    node-&gt;val = *preorder;        int root_index = 0;    for(;root_index&lt;length;root_index++)&#123;        if(inorder[root_index]==*preorder)break;    &#125;    node-&gt;left = BinaryTree(preorder+1, inorder,root_index);    node-&gt;right = BinaryTree(preorder+root_index+1, inorder+root_index+1,length-root_index-1);    cout&lt;&lt;node-&gt;val&lt;&lt;endl;    return node;&#125;signed main()&#123;    int arr[2005],sorted[2005];    while(cin&gt;&gt;arr[n])&#123;        sorted[n] = arr[n];        n++;    &#125;    sort(sorted, sorted+n);    BinaryTree(arr, sorted, n);&#125;\n樹重心題目連結超愛這一題，竟然可以用DFS 跑一次O(N)把所有的點的資訊全部求出來透過簡單的運算把看起來很複雜的題目很優美的解出來！\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;vector&lt;int&gt; Edge[100005];bool visit[100005];struct Node&#123;    int sum;//子節點總數（扣掉算父節點）    int maxn;//子數最大的那一個&#125;node[100005];int dfs(int id)&#123;    visit[id] = true;    int len = Edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = Edge[id][i];        if(visit[temp]==1)continue;        int t = dfs(temp);        node[id].sum += t;        node[id].maxn = max(node[id].maxn,t);    &#125;    return node[id].sum+1;&#125;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n;cin&gt;&gt;n;        memset(visit, 0, sizeof(visit));                for(int i=0;i&lt;n;i++)&#123;//initialize            Edge[i].clear();            node[i].maxn = node[i].sum = 0;        &#125;        for(int i=0;i&lt;n-1;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            Edge[a].push_back(b);            Edge[b].push_back(a);        &#125;        dfs(0);        int ans = n,index = 0;        for(int i=0;i&lt;n;i++)&#123;            int temp = max(node[i].maxn,n-node[i].sum-1);//子與父求慘度            if(temp&lt;ans)&#123;                index = i;                ans = temp;            &#125;        &#125;        cout&lt;&lt;index&lt;&lt;endl;    &#125;&#125;\n手寫作業這兩週手寫都是數學證明！有夠悲慘，因為題目很多都不會啊，還要去問老師，結果老師也沒有給出一個好的解方FF換個角度想，就算脫離數學證明，作業一樣不會簡單到哪裡去的！\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","樹","資結"]},{"title":"[題解]TIOJ 1211 最小生成樹","url":"/sprout10-1/","content":"最小生成樹\n題目連結NEOJ題目連結TIOJ實作講義資芽講義\n這一題手刻最小生成樹，感覺蠻好的，都是利用一些性質來實作最小生成樹\n性質一：樹最小生成圖一定會是一棵樹，不具備環，且一共有n-1條邊如果這張圖不是樹，則必定有環，即代表可以再拔掉一條邊使權重和更小\n性質二：Cycle PropertyC是圖上的一個環，e是C上權重最大一條邊，則e必不在MST一部分（證明：反證，假設e在MST，則加入另一邊比e權重更小形成環，此時把e拔掉可以形成更小的權重和，因此矛盾）\n性質三：Cut Property把圖上的點集分割成兩半，則cut上面的邊集合中最小權重的邊e會在MST裡面（證明：反證，假設e不在MST，則加入e會形成連接兩半節點的環，此時拔掉另一比e權重大的邊，會形成更小權重和，因此矛盾）\n利用性質二、性質三，就可以利用Kruskal演算法：利用到併查集的維護搭配路徑壓縮，可以快速判斷一個元素是否與另一個元素同屬一個集合（複雜度幾乎可以$O(1)$，更準確來說是$O(\\alpha)$），Kruskal總複雜度為 $O(ElogE)$另外還有一種實作方式Prim’s algorithm，等等再看\n\n            實作步驟1. 初始化設定： 設定好boss以及集合大小等參數2. 對所有的邊依照權重排序： 利用$O(m\\log m)$的時間排序，將邊依照權重由小到大加入MST中3. 依序加入邊： 以下會有兩種情況，可以用並查集+路徑壓縮（優化）判斷是否會形成環Case 1: 如果加了這條邊形成環（查到有一樣的boss）那這條邊會是這個環上的最大邊根據 Cycle property，這條邊不會是MST的一部分Case 2: 加了這條邊不會形成環那這條邊是條橋，連接左右兩棵樹根據 Cut Property，因為這條邊是這個 cut 上最小的邊所以這條邊會是 MST 的一部分4. 判斷是否合法： n個點所形成的樹會有n-1條邊，最小生成樹是一棵樹就必須滿足條件。\n          \nKRUSKAL’S ALGORITHM\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,num[N],boss[N];struct Node&#123;    int x,y,w;&#125;edge[N];bool cmp(Node a, Node b)&#123;    return a.w &lt; b.w;&#125;int findboss(int a)&#123;                    //尋找集合的老大（代表整個集合）    if(a==boss[a])return a;    return boss[a]=findboss(boss[a]);   //遞迴搭配路徑壓縮&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].w;    &#125;    for(int i=0;i&lt;n;i++)&#123;        num[i] = 1;        boss[i] = i;    &#125;    sort(edge,edge+m,cmp);                 //依照權重大小放入MST    int result = 0,num_edge = 0;    for(int i=0;i&lt;m &amp;&amp; num_edge&lt;n;i++)&#123;    //樹必須滿足小於n-1條邊        int a = findboss(edge[i].x),b = findboss(edge[i].y);        if(a!=b)&#123;                          //boss不同可以放入MST（加入不會形成環by Cut Property）            if(num[a]&gt;=num[b])&#123;            //執行啟發式合併                boss[b] = a;                num[a]+=num[b];            &#125;            else&#123;                boss[a] = b;                num[b]+=num[a];            &#125;            result+=edge[i].w;            num_edge++;        &#125;    &#125;    cout&lt;&lt;result&lt;&lt;endl;    //這邊可以判斷num_edge==n-1有沒有成立，不過題目是輸入都可以形成MST&#125;\nPrim’s Algorithm是一種貪婪演算法，首先取任一點加入最小生成樹中，接著將連到的邊加入heap中，每一次取出heap中邊權重最小的邊，如果這一條邊連到的點尚未被走訪，則加入這一條邊為最小生成數。正確性證明則可用cut proprity證明每次都加入權重最小的邊即為最小生成數。\n\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 200005#define eps 1e-9#define x first#define y secondusing namespace std;int n,m;bool visit[N];struct node&#123;    int to,w;&#125;;vector&lt;node&gt; edge[N];struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.w &gt; b.w;    &#125;&#125;;signed main()&#123;    Orz;    memset(visit,0,sizeof(visit));    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,m-1)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;    visit[1] = 1;    for(auto i : edge[1])pq.push(i);    int num_edge = 0,ans = 0;    while(num_edge &lt; n-1)&#123;        node x = pq.top();pq.pop();        if(visit[x.to])continue;        visit[x.to] = 1;        num_edge += 1;        ans += x.w;        for(auto i : edge[x.to])&#123;            pq.push(i);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 169 高棕櫚的意外收穫","url":"/sprout10-2/","content":"高棕櫚的意外收穫\n題目連結講義連結\n這一題就是按照字典序print出尤拉路徑，特別用鄰接矩陣來存圖是因為要按照字典序輸出，如果用鏈結串列來存還要花時間排序，因此用大一點的空間來節省時間\n尤拉路徑也是一筆畫問題，每一個節點一定會有進有出，因此原先的無向圖上每一點一定度數為偶數，若有奇點則選擇其中一個奇點作為起點，當奇點數量超過兩個則代表無解。我們將DFS的過程中離開當前節點的順序紀錄起來，逆序輸出就是一組合法歐拉迴路的解了！\n            實作程序1. 判斷奇點個數，若奇點個數k：k &gt; 2，那麼無解k = 2，則選擇其中一個奇點作為起點k = 0，則選擇任意一個點作為起點2. DFS 執行下列步驟若當前節點還有尚未走過的邊，那麼拜訪該邊，並在拜訪完後輸出該邊否則離開當前結點3. 若還有節點尚未拜訪，則無解4. 否則輸出順序即為一組解\n          \n#include &lt;bits/stdc++.h&gt;#define N 501using namespace std;int n,Edge[N][N],ans[1025],ind = 0;void DFS(int cur)&#123;    for(int i=1;i&lt;=500;i++)&#123;        if(Edge[cur][i])&#123;            Edge[cur][i]--;Edge[i][cur]--;            DFS(i);        &#125;    &#125;    ans[ind++] = cur;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(Edge, 0, sizeof(Edge));    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        Edge[a][b]++;        Edge[b][a]++;    &#125;    int start = 1;                //開始的節點編號    for(int i=1;i&lt;=500;i++)&#123;        int sum = 0;        for(int j=1;j&lt;=500;j++)&#123;            sum+=Edge[i][j];        &#125;        if(sum%2!=0)&#123;             //找到第一個度數為奇數的節點            start = i;            break;        &#125;    &#125;    DFS(start);    for(int i=ind-1;i&gt;=0;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 165 陣線推進","url":"/sprout10-3/","content":"陣線推進\n題目連結拓墣排序題，兩種實作方式，第一是BFS變形實作（queue實作），被pop出來的順序就是topological sort第二種就是DFS搭配時間戳記，最晚離開的放在最前面\n這一題是把入度為0的節點先push進priority_queue（按照字典序），當一個點處理過之後，入度變成0的所有它指向的點在push進queue裡面拓墣排序可以用在DAG的判定以及解決具有依賴關係的問題\n#include &lt;bits/stdc++.h&gt;#define N 100001using namespace std;int t,n,m,deg[N];//入度int ans[N],ind = 0;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        memset(deg,0,sizeof(deg));        memset(ans, 0, sizeof(ans));        ind = 0;        vector&lt;int&gt; edge[N];        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;m;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            deg[b]++;        &#125;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qq;//priority_queue取代queue        for(int i=0;i&lt;n;i++)if(deg[i]==0)qq.push(i);        while(!qq.empty())&#123;            int cur = qq.top();            qq.pop();            ans[ind++] = cur;            int len = edge[cur].size();            for(int i=0;i&lt;len;i++)&#123;                deg[edge[cur][i]]--;                if(deg[edge[cur][i]]==0)                    qq.push(edge[cur][i]);            &#125;        &#125;        if(ind==n)&#123;            cout&lt;&lt;ans[0];            for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];            cout&lt;&lt;endl;        &#125;        else cout&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第十週：進階圖論（一）","url":"/sprout10/","content":"上課內容並查集 Disjoint Set目標：快速判斷兩個元素是否同屬一個集合功能：詢問元素隸屬的集合、合併兩個集合，在圖論中，集合通常表示連通快，並查集可以查詢任兩點是否連通。在實作MST的時候，當我們要檢查兩個點連接成的邊是否會跟其他已經加入的邊形成環，就會使用並查集幫助我們判斷！複雜度：非常優秀，可以說是O(1)#include &lt;bits/stdc++.h&gt;#define N 100001using namespace std;int n,boss[N],num[N];int find_boss(int a)&#123;        //使用路徑壓縮    if(a==boss[a])return a;    else return boss[a] = find_boss(boss[a]);&#125;void merge(int a,int b)&#123;    //啟發式合併    if(num[a]&gt;=num[b])&#123;     //較小的集合合併到較大的集合        num[a] += num[b];        boss[b] = a;    &#125;    else&#123;        num[b] += num[a];        boss[a] = b;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        boss[i] = i;        num[i] = 1;    &#125;    while(1)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;                    //要查詢兩個元素        a = find_boss(a),b = find_boss(b);    //判斷是否同屬一個集合        if(a!=b)&#123;                             //老大不同屬不同集合            cout&lt;&lt;&quot;不同集合&quot;&lt;&lt;endl;            merge(a, b);        &#125;        else cout&lt;&lt;&quot;同集合&quot;&lt;&lt;endl;        for(int i=1;i&lt;=n;i++)cout&lt;&lt;boss[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;&#125;\n\n            路徑壓縮在回傳過程中順便利用遞迴把所經過的boss指向最上面的boss，由左圖變成右圖，效率更高（實測其實差不多，可能logn已經夠小加上遞迴本來就比較慢）用遞迴實現的特性實現，遞迴拉上來的時候順便更新boss[x]：路徑壓縮搭配啟發式合併，複雜度：$O(α(N))$等同常數\n          \n上機作業最小生成樹題目連結NEOJ題目連結TIOJ實作講義資芽講義\n這一題手刻最小生成樹，感覺蠻好的，都是利用一些性質來實作最小生成樹\n性質一：樹最小生成圖一定會是一棵樹，不具備環，且一共有n-1條邊如果這張圖不是樹，則必定有環，即代表可以再拔掉一條邊使權重和更小\n性質二：Cycle PropertyC是圖上的一個環，e是C上權重最大一條邊，則e必不在MST一部分（證明：反證，假設e在MST，則加入另一邊比e權重更小形成環，此時把e拔掉可以形成更小的權重和，因此矛盾）\n性質三：Cut Property把圖上的點集分割成兩半，則cut上面的邊集合中最小權重的邊e會在MST裡面（證明：反證，假設e不在MST，則加入e會形成連接兩半節點的環，此時拔掉另一比e權重大的邊，會形成更小權重和，因此矛盾）\n利用性質二、性質三，就可以利用Kruskal演算法：利用到併查集的維護搭配路徑壓縮，可以快速判斷一個元素是否與另一個元素同屬一個集合（複雜度幾乎可以$O(1)$，更準確來說是$O(\\alpha)$），Kruskal總複雜度為 $O(ElogE)$另外還有一種實作方式Prim’s algorithm，等等再看\n\n            實作步驟1. 初始化設定： 設定好boss以及集合大小等參數2. 對所有的邊依照權重排序： 利用$O(m\\log m)$的時間排序，將邊依照權重由小到大加入MST中3. 依序加入邊： 以下會有兩種情況，可以用並查集+路徑壓縮（優化）判斷是否會形成環Case 1: 如果加了這條邊形成環（查到有一樣的boss）那這條邊會是這個環上的最大邊根據 Cycle property，這條邊不會是MST的一部分Case 2: 加了這條邊不會形成環那這條邊是條橋，連接左右兩棵樹根據 Cut Property，因為這條邊是這個 cut 上最小的邊所以這條邊會是 MST 的一部分4. 判斷是否合法： n個點所形成的樹會有n-1條邊，最小生成樹是一棵樹就必須滿足條件。\n          \nKRUSKAL’S ALGORITHM\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,num[N],boss[N];struct Node&#123;    int x,y,w;&#125;edge[N];bool cmp(Node a, Node b)&#123;    return a.w &lt; b.w;&#125;int findboss(int a)&#123;                    //尋找集合的老大（代表整個集合）    if(a==boss[a])return a;    return boss[a]=findboss(boss[a]);   //遞迴搭配路徑壓縮&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].w;    &#125;    for(int i=0;i&lt;n;i++)&#123;        num[i] = 1;        boss[i] = i;    &#125;    sort(edge,edge+m,cmp);                 //依照權重大小放入MST    int result = 0,num_edge = 0;    for(int i=0;i&lt;m &amp;&amp; num_edge&lt;n;i++)&#123;    //樹必須滿足小於n-1條邊        int a = findboss(edge[i].x),b = findboss(edge[i].y);        if(a!=b)&#123;                          //boss不同可以放入MST（加入不會形成環by Cut Property）            if(num[a]&gt;=num[b])&#123;            //執行啟發式合併                boss[b] = a;                num[a]+=num[b];            &#125;            else&#123;                boss[a] = b;                num[b]+=num[a];            &#125;            result+=edge[i].w;            num_edge++;        &#125;    &#125;    cout&lt;&lt;result&lt;&lt;endl;    //這邊可以判斷num_edge==n-1有沒有成立，不過題目是輸入都可以形成MST&#125;\nPrim’s Algorithm是一種貪婪演算法，首先取任一點加入最小生成樹中，接著將連到的邊加入heap中，每一次取出heap中邊權重最小的邊，如果這一條邊連到的點尚未被走訪，則加入這一條邊為最小生成數。正確性證明則可用cut proprity證明每次都加入權重最小的邊即為最小生成數。\n\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 200005#define eps 1e-9#define x first#define y secondusing namespace std;int n,m;bool visit[N];struct node&#123;    int to,w;&#125;;vector&lt;node&gt; edge[N];struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.w &gt; b.w;    &#125;&#125;;signed main()&#123;    Orz;    memset(visit,0,sizeof(visit));    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,m-1)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;    visit[1] = 1;    for(auto i : edge[1])pq.push(i);    int num_edge = 0,ans = 0;    while(num_edge &lt; n-1)&#123;        node x = pq.top();pq.pop();        if(visit[x.to])continue;        visit[x.to] = 1;        num_edge += 1;        ans += x.w;        for(auto i : edge[x.to])&#123;            pq.push(i);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n高棕櫚的意外收穫題目連結講義連結\n這一題就是按照字典序print出尤拉路徑，特別用鄰接矩陣來存圖是因為要按照字典序輸出，如果用鏈結串列來存還要花時間排序，因此用大一點的空間來節省時間\n尤拉路徑也是一筆畫問題，每一個節點一定會有進有出，因此原先的無向圖上每一點一定度數為偶數，若有奇點則選擇其中一個奇點作為起點，當奇點數量超過兩個則代表無解。我們將DFS的過程中離開當前節點的順序紀錄起來，逆序輸出就是一組合法歐拉迴路的解了！\n            實作程序1. 判斷奇點個數，若奇點個數k：k &gt; 2，那麼無解k = 2，則選擇其中一個奇點作為起點k = 0，則選擇任意一個點作為起點2. DFS 執行下列步驟若當前節點還有尚未走過的邊，那麼拜訪該邊，並在拜訪完後輸出該邊否則離開當前結點3. 若還有節點尚未拜訪，則無解4. 否則輸出順序即為一組解\n          \n#include &lt;bits/stdc++.h&gt;#define N 501using namespace std;int n,Edge[N][N],ans[1025],ind = 0;void DFS(int cur)&#123;    for(int i=1;i&lt;=500;i++)&#123;        if(Edge[cur][i])&#123;            Edge[cur][i]--;Edge[i][cur]--;            DFS(i);        &#125;    &#125;    ans[ind++] = cur;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(Edge, 0, sizeof(Edge));    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        Edge[a][b]++;        Edge[b][a]++;    &#125;    int start = 1;                //開始的節點編號    for(int i=1;i&lt;=500;i++)&#123;        int sum = 0;        for(int j=1;j&lt;=500;j++)&#123;            sum+=Edge[i][j];        &#125;        if(sum%2!=0)&#123;             //找到第一個度數為奇數的節點            start = i;            break;        &#125;    &#125;    DFS(start);    for(int i=ind-1;i&gt;=0;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;&#125;\n陣線推進題目連結拓墣排序題，兩種實作方式，第一是BFS變形實作（queue實作），被pop出來的順序就是topological sort第二種就是DFS搭配時間戳記，最晚離開的放在最前面\n這一題是把入度為0的節點先push進priority_queue（按照字典序），當一個點處理過之後，入度變成0的所有它指向的點在push進queue裡面拓墣排序可以用在DAG的判定以及解決具有依賴關係的問題\n#include &lt;bits/stdc++.h&gt;#define N 100001using namespace std;int t,n,m,deg[N];//入度int ans[N],ind = 0;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        memset(deg,0,sizeof(deg));        memset(ans, 0, sizeof(ans));        ind = 0;        vector&lt;int&gt; edge[N];        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;m;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            deg[b]++;        &#125;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qq;//priority_queue取代queue        for(int i=0;i&lt;n;i++)if(deg[i]==0)qq.push(i);        while(!qq.empty())&#123;            int cur = qq.top();            qq.pop();            ans[ind++] = cur;            int len = edge[cur].size();            for(int i=0;i&lt;len;i++)&#123;                deg[edge[cur][i]]--;                if(deg[edge[cur][i]]==0)                    qq.push(edge[cur][i]);            &#125;        &#125;        if(ind==n)&#123;            cout&lt;&lt;ans[0];            for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];            cout&lt;&lt;endl;        &#125;        else cout&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;    &#125;&#125;\n手寫作業這一次的手寫也蠻困難的，討論BIT(fenwick tree)的實作以及複雜度！\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","圖論"]},{"title":"[題解]NEOJ 183 高棕櫚傳遞鏈","url":"/sprout11-1/","content":"高棕櫚傳遞鏈\n題目連結在一張圖中找割點（定義：拔掉它整張圖就不連通了）作法：如果用暴力，可以每一個點拔掉，做一次DFS判斷是否聯通（效率太差）\n效率更高的就是Trajan 演算法找AP(articulation point)\n\n            Tarjan’s algorithm 找 AP邊的種類可以分成：Tree edge,Back edge,Forward edge,Cross edge，其中無向圖中只會有樹邊跟回邊（按照無向邊DFS的結果，Foward edge 都會變成子孫的back edge, cross edge 會變成樹邊）維護一個low函數，代表不經過父節點能到的最小時間戳記（進入）的節點，lv函數為當前節點的時間戳記。一個點是不是割點，只要他的任意子節點的low函數大於等於自己的時間戳記編號，那把這個點拔掉，他小孩就走不到祖先了（如果走得到祖先，對於這一棵子樹，拔掉當前節點就可利用此邊繼續連通），所以他就是割點。更新：$low[now] = min(low[now],low[next])$分別為利用子孫或靠自己\n          \n必須要注意的是，割點判斷時要把root的特例獨立判斷。其實root反而比較簡單，如果root有超過一個子樹，代表拔掉root以後會分裂成以每個子樹為單位的連通塊\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,low[N],lv[N],es=1,root,son_cnt = 0;bool visit[N],ans[N];vector&lt;int&gt; edge[N];//low函數為不經過父節點能到的最小時間戳記,lv為當前進入時間戳記void DFS(int now,int father)&#123;    visit[now] = 1;             //將此點設為已拜訪    low[now] = lv[now] = es++;  //進入的時間戳記        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;     //拜訪每一個子孫        int next = edge[now][i];        if(now==root &amp;&amp; !visit[next])son_cnt++;//計算root小孩（處理特例）        if(!visit[next])&#123;       //排除走到祖先的情況            DFS(next, now);            if(low[next]&gt;=lv[now] &amp;&amp; now!=root)ans[now]=1;            //無法透過小孩到達比自己淺的節點，將now設為AP        &#125;        if(next!=father)low[now] = min(low[now],low[next]);        //排除指向父親的情況，如果經過父親，拔掉就不能往更上面去    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(lv, 0, sizeof(lv));    memset(low, 0, sizeof(low));    memset(visit, 0, sizeof(visit));    memset(ans,0,sizeof(ans));        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(!visit[i])&#123;            root = i;            son_cnt = 0;            DFS(i, i);            if(son_cnt&gt;1)ans[root] = 1;        &#125;    &#125;    for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;i&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 179 謠言問題","url":"/sprout11-2/","content":"謠言問題\n題目連結跟上一題（高棕櫚傳遞鏈）蠻類似的，一樣找到割點，不同的是要在DFS過程中同時紀錄子樹節點的數量。如果碰到割點，維護拔掉它之後分裂出去那些子樹的節點個數，到時候透過節點總數-拔掉後分裂個數即可推算有幾個人會知道謠言，取min即可\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 30001using namespace std;int n,m,root,lv[N],low[N],tree_cnt[N],es = 1;bool visit[N],ans[N];vector&lt;int&gt; edge[N];int DFS(int now,int father)&#123;      //回傳當前子節點個數    visit[now] = 1;    lv[now] = es;    low[now] = es++;        int len = edge[now].size(),sum=1;//計算節點數    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];     //下一個節點                if(!visit[next])&#123;            int temp = DFS(next,now);            sum += temp;            if(low[next] &gt;= lv[now] &amp;&amp; now!=root)&#123; //不能拔掉root                ans[now] = 1;           //設為AP                tree_cnt[now] += temp;  //被拔掉後可被分割成幾個連通塊節點數            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;    return sum;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    cin&gt;&gt;root;        memset(ans, 0, sizeof(ans));    memset(visit, 0, sizeof(visit));    memset(tree_cnt, 0, sizeof(tree_cnt));        int sum = DFS(root,root),min_cnt = INT_MAX,min_pos = 0;        for(int i=1;i&lt;=n;i++)&#123;        int temp = sum-tree_cnt[i]; //拔掉後剩下連通塊大小（跟root連的）        if(ans[i] &amp;&amp; temp &lt; min_cnt)&#123;            min_pos = i;        //拔掉第幾個            min_cnt = temp;     //更新拔掉後剩下連通塊大小        &#125;    &#125;    if(min_cnt == INT_MAX)cout&lt;&lt;0&lt;&lt;endl;    else cout&lt;&lt;min_pos&lt;&lt;&quot; &quot;&lt;&lt;min_cnt&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 183 高棕櫚傳遞鏈","url":"/sprout11-3/","content":"高棕櫚傳遞鏈\n題目連結前兩題找割點，這一題是找橋，跟找割點的方法幾乎一樣，而且對於邊還不需要討論root的情況（root變成不是特例），然後判斷割點的 &gt;= 變成 &gt;，原因可以透過畫圖理解（把點拔掉跟把邊拔掉的差別），就可以實作了！題目有一個特別的要求，按照給邊的順序進行輸出，那可以搭配set來快速查看某一元素是否在集合內$O(logN)$，接著就按照給定的條件來輸出\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,lv[N],low[N],timestamp = 1;bool visit[N];vector&lt;int&gt; edge[N];vector&lt;pair&lt;int, int&gt;&gt; ans;set&lt;pair&lt;int, int&gt;&gt;s;void DFS(int now,int father)&#123;    lv[now] = low[now] = timestamp++;    visit[now] = 1;        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];                if(!visit[next])&#123;            DFS(next, now);            if(low[next] &gt; lv[now])&#123;                if(next&lt;now)s.insert(make_pair(next,now));                else s.insert(make_pair(now, next));            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);        ans.push_back(make_pair(x, y));    &#125;    memset(visit, 0, sizeof(visit));        for(int i=1;i&lt;=n;i++)&#123;        if(!visit[i])&#123;            DFS(i, i);        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        pair&lt;int, int&gt; temp = ans[i];        if(s.find(temp)!=s.end())&#123;            cout&lt;&lt;temp.first&lt;&lt;&quot; &quot;&lt;&lt;temp.second&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 739 芽芽逛大街","url":"/sprout11-4/","content":"芽芽逛大街\n題目連結有向無環圖的 case → DAG 最長路徑!將每個強連通元件縮成點後，因為內部的點可以一直亂走全部走到，所以只要將新點的點權更新成內部所有點的點權總和，得到一張新的有向無環圖，就可以直接做 DAG 最長路徑得到答案。\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500002using namespace std;int n,m,dfn[N],low[N],es = 1,stk_in[N],vertex_val[N],deg[N];//dfn為時間戳記,low為back, cross edge（經過最多一次）到達最小點dfn,stk_in是否在stack內bool visit[N];int scc[N],scc_ind = 0,scc_val[N];//紀錄屬於哪個scc,scc編號,scc編號的價值（權重和）int topological_order[N],ind = 0;struct edg&#123;    int to;    int val;&#125;;vector&lt;edg&gt; edge[N],new_edge[N];stack&lt;int&gt; s;void DFS(int now)&#123;    dfn[now] = low[now] = es++;    s.push(now);    stk_in[now] = 1;    visit[now] = 1;    int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i].to;        if(!visit[next])&#123;       //尚未拜訪則拜訪            DFS(next);            low[now] = min(low[now],low[next]);        &#125;        else if(stk_in[next])&#123;  //在stk內且已拜訪-&gt;同屬一個SCC            low[now] = min(low[now],dfn[next]);            //這條邊指向還沒出stack的點，可為cross or back edge 更新low[now]        &#125;    &#125;    //如果是scc就pop stack裡面的東西    if(low[now] == dfn[now])&#123;        stk_in[now] = 0;        //pop出stack裡面        scc[now] = ++scc_ind;   //進行SCC編號        scc_val[scc_ind] = vertex_val[now]; //更新點權        while(s.top()!=now)&#123;                //pop直到now被找到            scc[s.top()] = scc_ind;            stk_in[s.top()] = 0;            //pop出來            scc_val[scc_ind] += vertex_val[s.top()];            s.pop();        &#125;        s.pop();//將stack 中now也pop    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(visit, 0, sizeof(visit));    memset(stk_in, 0, sizeof(stk_in));    memset(deg, 0, sizeof(deg));    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        vertex_val[i] = x;    &#125;    for(int i=0;i&lt;m;i++)&#123;        int x,y,val;cin&gt;&gt;x&gt;&gt;y&gt;&gt;val;//x指向y        edge[x].push_back( edg&#123;y,val&#125; );    &#125;    for(int i=1;i&lt;=n;i++)        if(!visit[i])DFS(i);        //枚舉每一條邊更新邊權    for(int i=1;i&lt;=n;i++)&#123;        int len = edge[i].size();        for(int j=0;j&lt;len;j++)&#123;            int to = edge[i][j].to;            if(scc[to]==scc[i])&#123;                int ind = scc[to];                scc_val[ind]+=edge[i][j].val;            &#125;            else&#123;   //不同SCC指向不同的邊                new_edge[scc[i]].push_back( edg&#123;scc[to],edge[i][j].val&#125;);                deg[scc[to]]++;            &#125;        &#125;    &#125;        //Topological sort    queue&lt;int&gt; q;        for(int i=1;i&lt;=scc_ind;i++)        if(deg[i]==0)q.push(i);    while(!q.empty())&#123;        int now = q.front(),len = new_edge[now].size();        topological_order[ind++] = now;        q.pop();        for(int i=0;i&lt;len;i++)&#123;            int next = new_edge[now][i].to;            if(--deg[next]==0)q.push(next);        &#125;    &#125;        //拓墣排序完進行DP找最長路徑    int dp[ind],ans = 0;    for(int i=1;i&lt;=scc_ind;i++)&#123;        dp[i] = scc_val[i];        ans = max(ans, scc_val[i]);    &#125;        for(int i=0;i&lt;ind;i++)&#123;        int now = topological_order[i],len = new_edge[now].size();        for(int j=0;j&lt;len;j++)&#123;            int next = new_edge[now][j].to;            dp[next] = max(dp[next],scc_val[next]+dp[now]+new_edge[now][j].val);            ans = max(ans, dp[next]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第十一週：進階圖論（二）","url":"/sprout11/","content":"上課內容雙連通元件樹壓平、點雙連通、邊雙連通\nSCC強連通元件LCA（最低共同祖先）\n上機作業高棕櫚傳遞鏈題目連結在一張圖中找割點（定義：拔掉它整張圖就不連通了）作法：如果用暴力，可以每一個點拔掉，做一次DFS判斷是否聯通（效率太差）\n效率更高的就是Trajan 演算法找AP(articulation point)\n\n            Tarjan’s algorithm 找 AP邊的種類可以分成：Tree edge,Back edge,Forward edge,Cross edge，其中無向圖中只會有樹邊跟回邊（按照無向邊DFS的結果，Foward edge 都會變成子孫的back edge, cross edge 會變成樹邊）維護一個low函數，代表不經過父節點能到的最小時間戳記（進入）的節點，lv函數為當前節點的時間戳記。一個點是不是割點，只要他的任意子節點的low函數大於等於自己的時間戳記編號，那把這個點拔掉，他小孩就走不到祖先了（如果走得到祖先，對於這一棵子樹，拔掉當前節點就可利用此邊繼續連通），所以他就是割點。更新：$low[now] = min(low[now],low[next])$分別為利用子孫或靠自己\n          \n必須要注意的是，割點判斷時要把root的特例獨立判斷。其實root反而比較簡單，如果root有超過一個子樹，代表拔掉root以後會分裂成以每個子樹為單位的連通塊\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,low[N],lv[N],es=1,root,son_cnt = 0;bool visit[N],ans[N];vector&lt;int&gt; edge[N];//low函數為不經過父節點能到的最小時間戳記,lv為當前進入時間戳記void DFS(int now,int father)&#123;    visit[now] = 1;             //將此點設為已拜訪    low[now] = lv[now] = es++;  //進入的時間戳記        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;     //拜訪每一個子孫        int next = edge[now][i];        if(now==root &amp;&amp; !visit[next])son_cnt++;//計算root小孩（處理特例）        if(!visit[next])&#123;       //排除走到祖先的情況            DFS(next, now);            if(low[next]&gt;=lv[now] &amp;&amp; now!=root)ans[now]=1;            //無法透過小孩到達比自己淺的節點，將now設為AP        &#125;        if(next!=father)low[now] = min(low[now],low[next]);        //排除指向父親的情況，如果經過父親，拔掉就不能往更上面去    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(lv, 0, sizeof(lv));    memset(low, 0, sizeof(low));    memset(visit, 0, sizeof(visit));    memset(ans,0,sizeof(ans));        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(!visit[i])&#123;            root = i;            son_cnt = 0;            DFS(i, i);            if(son_cnt&gt;1)ans[root] = 1;        &#125;    &#125;    for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;i&lt;&lt;endl;&#125;\n謠言問題題目連結跟上一題（高棕櫚傳遞鏈）蠻類似的，一樣找到割點，不同的是要在DFS過程中同時紀錄子樹節點的數量。如果碰到割點，維護拔掉它之後分裂出去那些子樹的節點個數，到時候透過節點總數-拔掉後分裂個數即可推算有幾個人會知道謠言，取min即可\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 30001using namespace std;int n,m,root,lv[N],low[N],tree_cnt[N],es = 1;bool visit[N],ans[N];vector&lt;int&gt; edge[N];int DFS(int now,int father)&#123;      //回傳當前子節點個數    visit[now] = 1;    lv[now] = es;    low[now] = es++;        int len = edge[now].size(),sum=1;//計算節點數    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];     //下一個節點                if(!visit[next])&#123;            int temp = DFS(next,now);            sum += temp;            if(low[next] &gt;= lv[now] &amp;&amp; now!=root)&#123; //不能拔掉root                ans[now] = 1;           //設為AP                tree_cnt[now] += temp;  //被拔掉後可被分割成幾個連通塊節點數            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;    return sum;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    cin&gt;&gt;root;        memset(ans, 0, sizeof(ans));    memset(visit, 0, sizeof(visit));    memset(tree_cnt, 0, sizeof(tree_cnt));        int sum = DFS(root,root),min_cnt = INT_MAX,min_pos = 0;        for(int i=1;i&lt;=n;i++)&#123;        int temp = sum-tree_cnt[i]; //拔掉後剩下連通塊大小（跟root連的）        if(ans[i] &amp;&amp; temp &lt; min_cnt)&#123;            min_pos = i;        //拔掉第幾個            min_cnt = temp;     //更新拔掉後剩下連通塊大小        &#125;    &#125;    if(min_cnt == INT_MAX)cout&lt;&lt;0&lt;&lt;endl;    else cout&lt;&lt;min_pos&lt;&lt;&quot; &quot;&lt;&lt;min_cnt&lt;&lt;endl;&#125;\n高棕櫚傳遞鏈題目連結前兩題找割點，這一題是找橋，跟找割點的方法幾乎一樣，而且對於邊還不需要討論root的情況（root變成不是特例），然後判斷割點的 &gt;= 變成 &gt;，原因可以透過畫圖理解（把點拔掉跟把邊拔掉的差別），就可以實作了！題目有一個特別的要求，按照給邊的順序進行輸出，那可以搭配set來快速查看某一元素是否在集合內$O(logN)$，接著就按照給定的條件來輸出\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,lv[N],low[N],timestamp = 1;bool visit[N];vector&lt;int&gt; edge[N];vector&lt;pair&lt;int, int&gt;&gt; ans;set&lt;pair&lt;int, int&gt;&gt;s;void DFS(int now,int father)&#123;    lv[now] = low[now] = timestamp++;    visit[now] = 1;        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];                if(!visit[next])&#123;            DFS(next, now);            if(low[next] &gt; lv[now])&#123;                if(next&lt;now)s.insert(make_pair(next,now));                else s.insert(make_pair(now, next));            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);        ans.push_back(make_pair(x, y));    &#125;    memset(visit, 0, sizeof(visit));        for(int i=1;i&lt;=n;i++)&#123;        if(!visit[i])&#123;            DFS(i, i);        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        pair&lt;int, int&gt; temp = ans[i];        if(s.find(temp)!=s.end())&#123;            cout&lt;&lt;temp.first&lt;&lt;&quot; &quot;&lt;&lt;temp.second&lt;&lt;endl;        &#125;    &#125;&#125;\n芽芽逛大街題目連結有向無環圖的 case → DAG 最長路徑!將每個強連通元件縮成點後，因為內部的點可以一直亂走全部走到，所以只要將新點的點權更新成內部所有點的點權總和，得到一張新的有向無環圖，就可以直接做 DAG 最長路徑得到答案。\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500002using namespace std;int n,m,dfn[N],low[N],es = 1,stk_in[N],vertex_val[N],deg[N];//dfn為時間戳記,low為back, cross edge（經過最多一次）到達最小點dfn,stk_in是否在stack內bool visit[N];int scc[N],scc_ind = 0,scc_val[N];//紀錄屬於哪個scc,scc編號,scc編號的價值（權重和）int topological_order[N],ind = 0;struct edg&#123;    int to;    int val;&#125;;vector&lt;edg&gt; edge[N],new_edge[N];stack&lt;int&gt; s;void DFS(int now)&#123;    dfn[now] = low[now] = es++;    s.push(now);    stk_in[now] = 1;    visit[now] = 1;    int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i].to;        if(!visit[next])&#123;       //尚未拜訪則拜訪            DFS(next);            low[now] = min(low[now],low[next]);        &#125;        else if(stk_in[next])&#123;  //在stk內且已拜訪-&gt;同屬一個SCC            low[now] = min(low[now],dfn[next]);            //這條邊指向還沒出stack的點，可為cross or back edge 更新low[now]        &#125;    &#125;    //如果是scc就pop stack裡面的東西    if(low[now] == dfn[now])&#123;        stk_in[now] = 0;        //pop出stack裡面        scc[now] = ++scc_ind;   //進行SCC編號        scc_val[scc_ind] = vertex_val[now]; //更新點權        while(s.top()!=now)&#123;                //pop直到now被找到            scc[s.top()] = scc_ind;            stk_in[s.top()] = 0;            //pop出來            scc_val[scc_ind] += vertex_val[s.top()];            s.pop();        &#125;        s.pop();//將stack 中now也pop    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(visit, 0, sizeof(visit));    memset(stk_in, 0, sizeof(stk_in));    memset(deg, 0, sizeof(deg));    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        vertex_val[i] = x;    &#125;    for(int i=0;i&lt;m;i++)&#123;        int x,y,val;cin&gt;&gt;x&gt;&gt;y&gt;&gt;val;//x指向y        edge[x].push_back( edg&#123;y,val&#125; );    &#125;    for(int i=1;i&lt;=n;i++)        if(!visit[i])DFS(i);        //枚舉每一條邊更新邊權    for(int i=1;i&lt;=n;i++)&#123;        int len = edge[i].size();        for(int j=0;j&lt;len;j++)&#123;            int to = edge[i][j].to;            if(scc[to]==scc[i])&#123;                int ind = scc[to];                scc_val[ind]+=edge[i][j].val;            &#125;            else&#123;   //不同SCC指向不同的邊                new_edge[scc[i]].push_back( edg&#123;scc[to],edge[i][j].val&#125;);                deg[scc[to]]++;            &#125;        &#125;    &#125;        //Topological sort    queue&lt;int&gt; q;        for(int i=1;i&lt;=scc_ind;i++)        if(deg[i]==0)q.push(i);    while(!q.empty())&#123;        int now = q.front(),len = new_edge[now].size();        topological_order[ind++] = now;        q.pop();        for(int i=0;i&lt;len;i++)&#123;            int next = new_edge[now][i].to;            if(--deg[next]==0)q.push(next);        &#125;    &#125;        //拓墣排序完進行DP找最長路徑    int dp[ind],ans = 0;    for(int i=1;i&lt;=scc_ind;i++)&#123;        dp[i] = scc_val[i];        ans = max(ans, scc_val[i]);    &#125;        for(int i=0;i&lt;ind;i++)&#123;        int now = topological_order[i],len = new_edge[now].size();        for(int j=0;j&lt;len;j++)&#123;            int next = new_edge[now][j].to;            dp[next] = max(dp[next],scc_val[next]+dp[now]+new_edge[now][j].val);            ans = max(ans, dp[next]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n手寫作業介紹雜湊，重點在於rolling hash，這也是下一週隨機課程當中會用到的重要概念。\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","圖論"]},{"title":"[題解]NEOJ 265 欸迪的字串","url":"/sprout12-1/","content":"欸迪的字串\n題目連結輸入有兩行，第一行包含一個長度介於[1,500000]的字串S，第二行包含一個長度介於[1,500000]的字串T，請輸出一串遞增的數列表示字串S出現在字串T的哪些地方。\nRolling hash：\nH(s[1:n]) = \\sum_{i=0}^n S_i\\times C^{n-i}我們如果假設我們要找的目標字串S，長度為m，他的雜湊值是：\nH(S)= \\sum_{i=1}^mS_i \\times C^{m-i}則對於長度為L與r-1的字串T，其hash值為：\nH(T[1:L]) = \\sum_{i=1}^LT_i\\times C^{L-i}H(T[1:r-1]) = \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i}則目標區間長度為m的字串長度即為字串S的雜湊值，將T[1:L]的雜湊值扣掉$C^{m}$乘上T[1:r-1]的雜湊值，即為所求。\n\\begin{split}H(S)&=H(T[r:L])\\\\ &=H(T[1:L])-H(T[1:r-1])\\\\\n&= \\sum_{i=1}^LT_i\\times C^{L-i} - C^{m}\\times \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i} \\\\\n&=\\sum_{i=1}^LT_i\\times C^{L-i}-\\sum_{i=1}^{r-1}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=r}^{L}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=1}^{m}T_{i+r-1}\\times C^{m-1}\\end{split}就可以得到當前區間的hash值所以這整題就變成維護字串T的前綴和，透過以上方式O(n)得到每一個index的hash值，接著O(1)比對即可。\n            Q:照最基本的暴力比對可不可行？A:可以構造出需要比對很多次的字串，有可能會被卡TLE之類的\n          以後一定要記得，必須要行末輸出一行，我在這邊WA超久\n#include &lt;bits/stdc++.h&gt;#define int unsigned long long int#define INF 0x3f3f3f3f#define N 500005#define mod 1000000007using namespace std;int power[N],hash_func[N],charc[30],n,m,C = 137;char target[N],a[N];vector&lt;int&gt; vec;void init()&#123;    power[0] = 1;    srand(time(NULL));    for(int i=1;i&lt;=m;i++)&#123;        power[i] = ((power[i-1]*C)+mod)%mod;    &#125;    for(int i=0;i&lt;30;i++)&#123;    //再用rand來使字串更亂（不用也沒差）        int temp = rand();        charc[i] = temp;    &#125;&#125;signed main()&#123;    scanf(&quot;%s\\n%s&quot;,target+1,a+1);    m = strlen(target+1);    n = strlen(a+1);    init();    hash_func[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;        hash_func[i] = ((C*hash_func[i-1]+(charc[a[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    int sum = 0;    for(int i=1;i&lt;=m;i++)&#123;        sum = ((sum*C+(charc[target[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    for(int i=0;i&lt;=n-m;i++)&#123;        if(sum == ((hash_func[i+m]-((hash_func[i]*power[m])+mod)%mod)+mod)%mod)            vec.push_back(i);    &#125;    int len = vec.size();        if(len&gt;0)printf(&quot;%llu&quot;,vec[0]);    for(int i=1;i&lt;len;i++)&#123;        printf(&quot; %llu&quot;,vec[i]);    &#125;    cout&lt;&lt;endl;    //這一行是毒瘤&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 266 溫力的故事","url":"/sprout12-2/","content":"溫力的故事\n題目連結給字串集合A，接下來給m個字串，問你在m個字串中i字串一共出現了幾次。直覺的想法就是直接用multiset來解這一題。\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int unsigned long long int#define N 105using namespace std;int n,m,power[N],C = 13331;void init()&#123;    power[0] = 1;    for(int i=1;i&lt;=N;i++)&#123;        power[i] = power[i-1]*C;    &#125;&#125;int func(string s)&#123;    int len = s.size(),sum = 0;    for(int i=1;i&lt;=len;i++)&#123;        sum+=((int)s[i-1]*power[len-i]);    &#125;    return sum;&#125;signed main()&#123;    ios;    init();    multiset&lt;int&gt; ss;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        ss.insert(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        cout&lt;&lt;ss.count(temp)&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 793 想不到題目標題QQ","url":"/sprout12-3/","content":"想不到題目標題QQ\n題目連結圖中的-2改成-(k-1)，對於圖中的x,y都是設計成大數亂數，要承擔的風險就是這些大數相加之後不應該變成0的卻變成0（機率超小）還有一個重點，對於每一筆詢問都要求出區間的和，因此要用O(n)維護前綴和！（一開始沒想到tle，不過靈光一閃維護前綴和就過了）\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 500005#define mod 1000000007using namespace std;int n,k,m,arr[N],times[N],fuck[N],value[N],pre[N];void init()&#123;    memset(times, 0, sizeof(times));    srand(time(NULL));    pre[0] = 0;    for(int i=0;i&lt;=N;i++)&#123;        int temp = rand()%mod;        fuck[i] = temp;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        times[arr[i]]++;        if(times[arr[i]]%k==0)&#123;            value[i] = -(k-1)*fuck[arr[i]];        &#125;        else&#123;            value[i] = fuck[arr[i]];        &#125;        pre[i] = (pre[i-1]+value[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,sum=0;cin&gt;&gt;l&gt;&gt;r;        sum = pre[r]-pre[l-1];        if(sum==0)cout&lt;&lt;1;        else cout&lt;&lt;0;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 740 矩陣乘法","url":"/sprout12-4/","content":"矩陣乘法\n題目連結給定三個矩陣ABC，驗證A乘上B是否為C。當然可以用$O(n^3)$的時間實際驗證A乘上B的結果與C比對，但其實有更快的方法如下，構造出矩陣R，這一題可以思考要1乘上多少的矩陣，透過兩次O(n^2)的乘法，就可以比對這個R矩陣乘上C矩陣的結果這題蠻簡單的，一次就過了\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 1505#define mod 1000000007using namespace std;int n,m,k,a[N][N],b[N][N],c[N][N],R[N],temp[N],c_new[N];void init()&#123;    memset(temp, 0, sizeof(temp));    srand(time(NULL));    for(int i=0;i&lt;N;i++)&#123;        int temp = rand()%mod;        R[i] = temp;    &#125;&#125;void input()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;b[i][j];        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;c[i][j];        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    input();    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            temp[i]+=(b[i][j]*R[j])%mod;        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            c_new[i]+=(a[i][j]*temp[j])%mod;        &#125;    &#125;    bool flag = 1;    for(int i=0;i&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;k;j++)&#123;            sum+=(c[i][j]*R[j])%mod;        &#125;        if(c_new[i]!=sum)&#123;            flag = 0;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 795 最近點對","url":"/sprout12-5/","content":"最近點對\n題目連結大魔王題，害我TLE 27次。二維平面，給定n個點，求出最近的兩個點的距離。重大BUG害我卡三天的BUG在於，題目要求輸出距離的平方，結果在計算過程中就直接把距離當作是平方，自然有很多點會同時出現在一格網格座標中（我弱，一直TLE），還一直用什麼multi_map之類的，當然就是TLE嘍。暴力做：$O(n^2)$，分治做：$O(nlogn)$，隨機做：期望$O(n)$,最慘$O(n^2)$這一題的步驟：\n\n把 N 個點平移到第一象限\n把 N 個點的順序隨機打亂，d = dis(𝑎1, 𝑎2)\n以 𝑟 = 𝑑/2 的大小將二維平面切成網格狀，並將這些網格也 𝑥𝑦以座標表示:點(𝑥,𝑦)會落入座標為 (𝑟,𝑟)不會有兩個點在同一個格子內（很重要的性質）\n一直把點加進網格中如果產生新的最近點對一定會出現在以某個點為中心的5×5宮格內\n找到更近的最近點對更新 r= 新的最近點對 /2 ，回到步驟三重來 O(i+1)\n\n\n            期望複雜度 $O(n)$ 證明考慮加入第i+1個點時出現新的最近點對，發生的機率為：在$C_2^{i+1}$個配對中跟i+1個點產生最近點對共有i種可能，因此機率為$\\frac{2}{i+1}$，當機率發生的時候，必須將所有的點都刪掉重新來一遍（因為r變小，unordered_map裡面的東西也要被清空，重新推入i+1個點），需要付出$O(i+1)$的時間，相乘起來每一個點期望的複雜度為$O(1)$，因此總時間複雜度為$O(n)$。\n          \n實作上可以用unordered_map，因為保證不會出現同一格的情況（一格間的最長距離也就不超過d，所以當出現在同一格就表示該更新了）\n優化：先用$O(n^2)$的作法，找到前面的少數pair（$\\sqrt n$）的最短距離，這樣可以減少被重新更新的機會\n這篇文章有分治的作法，雖然分治的複雜度是O(n\\log n)，隨機是$O(n)$，但因為隨機常數比較大的關係，時間比分治慢了快兩倍！下圖是分治的執行結果：\n以下是隨機AC Code：\n#include &lt;bits/stdc++.h&gt;#define int long long int#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define INF 1000000000LL#define swift 1000000000using namespace std;int n,ans;double r,d;int dx[25] = &#123;-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2&#125;;int dy[25] = &#123;-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2&#125;;unordered_map&lt;int, int&gt; m;void solve();inline void init();void solve();bool insert(int,int,int);inline double dis(int,int);inline int Grid(int);struct node&#123;    int x,y,ind;&#125;point[N];//函式實作inline void init()&#123;    m.clear();&#125;inline int Grid(int ind)&#123; //input網格座標    int x = point[ind].x/r;    int y = point[ind].y/r;    return x*INF+y;&#125;inline int dist(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return (x*x+y*y);&#125;inline double dis(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return sqrt(x*x+y*y);&#125;void solve()&#123;    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));    for(int ind = 2;ind &lt; n;ind++)&#123;        int x = point[ind].x/r,y = point[ind].y/r,better=0;        for(int i=0;i&lt;25;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            auto it = m.find(nx*INF+ny);            if(it!=m.end())&#123;                double distance = dis(point[it-&gt;second],point[ind]);                if(distance&lt;d)&#123;                    better = 1;                    ans = dist(point[it-&gt;second],point[ind]);                    d = distance;                    r = d/2;                &#125;            &#125;        &#125;        if(better)&#123;    //前面的格子直接瑱入            m.clear();            for(int i=0;i&lt;=ind;i++)m.insert(make_pair(Grid(i),i));        &#125;        else&#123;            m.insert(make_pair(Grid(ind), ind));        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        x+=swift;y+=swift;        point[i].x = x;point[i].y = y;    &#125;    random_shuffle(point, point+n);    int smalln = sqrt(n);    ans = dist(point[0],point[1]);    d = dis(point[0], point[1]);    for(int i=0;i&lt;=smalln;i++)&#123;        for(int j=i+1;j&lt;=smalln;j++)&#123;            d = min(d,dis(point[i], point[j]));            ans = min(ans,dist(point[i],point[j]));        &#125;    &#125;    r = d/2;    solve();    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第十二週：隨機算法","url":"/sprout12/","content":"上課內容這一週講隨機，主要講rolling hash，字串的hash、隨機的例題，像是矩陣乘法的驗證$O(n^2)$、訪問區間各元素出現次數是否為k的倍數，最近點對的$O(n)$作法等（還有東西還沒有看XD）\n\n上機作業欸迪的字串題目連結輸入有兩行，第一行包含一個長度介於[1,500000]的字串S，第二行包含一個長度介於[1,500000]的字串T，請輸出一串遞增的數列表示字串S出現在字串T的哪些地方。\nRolling hash：\nH(s[1:n]) = \\sum_{i=0}^n S_i\\times C^{n-i}我們如果假設我們要找的目標字串S，長度為m，他的雜湊值是：\nH(S)= \\sum_{i=1}^mS_i \\times C^{m-i}則對於長度為L與r-1的字串T，其hash值為：\nH(T[1:L]) = \\sum_{i=1}^LT_i\\times C^{L-i}H(T[1:r-1]) = \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i}則目標區間長度為m的字串長度即為字串S的雜湊值，將T[1:L]的雜湊值扣掉$C^{m}$乘上T[1:r-1]的雜湊值，即為所求。\n\\begin{split}H(S)&=H(T[r:L])\\\\ &=H(T[1:L])-H(T[1:r-1])\\\\\n&= \\sum_{i=1}^LT_i\\times C^{L-i} - C^{m}\\times \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i} \\\\\n&=\\sum_{i=1}^LT_i\\times C^{L-i}-\\sum_{i=1}^{r-1}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=r}^{L}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=1}^{m}T_{i+r-1}\\times C^{m-1}\\end{split}就可以得到當前區間的hash值所以這整題就變成維護字串T的前綴和，透過以上方式O(n)得到每一個index的hash值，接著O(1)比對即可。\n            Q:照最基本的暴力比對可不可行？A:可以構造出需要比對很多次的字串，有可能會被卡TLE之類的\n          以後一定要記得，必須要行末輸出一行，我在這邊WA超久\n#include &lt;bits/stdc++.h&gt;#define int unsigned long long int#define INF 0x3f3f3f3f#define N 500005#define mod 1000000007using namespace std;int power[N],hash_func[N],charc[30],n,m,C = 137;char target[N],a[N];vector&lt;int&gt; vec;void init()&#123;    power[0] = 1;    srand(time(NULL));    for(int i=1;i&lt;=m;i++)&#123;        power[i] = ((power[i-1]*C)+mod)%mod;    &#125;    for(int i=0;i&lt;30;i++)&#123;    //再用rand來使字串更亂（不用也沒差）        int temp = rand();        charc[i] = temp;    &#125;&#125;signed main()&#123;    scanf(&quot;%s\\n%s&quot;,target+1,a+1);    m = strlen(target+1);    n = strlen(a+1);    init();    hash_func[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;        hash_func[i] = ((C*hash_func[i-1]+(charc[a[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    int sum = 0;    for(int i=1;i&lt;=m;i++)&#123;        sum = ((sum*C+(charc[target[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    for(int i=0;i&lt;=n-m;i++)&#123;        if(sum == ((hash_func[i+m]-((hash_func[i]*power[m])+mod)%mod)+mod)%mod)            vec.push_back(i);    &#125;    int len = vec.size();        if(len&gt;0)printf(&quot;%llu&quot;,vec[0]);    for(int i=1;i&lt;len;i++)&#123;        printf(&quot; %llu&quot;,vec[i]);    &#125;    cout&lt;&lt;endl;    //這一行是毒瘤&#125;\n溫力的故事題目連結給字串集合A，接下來給m個字串，問你在m個字串中i字串一共出現了幾次。直覺的想法就是直接用multiset來解這一題。\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int unsigned long long int#define N 105using namespace std;int n,m,power[N],C = 13331;void init()&#123;    power[0] = 1;    for(int i=1;i&lt;=N;i++)&#123;        power[i] = power[i-1]*C;    &#125;&#125;int func(string s)&#123;    int len = s.size(),sum = 0;    for(int i=1;i&lt;=len;i++)&#123;        sum+=((int)s[i-1]*power[len-i]);    &#125;    return sum;&#125;signed main()&#123;    ios;    init();    multiset&lt;int&gt; ss;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        ss.insert(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        cout&lt;&lt;ss.count(temp)&lt;&lt;endl;    &#125;&#125;\n想不到題目標題QQ題目連結圖中的-2改成-(k-1)，對於圖中的x,y都是設計成大數亂數，要承擔的風險就是這些大數相加之後不應該變成0的卻變成0（機率超小）還有一個重點，對於每一筆詢問都要求出區間的和，因此要用O(n)維護前綴和！（一開始沒想到tle，不過靈光一閃維護前綴和就過了）\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 500005#define mod 1000000007using namespace std;int n,k,m,arr[N],times[N],fuck[N],value[N],pre[N];void init()&#123;    memset(times, 0, sizeof(times));    srand(time(NULL));    pre[0] = 0;    for(int i=0;i&lt;=N;i++)&#123;        int temp = rand()%mod;        fuck[i] = temp;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        times[arr[i]]++;        if(times[arr[i]]%k==0)&#123;            value[i] = -(k-1)*fuck[arr[i]];        &#125;        else&#123;            value[i] = fuck[arr[i]];        &#125;        pre[i] = (pre[i-1]+value[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,sum=0;cin&gt;&gt;l&gt;&gt;r;        sum = pre[r]-pre[l-1];        if(sum==0)cout&lt;&lt;1;        else cout&lt;&lt;0;    &#125;    cout&lt;&lt;endl;&#125;\n矩陣乘法題目連結給定三個矩陣ABC，驗證A乘上B是否為C。當然可以用$O(n^3)$的時間實際驗證A乘上B的結果與C比對，但其實有更快的方法如下，構造出矩陣R，這一題可以思考要1乘上多少的矩陣，透過兩次O(n^2)的乘法，就可以比對這個R矩陣乘上C矩陣的結果這題蠻簡單的，一次就過了\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 1505#define mod 1000000007using namespace std;int n,m,k,a[N][N],b[N][N],c[N][N],R[N],temp[N],c_new[N];void init()&#123;    memset(temp, 0, sizeof(temp));    srand(time(NULL));    for(int i=0;i&lt;N;i++)&#123;        int temp = rand()%mod;        R[i] = temp;    &#125;&#125;void input()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;b[i][j];        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;c[i][j];        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    input();    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            temp[i]+=(b[i][j]*R[j])%mod;        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            c_new[i]+=(a[i][j]*temp[j])%mod;        &#125;    &#125;    bool flag = 1;    for(int i=0;i&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;k;j++)&#123;            sum+=(c[i][j]*R[j])%mod;        &#125;        if(c_new[i]!=sum)&#123;            flag = 0;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;\n最近點對題目連結大魔王題，害我TLE 27次。二維平面，給定n個點，求出最近的兩個點的距離。重大BUG害我卡三天的BUG在於，題目要求輸出距離的平方，結果在計算過程中就直接把距離當作是平方，自然有很多點會同時出現在一格網格座標中（我弱，一直TLE），還一直用什麼multi_map之類的，當然就是TLE嘍。暴力做：$O(n^2)$，分治做：$O(nlogn)$，隨機做：期望$O(n)$,最慘$O(n^2)$這一題的步驟：\n\n把 N 個點平移到第一象限\n把 N 個點的順序隨機打亂，d = dis(𝑎1, 𝑎2)\n以 𝑟 = 𝑑/2 的大小將二維平面切成網格狀，並將這些網格也 𝑥𝑦以座標表示:點(𝑥,𝑦)會落入座標為 (𝑟,𝑟)不會有兩個點在同一個格子內（很重要的性質）\n一直把點加進網格中如果產生新的最近點對一定會出現在以某個點為中心的5×5宮格內\n找到更近的最近點對更新 r= 新的最近點對 /2 ，回到步驟三重來 O(i+1)\n\n\n            期望複雜度 $O(n)$ 證明考慮加入第i+1個點時出現新的最近點對，發生的機率為：在$C_2^{i+1}$個配對中跟i+1個點產生最近點對共有i種可能，因此機率為$\\frac{2}{i+1}$，當機率發生的時候，必須將所有的點都刪掉重新來一遍（因為r變小，unordered_map裡面的東西也要被清空，重新推入i+1個點），需要付出$O(i+1)$的時間，相乘起來每一個點期望的複雜度為$O(1)$，因此總時間複雜度為$O(n)$。\n          \n實作上可以用unordered_map，因為保證不會出現同一格的情況（一格間的最長距離也就不超過d，所以當出現在同一格就表示該更新了）\n優化：先用$O(n^2)$的作法，找到前面的少數pair（$\\sqrt n$）的最短距離，這樣可以減少被重新更新的機會\n這篇文章有分治的作法，雖然分治的複雜度是O(n\\log n)，隨機是$O(n)$，但因為隨機常數比較大的關係，時間比分治慢了快兩倍！下圖是分治的執行結果：\n以下是隨機AC Code：\n#include &lt;bits/stdc++.h&gt;#define int long long int#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define INF 1000000000LL#define swift 1000000000using namespace std;int n,ans;double r,d;int dx[25] = &#123;-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2&#125;;int dy[25] = &#123;-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2&#125;;unordered_map&lt;int, int&gt; m;void solve();inline void init();void solve();bool insert(int,int,int);inline double dis(int,int);inline int Grid(int);struct node&#123;    int x,y,ind;&#125;point[N];//函式實作inline void init()&#123;    m.clear();&#125;inline int Grid(int ind)&#123; //input網格座標    int x = point[ind].x/r;    int y = point[ind].y/r;    return x*INF+y;&#125;inline int dist(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return (x*x+y*y);&#125;inline double dis(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return sqrt(x*x+y*y);&#125;void solve()&#123;    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));    for(int ind = 2;ind &lt; n;ind++)&#123;        int x = point[ind].x/r,y = point[ind].y/r,better=0;        for(int i=0;i&lt;25;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            auto it = m.find(nx*INF+ny);            if(it!=m.end())&#123;                double distance = dis(point[it-&gt;second],point[ind]);                if(distance&lt;d)&#123;                    better = 1;                    ans = dist(point[it-&gt;second],point[ind]);                    d = distance;                    r = d/2;                &#125;            &#125;        &#125;        if(better)&#123;    //前面的格子直接瑱入            m.clear();            for(int i=0;i&lt;=ind;i++)m.insert(make_pair(Grid(i),i));        &#125;        else&#123;            m.insert(make_pair(Grid(ind), ind));        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        x+=swift;y+=swift;        point[i].x = x;point[i].y = y;    &#125;    random_shuffle(point, point+n);    int smalln = sqrt(n);    ans = dist(point[0],point[1]);    d = dis(point[0], point[1]);    for(int i=0;i&lt;=smalln;i++)&#123;        for(int j=i+1;j&lt;=smalln;j++)&#123;            d = min(d,dis(point[i], point[j]));            ans = min(ans,dist(point[i],point[j]));        &#125;    &#125;    r = d/2;    solve();    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n手寫作業不用交手寫作業！不過還是有一份「欣賞用」的，講Disjoint Set\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","隨機"]},{"title":"[題解]NEOJ 252 Counting Triangles","url":"/sprout13-1/","content":"Counting Triangles\n題目連結我個人認為做法超級精妙的！有很多種作法，挑一個比較好實作的：\n            假設可以 $O(1)$ 回答 (x, y) 是否為圖中的一個邊。對於每條邊 (u, v) ，你花$O(min(d_u, d_v))$去算出包含這條邊的三角形個數總複雜度：$O(M\\sqrt{M})$\n          \n\n其中對於均攤查詢一條邊有沒有在圖中，總邊數$O(M)$ $\\div$ 詢問每一條邊$O(M)$ = 均攤$O(1)$的複雜度，實作起來非常簡單\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100001#define M 100001using namespace std;int main()&#123;    ios;    vector&lt;int&gt; G[N],query[N];  //G是存圖、query是存詢問    int n,m,x[M],y[M];  //x,y存邊用    bool visit[N];        cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;x[i]&gt;&gt;y[i];        G[x[i]].push_back(y[i]);        G[y[i]].push_back(x[i]);    &#125;    int sml = 0,big = 0;    for(int i=0;i&lt;m;i++)&#123;    //保證複雜度為根號的關鍵        if(G[x[i]].size()&lt;=G[y[i]].size())sml = x[i];        else sml = y[i];    //尋找哪一個度數比較小        big = x[i]+y[i]-sml;        for(int j : G[sml])&#123;   //訪問跟sml有相鄰的所有邊，看有沒有(j,big)            query[j].push_back(big);        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        //均攤O(1)?        for(int j:G[i])&#123;            visit[j] = true;        &#125;        for(int j:query[i])&#123;            ans+=visit[j];        &#125;        for(int j:G[i])&#123;            visit[j] = false;        &#125;    &#125;    cout&lt;&lt;ans/3&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 213 中國人插隊問題","url":"/sprout13-2/","content":"中國人插隊問題\n題目連結如果用一個vector 存整個序列，query $O(1)$，但新增跟刪除都是$O(N)$因此，如果改用分塊的方法，用deque下去砸，每K個分成一塊，對於插入與刪除都是$O(K+\\frac{N}{K})$，詢問是$O(1)$根據算幾不等式，我們可以取$K = \\sqrt{N}$ 時，複雜度可以達到$O(\\sqrt{N})$ ，很不錯吧！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;signed main()&#123;    ios;    int n,m,K;    cin&gt;&gt;n&gt;&gt;m;    K = sqrt(n);    deque&lt;int&gt; deq[n/K+(m/K)+10];    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        deq[i/K].push_back(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string a;cin&gt;&gt;a;        if(a[0]==&#x27;A&#x27;)&#123;            int x,y;cin&gt;&gt;y&gt;&gt;x;y--;            deq[y/K].insert(deq[y/K].begin()+(y%K), x);            int len = deq[y/K].size(),cur = y/K;            while(len&gt;K)&#123;                int temp = deq[cur].back();                deq[cur].pop_back();                cur++;                deq[cur].push_front(temp);                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;L&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            deq[x/K].erase(deq[x/K].begin()+(x%K));            int len = deq[x/K].size(),cur = x/K;            while(len&lt;K &amp;&amp; deq[cur+1].size()!=0)&#123;                int temp = deq[cur+1].front();                deq[cur+1].pop_front();                deq[cur].push_back(temp);                cur++;                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;Q&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            int len = x%K;            auto it = deq[x/K].begin();            cout&lt;&lt;*(it+len)&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 742 第 Z 小","url":"/sprout13-3/","content":"第 Z 小\n題目連結超討厭，一直RE，結果是卡在沒有開long long，哭啊這一題是值域分塊，一樣是根據值域每K個分成一塊，去維護每一大塊的數字數量總和，這樣在查詢(query)的時候花 $O(C/K)$ 找到相應大塊(C為值域)，再花 $O(K)$ 的時間掃過小塊，而加值減值都是$O(1)$可以處理複雜度：$O(K+\\frac{C}{K})$ 取 K=$\\sqrt{C}$ 有最小值：$O(Q\\sqrt{C})$\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100005using namespace std;    //值域分塊const int K = 100;signed main()&#123;    ios;    int q,arr[N],mn[N/K+10];cin&gt;&gt;q;    memset(arr, 0, sizeof(arr));    while(q--)&#123;        int temp;cin&gt;&gt;temp;        if(temp==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]+=y;            mn[x/K]+=y;        &#125;        else if(temp==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]-=y;            mn[x/K]-=y;        &#125;        else if(temp==3)&#123;            int z,sum = 0,ind=0;cin&gt;&gt;z; //ind查詢位於第幾塊            while(sum+mn[ind]&lt;z)sum+=mn[ind++];            int cur_ind = ind*K;            for(int i=0;i&lt;=K;i++)&#123;                if(arr[cur_ind+i])&#123;                    sum+=arr[cur_ind+i];                    if(sum&gt;=z)&#123;                        cout&lt;&lt;ind*K+i&lt;&lt;endl;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 722 小咲的玩具","url":"/sprout13-4/","content":"小咲的玩具\n題目連結這一題的常數超緊，因此在嘗試使用hash時用unordredmap被卡TLE，在很電的人提示後，要使用黑魔法cc_hash_table才可能會過關\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;cc_hash_table&lt;int,int&gt;cc;\n他的用法其實跟unordered_map幾乎一樣吧（至少基本的insert跟find的語法都一樣），不過他可以做到比unordered_map更好的效率。不過我用最近點對這一題測試效率卻發現黑魔法會tle，可能是在clear這一個步驟的效率並不是很好吧！\n總之，就是對於每一筆詢問(x,y)，不失一般性假設size_y &gt; size_x，則對於y排序並預處理前綴和，同時枚舉x中的所有點並二分搜他在y的位置最重要的，是對每一筆詢問都儲存起來，這樣複雜度會瞬間少一個N補複雜度證明\n#include &lt;bits/stdc++.h&gt;using namespace std;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;#define int long long#define N 150006int n,k,q;vector&lt;int&gt; vec[N],pre[N];bool visit[N];cc_hash_table&lt;int,int&gt;cc; int HASH(int x,int y)&#123;    return x*1000000007+y;&#125;signed main()&#123;    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;k,&amp;q);    memset(visit, 0, sizeof(visit));    while(k--)&#123;        int c,p;scanf(&quot;%lld %lld&quot;,&amp;c,&amp;p);        vec[p].push_back(c);    &#125;    while(q--)&#123;        int x,y;scanf(&quot;%lld %lld&quot;,&amp;x,&amp;y);        if(vec[x].size()&gt;vec[y].size())swap(x, y);                if(cc.find(HASH(x,y))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(x,y))-&gt;second);            continue;        &#125;        else if(cc.find(HASH(y,x))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(y,x))-&gt;second);            continue;        &#125;                int len = vec[y].size();        if(!visit[y])&#123;            sort(vec[y].begin(),vec[y].end());            pre[y].resize(len+6);            for(int i=0;i&lt;=len;i++)pre[y][i+1] = pre[y][i]+vec[y][i];            visit[y] = 1;        &#125;                int ans = 0;        for(int j:vec[x])&#123;            int pos = lower_bound(vec[y].begin(), vec[y].end(),j)-vec[y].begin();            pos--;            if(pos&lt;0)ans+=(len*j);            else ans += (pre[y][pos+1]+j*(len-pos-1));        &#125;        printf(&quot;%lld\\n&quot;,ans);        cc.insert(make_pair(HASH(x,y),ans));        cc.insert(make_pair(HASH(y,x),ans));    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第十三週：根號算法","url":"/sprout13/","content":"上課內容好噁心喔，複雜度竟然帶根號！？ 根號算法有很多例題，最常聽到（或遇到？）的就是分塊了！把序列分成$\\sqrt{K}$ 塊，在做RMQ（區間加值、區間求和等）的其中一種方式\n\nRMQ區間極值詢問（可以用分塊做、線段樹、BIT、稀疏表sparse table）\nCounting Triangle\n分塊（值域分塊、塊狀鍊表等）\n操作分塊\n\n其實根號算法的重點其實在於複雜度分析（講師花很多時間講不同作法的複雜度分析），怎麼樣分析讓複雜度跑出根號\n\n上機作業Counting Triangles題目連結我個人認為做法超級精妙的！有很多種作法，挑一個比較好實作的：\n            假設可以 $O(1)$ 回答 (x, y) 是否為圖中的一個邊。對於每條邊 (u, v) ，你花$O(min(d_u, d_v))$去算出包含這條邊的三角形個數總複雜度：$O(M\\sqrt{M})$\n          \n\n其中對於均攤查詢一條邊有沒有在圖中，總邊數$O(M)$ $\\div$ 詢問每一條邊$O(M)$ = 均攤$O(1)$的複雜度，實作起來非常簡單\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100001#define M 100001using namespace std;int main()&#123;    ios;    vector&lt;int&gt; G[N],query[N];  //G是存圖、query是存詢問    int n,m,x[M],y[M];  //x,y存邊用    bool visit[N];        cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;x[i]&gt;&gt;y[i];        G[x[i]].push_back(y[i]);        G[y[i]].push_back(x[i]);    &#125;    int sml = 0,big = 0;    for(int i=0;i&lt;m;i++)&#123;    //保證複雜度為根號的關鍵        if(G[x[i]].size()&lt;=G[y[i]].size())sml = x[i];        else sml = y[i];    //尋找哪一個度數比較小        big = x[i]+y[i]-sml;        for(int j : G[sml])&#123;   //訪問跟sml有相鄰的所有邊，看有沒有(j,big)            query[j].push_back(big);        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        //均攤O(1)?        for(int j:G[i])&#123;            visit[j] = true;        &#125;        for(int j:query[i])&#123;            ans+=visit[j];        &#125;        for(int j:G[i])&#123;            visit[j] = false;        &#125;    &#125;    cout&lt;&lt;ans/3&lt;&lt;endl;&#125;\n中國人插隊問題題目連結如果用一個vector 存整個序列，query $O(1)$，但新增跟刪除都是$O(N)$因此，如果改用分塊的方法，用deque下去砸，每K個分成一塊，對於插入與刪除都是$O(K+\\frac{N}{K})$，詢問是$O(1)$根據算幾不等式，我們可以取$K = \\sqrt{N}$ 時，複雜度可以達到$O(\\sqrt{N})$ ，很不錯吧！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;signed main()&#123;    ios;    int n,m,K;    cin&gt;&gt;n&gt;&gt;m;    K = sqrt(n);    deque&lt;int&gt; deq[n/K+(m/K)+10];    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        deq[i/K].push_back(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string a;cin&gt;&gt;a;        if(a[0]==&#x27;A&#x27;)&#123;            int x,y;cin&gt;&gt;y&gt;&gt;x;y--;            deq[y/K].insert(deq[y/K].begin()+(y%K), x);            int len = deq[y/K].size(),cur = y/K;            while(len&gt;K)&#123;                int temp = deq[cur].back();                deq[cur].pop_back();                cur++;                deq[cur].push_front(temp);                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;L&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            deq[x/K].erase(deq[x/K].begin()+(x%K));            int len = deq[x/K].size(),cur = x/K;            while(len&lt;K &amp;&amp; deq[cur+1].size()!=0)&#123;                int temp = deq[cur+1].front();                deq[cur+1].pop_front();                deq[cur].push_back(temp);                cur++;                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;Q&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            int len = x%K;            auto it = deq[x/K].begin();            cout&lt;&lt;*(it+len)&lt;&lt;endl;        &#125;    &#125;&#125;\n第 Z 小題目連結超討厭，一直RE，結果是卡在沒有開long long，哭啊這一題是值域分塊，一樣是根據值域每K個分成一塊，去維護每一大塊的數字數量總和，這樣在查詢(query)的時候花 $O(C/K)$ 找到相應大塊(C為值域)，再花 $O(K)$ 的時間掃過小塊，而加值減值都是$O(1)$可以處理複雜度：$O(K+\\frac{C}{K})$ 取 K=$\\sqrt{C}$ 有最小值：$O(Q\\sqrt{C})$\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100005using namespace std;    //值域分塊const int K = 100;signed main()&#123;    ios;    int q,arr[N],mn[N/K+10];cin&gt;&gt;q;    memset(arr, 0, sizeof(arr));    while(q--)&#123;        int temp;cin&gt;&gt;temp;        if(temp==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]+=y;            mn[x/K]+=y;        &#125;        else if(temp==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]-=y;            mn[x/K]-=y;        &#125;        else if(temp==3)&#123;            int z,sum = 0,ind=0;cin&gt;&gt;z; //ind查詢位於第幾塊            while(sum+mn[ind]&lt;z)sum+=mn[ind++];            int cur_ind = ind*K;            for(int i=0;i&lt;=K;i++)&#123;                if(arr[cur_ind+i])&#123;                    sum+=arr[cur_ind+i];                    if(sum&gt;=z)&#123;                        cout&lt;&lt;ind*K+i&lt;&lt;endl;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n小咲的玩具題目連結這一題的常數超緊，因此在嘗試使用hash時用unordredmap被卡TLE，在很電的人提示後，要使用黑魔法cc_hash_table才可能會過關\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;cc_hash_table&lt;int,int&gt;cc;\n他的用法其實跟unordered_map幾乎一樣吧（至少基本的insert跟find的語法都一樣），不過他可以做到比unordered_map更好的效率。不過我用最近點對這一題測試效率卻發現黑魔法會tle，可能是在clear這一個步驟的效率並不是很好吧！\n總之，就是對於每一筆詢問(x,y)，不失一般性假設size_y &gt; size_x，則對於y排序並預處理前綴和，同時枚舉x中的所有點並二分搜他在y的位置最重要的，是對每一筆詢問都儲存起來，這樣複雜度會瞬間少一個N補複雜度證明\n#include &lt;bits/stdc++.h&gt;using namespace std;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;#define int long long#define N 150006int n,k,q;vector&lt;int&gt; vec[N],pre[N];bool visit[N];cc_hash_table&lt;int,int&gt;cc; int HASH(int x,int y)&#123;    return x*1000000007+y;&#125;signed main()&#123;    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;k,&amp;q);    memset(visit, 0, sizeof(visit));    while(k--)&#123;        int c,p;scanf(&quot;%lld %lld&quot;,&amp;c,&amp;p);        vec[p].push_back(c);    &#125;    while(q--)&#123;        int x,y;scanf(&quot;%lld %lld&quot;,&amp;x,&amp;y);        if(vec[x].size()&gt;vec[y].size())swap(x, y);                if(cc.find(HASH(x,y))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(x,y))-&gt;second);            continue;        &#125;        else if(cc.find(HASH(y,x))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(y,x))-&gt;second);            continue;        &#125;                int len = vec[y].size();        if(!visit[y])&#123;            sort(vec[y].begin(),vec[y].end());            pre[y].resize(len+6);            for(int i=0;i&lt;=len;i++)pre[y][i+1] = pre[y][i]+vec[y][i];            visit[y] = 1;        &#125;                int ans = 0;        for(int j:vec[x])&#123;            int pos = lower_bound(vec[y].begin(), vec[y].end(),j)-vec[y].begin();            pos--;            if(pos&lt;0)ans+=(len*j);            else ans += (pre[y][pos+1]+j*(len-pos-1));        &#125;        printf(&quot;%lld\\n&quot;,ans);        cc.insert(make_pair(HASH(x,y),ans));        cc.insert(make_pair(HASH(y,x),ans));    &#125;&#125;\n手寫作業這已經是最後的一堂課了qq，13週的課程就這樣結束了！手寫作業排名12，上機不知道，但二階段因為剛好二段的關係，有一個禮拜（dp3）的課的上機作業全部放掉（我在幹嘛qq）那真是慘啊！\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","根號算法"]},{"title":"[題解]NEOJ 59 Heap 練習","url":"/sprout3-1/","content":"Heap 練習\n題目連結刻一個heap嘛，不想刻就call stl( std::priorityqueue 就不放上來了)自己刻一個binary heap ，沒有想象中的簡單，有些細節會不小心漏掉\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int t,top=1,heap[1000005];//complete binary treevoid push(int n)&#123;    heap[top] = n;    int father_pos = top/2,pos = top;    while(father_pos&gt;0 &amp;&amp; heap[father_pos]&gt;heap[pos])&#123;        swap(heap[father_pos], heap[pos]);        pos = father_pos;        father_pos/=2;    &#125;    top = top+1;&#125;int pop()&#123;    int ans = heap[1];    heap[1] = heap[--top];    heap[top] = 0;    int now = 1,left = now*2, right = now*2+1;        int temp = min(heap[right],heap[left]);    while(heap[left]!=0 &amp;&amp; heap[right]!=0 &amp;&amp; heap[now]&gt;temp)&#123;        if(heap[now]&gt;heap[right] &amp;&amp; heap[left]&gt;heap[right])&#123;            swap(heap[right], heap[now]);            now = right;        &#125;        else if(heap[now]&gt;heap[left])&#123;            swap(heap[left], heap[now]);            now = left;        &#125;        right = now*2+1;        left = now*2;        temp = min(heap[right],heap[left]);    &#125;    if(heap[right]!=0 &amp;&amp; heap[now]&gt;heap[right])swap(heap[right], heap[now]);    else if(heap[left]!=0 &amp;&amp; heap[now]&gt;heap[left])swap(heap[left], heap[now]);    return ans;&#125;bool empty()&#123;    if(heap[1]==0)return 1;    else return 0;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    memset(heap, 0, sizeof(heap));    while(t--)&#123;        int a;cin&gt;&gt;a;        if(a==1)&#123;            int b;cin&gt;&gt;b;            push(b);        &#125;        else if(a==2)&#123;            if(empty())cout&lt;&lt;&quot;empty!&quot;&lt;&lt;endl;            else cout&lt;&lt;pop()&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]TOJ 1101 哪裡有卦，哪裡就有源","url":"/sprout3-2/","content":"哪裡有卦，哪裡就有源(TOJ 1101)\n題目連結明顯的二分圖水題喔～用 dfs 把經過的點標出黑白，過程中如果遇到問題就表示非二分圖了\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;bool visit[100005],color[100005];vector&lt;int&gt; edge[100005];bool dfs(int id, bool col)&#123;    visit[id] = 1;    color[id] = col;    int len = edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = edge[id][i];        if(visit[temp])&#123;            if(color[temp]==col)return 0;            else continue;        &#125;        if(!dfs(temp, !col))return 0;    &#125;    return 1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        int m;cin&gt;&gt;m;        for(int i=0;i&lt;n;i++)edge[i].clear();        memset(visit, 0, sizeof(visit));        memset(color, 0, sizeof(color));        while(m--)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            edge[b].push_back(a);        &#125;        bool f = 1;        for(int i=0;i&lt;n;i++)&#123;            if(!visit[i])&#123;                if(!dfs(i, 0))&#123;                    f = 0;                    break;                &#125;            &#125;        &#125;        if(f)cout&lt;&lt;&quot;NORMAL.&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;RAINBOW.&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 44 喵喵抓老鼠","url":"/sprout3-3/","content":"喵喵抓老鼠\n題目連結這一題是用BFS找最短路徑，因為沒有權重，所以可以直接用BFS看多久會最先走到老鼠x y 座標原本用2個queue 分別存x跟y ，沒想到MLE了，後來改用struct，還是MLE!!不過在27行的地方有一個Bug，害我找了好久…去問了電神，才發現 visit 應該要在push 的時候就紀錄了，不要等到pop的時候，不然很多重複的會被push 進去（簡單來說，一個位置只能被push一次）\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define MAX 102using namespace std;int n,sx,sy;int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,-1,0,1&#125;;//左下右上char maze[MAX][MAX];bool visit[MAX][MAX];struct node&#123;    int x,y,path;&#125;;queue&lt;node&gt; qq;int bfs()&#123;    int now_x = sx, now_y = sy;    qq.push(node&#123;sx,sy,0&#125;);    while(!qq.empty())&#123;        now_x = qq.front().x;        now_y = qq.front().y;        if(maze[now_x][now_y]==&#x27;@&#x27;)return qq.front().path;        int front = qq.front().path+1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i],ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]!=&#x27;#&#x27;)&#123;                qq.push(node&#123;nx,ny,front&#125;);                visit[nx][ny] = 1;            &#125;        &#125;        qq.pop();    &#125;    return -1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        memset(visit, 0, sizeof(visit));        while(!qq.empty())qq.pop();        for(int i=0;i&lt;n;i++)cin&gt;&gt;maze[i];                for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;strlen(maze[i]);j++)                if(maze[i][j]==&#x27;K&#x27;)&#123;                    sx = i;sy = j;                    break;                &#125;        int ans = bfs();        if(ans&gt;=0)cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;= =\\&quot;&quot;&lt;&lt;&quot;\\n&quot;;    &#125;    return 0;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 42 庭院裡的水池","url":"/sprout3-4/","content":"庭院裡的水池\n題目連結看圖形有幾個連通圖的判斷的水題，可以用dfs 或bfs 做，小心index不要戳到負的\nBFS作法\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void bfs(int x,int y)&#123;    int now_x=x,now_y=y;    qx.push(x);    qy.push(y);    while(!qx.empty())&#123;        now_x = qx.front();now_y = qy.front();        visit[now_x][now_y]=1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i], ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;                qx.push(nx);                qy.push(ny);                visit[nx][ny] = 1;            &#125;        &#125;        qx.pop();        qy.pop();    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    bfs(i,j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nDFS作法\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void dfs(int x, int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;4;i++)&#123;        int nx = x+dx[i], ny = y+dy[i];        if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;            dfs(nx, ny);        &#125;    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    dfs(i, j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n比較上面兩種方法的複雜度BFS明顯優於DFS 啊！（遞迴本身來說就很耗記憶體?!應該是這題特殊的原因，不然應該用DFS 較優）\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]ZJ d537 染色遊戲","url":"/sprout3-5/","content":"染色遊戲—台北縣98資訊學科能力競賽\n題目連結1題目連結2\n\n一題好題勝過百題水題\n\n現在終於體會到這一句話的精髓！這是一題難題呀（neoj的測資很緊）首先先看顏色儲存的方式如果我想要讓混色時一個運算進行，那要如何以數字形式儲存顏色就顯德相當重要可以發現，用加法並不是個粉好的方法，因為顏色的數字有可能超過7因此可以用取OR的方式來完成：\n\nYELLOW : 001BLUE : 010GREEN : 011RED : 100ORANGE : 101PURPLE : 110DARK(BLACK) : 111\n\n如果以這樣的編碼方式，剛剛好可以以OR運算來就可以模擬染色（這應該只能用觀察出來吧）有了顏色的編碼方式之後，接下來就是處理點擴散的問題由 $n&lt;=1000$ 可知，如果要用2個for迴圈走訪整個畫布是不可行的因為這樣就已經$10^6$ 多幾個常數就TLE了。不能走訪每一個點，就只能好好的把要看的點push進queue裡面每一次針對要找的節點，就能節省不必要的運算\n最後，要怎麼維護點呢？用一個struct 儲存，除了座標之外，就是出現的時間還有顏色\n            我遇到TLE 或 WA的BUG：用 $n^2$ 掃描整個畫布—TLEpush進一個struct時要在名字部分括號起來：queue&lt;node&gt; q;q.push((node)&#123;1,2,3,4&#125;);沒有加上遇到減少就break的條件，所以每一次都必須要整個畫布都變成黑色才會輸出—TLE沒有紀錄一個點有沒有被三原色走過，一個點可能被走過很多次—TLE邊界要好好維護，一個較方便的作法，讓index都從1開始，這樣相加相減變成-1 時才不會RE時間優化：明顯知道答案（如問D的情況），就直接輸出$n^2$就好\n          \n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,col[150],dx[8] = &#123;-1,0,1,1,1,0,-1,-1&#125;,    dy[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;,board[1005][1005];bool visit[1005][1005][5];//三原色每一個點只能被走一次int encode(char a)&#123;    col[&#x27;Y&#x27;] = 1;col[&#x27;B&#x27;] = 2;col[&#x27;G&#x27;] = 3;col[&#x27;R&#x27;] = 4;    col[&#x27;O&#x27;] = 5;col[&#x27;P&#x27;] = 6;col[&#x27;D&#x27;] = 7;    return col[a];&#125;struct node&#123;    int x,y,time,color;&#125;;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        queue&lt;node&gt; qq;        memset(board, 0, sizeof(board));        memset(visit, 0, sizeof(visit));        char a;        for(int i=0;i&lt;3;i++)&#123;            int b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;b++;c++;            qq.push((node)&#123;b,c,1,encode(a)&#125;);            board[b][c] = encode(a);        &#125;        cin&gt;&gt;a;        int target = encode(a),cur_sum = 0,ans = 0,time = 1;        if(a==&#x27;B&#x27;||a==&#x27;Y&#x27;||a==&#x27;R&#x27;)cur_sum++;//當要求的是三原色，初始的數量可以加一                if(a==&#x27;D&#x27;)&#123;            cout&lt;&lt;n*n&lt;&lt;endl;            continue;        &#125;//如果是D的話，只需要輸出n^2，可以節省不少時間        while(!qq.empty())&#123;//BFS 開始            while(!qq.empty() &amp;&amp; qq.front().time==time)&#123;//開始每一個時刻的模擬                int nx = qq.front().x,ny = qq.front().y;                for(int i=0;i&lt;8;i++)&#123;                    int x = nx+dx[i],y = ny+dy[i];                    if(x&lt;=0 ||x&gt;n||y&lt;=0||y&gt;n||board[x][y]==7||                       visit[x][y][qq.front().color])continue;//超出邊界或曾拜訪或已塗黑可跳過                    qq.push((node)&#123;x,y,time+1,qq.front().color&#125;);//push下一時刻的node                    int new_color = board[x][y]|qq.front().color;//比較新的顏色與舊的顏色                    if(new_color!=board[x][y])&#123;//顏色不同時要比較狀況                        if(new_color==target)cur_sum++;//新顏色是但舊顏色不一樣 則加一                        else if(board[x][y]==target)cur_sum--;//舊的是新的不是 則減一                    &#125;                    board[x][y]|=qq.front().color;//對新方塊上色                    visit[x][y][qq.front().color] = 1;//此顏色已經拜訪                &#125;                qq.pop();//pop from queue            &#125;            time++;//一輪模擬結束            if(ans&gt;cur_sum)break;//因為數量會先非嚴格遞增、後非嚴格遞減            ans = max(ans, cur_sum);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第三週：基礎圖論、淹水問題","url":"/sprout3/","content":"前兩次上課還沒來得及補齊，先來紀錄一下第三週的內容\n上課內容這一週的主題是基礎圖論、淹水問題(BFS)還有Heap!把這幾個單元排在一起真的是負擔很重QQ\n\n基礎圖論之前就有聽過，所以在寫題目感覺還好，不會很吃力\nHeap則是我第一次接觸到的資料結構，當周上課前把影片（介紹Binary Heap）之後，上課就直接講合併Heap、黑魔法Heap、左偏樹等等把我電爛的東西\n淹水問題，上課沒有特別介紹，因為講師說他不喜歡Flood Fill 演算法所以只講了可以用 dx 和 dy 表示上下左右的方位，其他的都沒講，只能自己看影片了呀～\n\n這一週是段考週呀 我得花一些時間讀段考，不然段考要爆炸了...\n\n上機作業Heap 練習題目連結刻一個heap嘛，不想刻就call stl( std::priorityqueue 就不放上來了)自己刻一個binary heap ，沒有想象中的簡單，有些細節會不小心漏掉\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int t,top=1,heap[1000005];//complete binary treevoid push(int n)&#123;    heap[top] = n;    int father_pos = top/2,pos = top;    while(father_pos&gt;0 &amp;&amp; heap[father_pos]&gt;heap[pos])&#123;        swap(heap[father_pos], heap[pos]);        pos = father_pos;        father_pos/=2;    &#125;    top = top+1;&#125;int pop()&#123;    int ans = heap[1];    heap[1] = heap[--top];    heap[top] = 0;    int now = 1,left = now*2, right = now*2+1;        int temp = min(heap[right],heap[left]);    while(heap[left]!=0 &amp;&amp; heap[right]!=0 &amp;&amp; heap[now]&gt;temp)&#123;        if(heap[now]&gt;heap[right] &amp;&amp; heap[left]&gt;heap[right])&#123;            swap(heap[right], heap[now]);            now = right;        &#125;        else if(heap[now]&gt;heap[left])&#123;            swap(heap[left], heap[now]);            now = left;        &#125;        right = now*2+1;        left = now*2;        temp = min(heap[right],heap[left]);    &#125;    if(heap[right]!=0 &amp;&amp; heap[now]&gt;heap[right])swap(heap[right], heap[now]);    else if(heap[left]!=0 &amp;&amp; heap[now]&gt;heap[left])swap(heap[left], heap[now]);    return ans;&#125;bool empty()&#123;    if(heap[1]==0)return 1;    else return 0;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    memset(heap, 0, sizeof(heap));    while(t--)&#123;        int a;cin&gt;&gt;a;        if(a==1)&#123;            int b;cin&gt;&gt;b;            push(b);        &#125;        else if(a==2)&#123;            if(empty())cout&lt;&lt;&quot;empty!&quot;&lt;&lt;endl;            else cout&lt;&lt;pop()&lt;&lt;endl;        &#125;    &#125;&#125;\n哪裡有卦，哪裡就有源(TOJ 1101)題目連結明顯的二分圖水題喔～用 dfs 把經過的點標出黑白，過程中如果遇到問題就表示非二分圖了\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;bool visit[100005],color[100005];vector&lt;int&gt; edge[100005];bool dfs(int id, bool col)&#123;    visit[id] = 1;    color[id] = col;    int len = edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = edge[id][i];        if(visit[temp])&#123;            if(color[temp]==col)return 0;            else continue;        &#125;        if(!dfs(temp, !col))return 0;    &#125;    return 1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        int m;cin&gt;&gt;m;        for(int i=0;i&lt;n;i++)edge[i].clear();        memset(visit, 0, sizeof(visit));        memset(color, 0, sizeof(color));        while(m--)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            edge[b].push_back(a);        &#125;        bool f = 1;        for(int i=0;i&lt;n;i++)&#123;            if(!visit[i])&#123;                if(!dfs(i, 0))&#123;                    f = 0;                    break;                &#125;            &#125;        &#125;        if(f)cout&lt;&lt;&quot;NORMAL.&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;RAINBOW.&quot;&lt;&lt;endl;    &#125;&#125;\n喵喵抓老鼠題目連結這一題是用BFS找最短路徑，因為沒有權重，所以可以直接用BFS看多久會最先走到老鼠x y 座標原本用2個queue 分別存x跟y ，沒想到MLE了，後來改用struct，還是MLE!!不過在27行的地方有一個Bug，害我找了好久…去問了電神，才發現 visit 應該要在push 的時候就紀錄了，不要等到pop的時候，不然很多重複的會被push 進去（簡單來說，一個位置只能被push一次）\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define MAX 102using namespace std;int n,sx,sy;int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,-1,0,1&#125;;//左下右上char maze[MAX][MAX];bool visit[MAX][MAX];struct node&#123;    int x,y,path;&#125;;queue&lt;node&gt; qq;int bfs()&#123;    int now_x = sx, now_y = sy;    qq.push(node&#123;sx,sy,0&#125;);    while(!qq.empty())&#123;        now_x = qq.front().x;        now_y = qq.front().y;        if(maze[now_x][now_y]==&#x27;@&#x27;)return qq.front().path;        int front = qq.front().path+1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i],ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]!=&#x27;#&#x27;)&#123;                qq.push(node&#123;nx,ny,front&#125;);                visit[nx][ny] = 1;            &#125;        &#125;        qq.pop();    &#125;    return -1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        memset(visit, 0, sizeof(visit));        while(!qq.empty())qq.pop();        for(int i=0;i&lt;n;i++)cin&gt;&gt;maze[i];                for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;strlen(maze[i]);j++)                if(maze[i][j]==&#x27;K&#x27;)&#123;                    sx = i;sy = j;                    break;                &#125;        int ans = bfs();        if(ans&gt;=0)cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;= =\\&quot;&quot;&lt;&lt;&quot;\\n&quot;;    &#125;    return 0;&#125;\n庭院裡的水池題目連結看圖形有幾個連通圖的判斷的水題，可以用dfs 或bfs 做，小心index不要戳到負的\nBFS作法\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void bfs(int x,int y)&#123;    int now_x=x,now_y=y;    qx.push(x);    qy.push(y);    while(!qx.empty())&#123;        now_x = qx.front();now_y = qy.front();        visit[now_x][now_y]=1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i], ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;                qx.push(nx);                qy.push(ny);                visit[nx][ny] = 1;            &#125;        &#125;        qx.pop();        qy.pop();    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    bfs(i,j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nDFS作法\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void dfs(int x, int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;4;i++)&#123;        int nx = x+dx[i], ny = y+dy[i];        if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;            dfs(nx, ny);        &#125;    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    dfs(i, j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n比較上面兩種方法的複雜度BFS明顯優於DFS 啊！（遞迴本身來說就很耗記憶體?!應該是這題特殊的原因，不然應該用DFS 較優）\n染色遊戲—台北縣98資訊學科能力競賽題目連結1題目連結2\n\n一題好題勝過百題水題\n\n現在終於體會到這一句話的精髓！這是一題難題呀（neoj的測資很緊）首先先看顏色儲存的方式如果我想要讓混色時一個運算進行，那要如何以數字形式儲存顏色就顯德相當重要可以發現，用加法並不是個粉好的方法，因為顏色的數字有可能超過7因此可以用取OR的方式來完成：\n\nYELLOW : 001BLUE : 010GREEN : 011RED : 100ORANGE : 101PURPLE : 110DARK(BLACK) : 111\n\n如果以這樣的編碼方式，剛剛好可以以OR運算來就可以模擬染色（這應該只能用觀察出來吧）有了顏色的編碼方式之後，接下來就是處理點擴散的問題由 $n&lt;=1000$ 可知，如果要用2個for迴圈走訪整個畫布是不可行的因為這樣就已經$10^6$ 多幾個常數就TLE了。不能走訪每一個點，就只能好好的把要看的點push進queue裡面每一次針對要找的節點，就能節省不必要的運算\n最後，要怎麼維護點呢？用一個struct 儲存，除了座標之外，就是出現的時間還有顏色\n            我遇到TLE 或 WA的BUG：用 $n^2$ 掃描整個畫布—TLEpush進一個struct時要在名字部分括號起來：queue&lt;node&gt; q;q.push((node)&#123;1,2,3,4&#125;);沒有加上遇到減少就break的條件，所以每一次都必須要整個畫布都變成黑色才會輸出—TLE沒有紀錄一個點有沒有被三原色走過，一個點可能被走過很多次—TLE邊界要好好維護，一個較方便的作法，讓index都從1開始，這樣相加相減變成-1 時才不會RE時間優化：明顯知道答案（如問D的情況），就直接輸出$n^2$就好\n          \n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,col[150],dx[8] = &#123;-1,0,1,1,1,0,-1,-1&#125;,    dy[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;,board[1005][1005];bool visit[1005][1005][5];//三原色每一個點只能被走一次int encode(char a)&#123;    col[&#x27;Y&#x27;] = 1;col[&#x27;B&#x27;] = 2;col[&#x27;G&#x27;] = 3;col[&#x27;R&#x27;] = 4;    col[&#x27;O&#x27;] = 5;col[&#x27;P&#x27;] = 6;col[&#x27;D&#x27;] = 7;    return col[a];&#125;struct node&#123;    int x,y,time,color;&#125;;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        queue&lt;node&gt; qq;        memset(board, 0, sizeof(board));        memset(visit, 0, sizeof(visit));        char a;        for(int i=0;i&lt;3;i++)&#123;            int b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;b++;c++;            qq.push((node)&#123;b,c,1,encode(a)&#125;);            board[b][c] = encode(a);        &#125;        cin&gt;&gt;a;        int target = encode(a),cur_sum = 0,ans = 0,time = 1;        if(a==&#x27;B&#x27;||a==&#x27;Y&#x27;||a==&#x27;R&#x27;)cur_sum++;//當要求的是三原色，初始的數量可以加一                if(a==&#x27;D&#x27;)&#123;            cout&lt;&lt;n*n&lt;&lt;endl;            continue;        &#125;//如果是D的話，只需要輸出n^2，可以節省不少時間        while(!qq.empty())&#123;//BFS 開始            while(!qq.empty() &amp;&amp; qq.front().time==time)&#123;//開始每一個時刻的模擬                int nx = qq.front().x,ny = qq.front().y;                for(int i=0;i&lt;8;i++)&#123;                    int x = nx+dx[i],y = ny+dy[i];                    if(x&lt;=0 ||x&gt;n||y&lt;=0||y&gt;n||board[x][y]==7||                       visit[x][y][qq.front().color])continue;//超出邊界或曾拜訪或已塗黑可跳過                    qq.push((node)&#123;x,y,time+1,qq.front().color&#125;);//push下一時刻的node                    int new_color = board[x][y]|qq.front().color;//比較新的顏色與舊的顏色                    if(new_color!=board[x][y])&#123;//顏色不同時要比較狀況                        if(new_color==target)cur_sum++;//新顏色是但舊顏色不一樣 則加一                        else if(board[x][y]==target)cur_sum--;//舊的是新的不是 則減一                    &#125;                    board[x][y]|=qq.front().color;//對新方塊上色                    visit[x][y][qq.front().color] = 1;//此顏色已經拜訪                &#125;                qq.pop();//pop from queue            &#125;            time++;//一輪模擬結束            if(ans&gt;cur_sum)break;//因為數量會先非嚴格遞增、後非嚴格遞減            ans = max(ans, cur_sum);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n手寫作業這一週的手寫作業是介紹c++ 的記憶體使用方式，什麼變數應該會被存在什麼位置之類的，heap 與stack 還有虛擬記憶體，以及為什麼有時候寫dfs遞迴下去會RE的問題（我是還沒有遇過啦）總之終於沒有數學證明題了！\n\n今天段考果然炸裂了QQQQQQQ\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","圖論","淹水問題"]},{"title":"[題解]TIOJ 1025 數獨問題","url":"/sprout4-1/","content":"數獨\n題目連結首先是數獨，很有趣，之前有做過類似的是八皇后問題用到DFS剪枝，筆記在這\n#include &lt;bits/stdc++.h&gt;using namespace std;class Sudoku&#123;private:    int maze[9][9];    bool flag = false;public:    void print(string s);//    void scan_maze();//    vector&lt;int&gt; select(int, int);    int next_empty(int, int);    void solving();    void dfs(int row, int col );    &#125;;void Sudoku::print(string s)&#123;    cout&lt;&lt;endl&lt;&lt;&quot;=====&quot;&lt;&lt;s&lt;&lt;&quot;======&quot;&lt;&lt;endl;    for (int i=0; i&lt;9;i++)&#123;        cout&lt;&lt;&quot;|&quot;;        for (int j=0;j&lt;9;j++)&#123;            cout&lt;&lt;maze[i][j];            if(j%3==2)cout&lt;&lt;&quot;|&quot;;        &#125;        cout&lt;&lt;endl;        if(i%3==2)cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;    &#125;&#125;vector&lt;int&gt; Sudoku::select(int r, int c)&#123;    bool box[9]=&#123;0&#125;;    for(int i=0;i&lt;9;i++)&#123;        if(maze[i][c]&gt;0)box[maze[i][c]-1] = 1;        if(maze[r][i]&gt;0)box[maze[r][i]-1] = 1;    &#125;    int row_start = 3*(r/3),col_start = 3*(c/3);    for(int i=0;i&lt;3;i++)&#123;        for(int j=0;j&lt;3;j++)&#123;            if(maze[row_start+i][col_start+j]&gt;0)                box[maze[row_start+i][col_start+j]-1] = 1;        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i=0;i&lt;9;i++)        if(!box[i])ans.push_back(i+1);    return ans;&#125;int Sudoku::next_empty(int row, int col)&#123;    int ind = col;    for(int i=row;i&lt;9;i++)&#123;        while(ind&lt;9)&#123;            if(maze[i][ind]==0)&#123;                int pos = i*9+ind;                return pos;            &#125;            ind++;        &#125;        ind = 0;    &#125;    return -1;&#125;void Sudoku::dfs(int row, int col )&#123;    int pos = next_empty(row, col),nr,nc;    if(pos == -1)&#123;        flag = true;        return;    &#125;    vector&lt;int&gt; candidate = select(row, col);    int len = candidate.size();        for(int i=0;i&lt;len;i++)&#123;        maze[row][col] = candidate[i];        pos = next_empty(row, col);        nr = pos/9; nc = pos%9;        dfs(nr, nc);        if(flag)return;    &#125;    maze[row][col] = 0;&#125;void Sudoku::scan_maze()&#123;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 0;            else maze[i][j] = temp -&#x27;0&#x27;;        &#125;    &#125;&#125;void Sudoku::solving()&#123;    int first_empty = next_empty(0, 0),nr,nc;    nr = first_empty/9; nc = first_empty%9;    dfs(nr, nc);    bool f = false;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            vector&lt;int&gt; v = select(i,j);            if(v.size()&gt;0)f = true;        &#125;    &#125;    if(!flag || f)cout&lt;&lt;&quot;No solution.&quot;&lt;&lt;endl;    else&#123;        print(&quot;solved&quot;);    &#125;    flag = false;&#125;int main()&#123;    Sudoku sodoku1;    sodoku1.scan_maze();    sodoku1.print(&quot;begin&quot;);    sodoku1.solving();&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 63 Lotto(UVA)","url":"/sprout4-2/","content":"Lotto(UVA)\n題目連結這一題主要就是建立一個排列樹，把每一種可能的情況用遞迴列出來這一題用DFS明顯比BFS來得好、空間省很多（用一下資芽的圖XD)\n來看程式碼吧！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[15];void permutation(int arr_ind, int cur[],int cur_ind)&#123;    if(arr_ind&gt;n)return;    if(cur_ind&gt;=6)&#123;        for(int i=0;i&lt;6;i++)&#123;            if(i&gt;0)cout&lt;&lt;&quot; &quot;;            cout&lt;&lt;cur[i];        &#125;        cout&lt;&lt;endl;        return;    &#125;    for(int i = 0; i &lt;= n-(6-cur_ind); i++)&#123;        cur[cur_ind] = arr[arr_ind+i];        permutation(arr_ind+i+1, cur, cur_ind+1);    &#125;&#125;bool f=0;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;    if(f)cout&lt;&lt;endl;    memset(arr, 0, sizeof(arr));    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr, arr+n);    int cur[10];    permutation(0, cur, 0);    f=1;    &#125;&#125;\n\n            這一題必須很小心輸入輸出，它們會讓你WA很久呀！行末不要多餘空白測資全部印出來後，末端不要多餘換行大概就這兩點\n          \n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 69 田忌賽馬(NPSC)","url":"/sprout4-3/","content":"田忌賽馬(NPSC)\n題目連結之前有寫過這一題，不過現在再寫一次還是WA了很久，對於二分搜的維護（到底是取到0還是1）還要更熟悉除此之外，我因為邊界問題（$10^8$ 或是$10^8+1$）沒有仔細注意就一直WA\n#include &lt;bits/stdc++.h&gt;#define N 10000 using namespace std;  lli n,k,t,M,upper = 100000000,lower = -1;  lli mine[N],develop[N],enemy[N],curr[N];  bool win(lli day)&#123;      int it = 0,sum = 0;      for(int i=0;i&lt;n;i++)          curr[i] = mine[i]+day*develop[i];      sort(curr, curr+n);      for(int i=0;i&lt;n;i++)&#123;          if(curr[i]&gt;enemy[it])&#123;              sum++;              it++;          &#125;      &#125;      return (sum&gt;=k);  &#125;    int main()&#123;      ios::sync_with_stdio(false);      cin.tie(0);      cin&gt;&gt;t;      while(t--)&#123;          upper = 100000000;lower = -1;          cin&gt;&gt;n&gt;&gt;k;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;mine[i]&gt;&gt;develop[i];          &#125;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;enemy[i];          &#125;          sort(enemy, enemy+n);          if(!win(upper))cout&lt;&lt;-1&lt;&lt;endl;          else&#123;              while(upper-lower!=1)&#123;                  M = (upper+lower)/2;                  if(win(M))upper = M;                  else lower = M;              &#125;              cout&lt;&lt;upper&lt;&lt;endl;          &#125;      &#125;  &#125;  \n\n            這樣維護二分搜也可以，就是保證 r 一定是1（l就不一定）while(r&gt;l)&#123;    int mid = (l+r)/2, arr[n+5];    for(int i=0;i&lt;n;i++)arr[i] = mine[i]+mid*rate[i];        sort(arr, arr+n,greater&lt;int&gt;());        int f = can_win(arr, enemy);        if(f)r = mid;        else l = mid+1;    &#125;單純二分搜，找01分界點！\n          \n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 72 Happiness Function","url":"/sprout4-4/","content":"Happiness Function(2013 台清交程式設計競賽)\n題目連結很酷的題目，首先必須做一點數學上的分析\n            假設題目給定的n個二次函數依序為$A_1(x),A_2(x),…,A_n(x)$令函數$f(t)=max(A_j(t), 1&lt;=j&lt;=n)$則$f(t)$為一個U型函數\n          有了這個性質之後就可以利用三分搜來找U型函數的最小值!\n值得注意的是：\n\nfloat 是單精度浮點數、double 是雙精度浮點數，我用 float吃了好幾個WA，結果用double 直接 AC\nwhile 迴圈裡面的判斷不要用浮點數相減，會出事（TLE）\n\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define float ausing namespace std;int T,n;double a[12],b[12],c[12];double func(double t, int i)&#123;    return a[i]*(t-b[i])*(t-b[i])+c[i];&#125;int main()&#123;    ios;    cout&lt;&lt;fixed&lt;&lt;setprecision(5);    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];        double left = 0.0, right = 300.0;        double now_l = 0,now_r = 0,nl = 0,nr = 0;        int cnt = 0;        while(cnt&lt;=10000)&#123;            nl = (2*left+right)/3;            nr = (2*right+left)/3;            now_l = now_r = 0;            for(int i=0;i&lt;n;i++)now_r = max(now_r, func(nr,i));            for(int i=0;i&lt;n;i++)now_l = max(now_l, func(nl,i));            if(now_r &gt; now_l)right = nr;            else left = nl;            cnt++;        &#125;        cout&lt;&lt;now_l&lt;&lt;endl;    &#125;&#125;\n簡單統整，就是三分搜找最低點！\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 73 東方古墓古文","url":"/sprout4-5/","content":"東方古墓古文\n題目連結這一題主要是二分搜工作量上限X，寫一個函數判斷是否工作量X是否可行Debug 超久，不知道在幹嘛，結果最後是卡在二分搜的上界範圍不夠大要開到$10^9$這麼大！時間複雜度：$N$$log$(總工作量)\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;int n,m,arr[100005];bool is_ok(int lim)&#123;    int sum = 0,ans = 1;    for(int i=0;i&lt;n;i++)&#123;        if(arr[i]&gt;lim)return 0;        sum += arr[i];        if(sum+arr[i+1] &gt; lim)&#123;            sum = 0;            ans++;        &#125;    &#125;    if(ans&gt;m)return 0;    else return 1;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n&gt;&gt;m;        memset(arr, 0, sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        arr[n] = -INT_MAX;        int r = 1000000001,l = 0;        while(r-l &gt; 1)&#123;            int mid = (l+r)/2;            if(is_ok(mid))r = mid;            else l = mid;        &#125;        if(r == 1000000001)cout&lt;&lt;1000000000&lt;&lt;endl;        else cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 60 極速馬拉松","url":"/sprout4-6/","content":"極速馬拉松\n題目連結這一題難的主要是變數太多只要理解它到底要幹嘛，就可以發現可以利用$O(N)$枚舉出固定去間內最大的距離之後再$O(logN)$ 二分搜時間就可以用$O(logN)$ AC這一題\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int a,b,c,d,m,s,t;int func(int time)&#123;    int speed_time = m/c,max_distance = 0,cur_m = m%c;    int cur_distance = b*speed_time,cur_t = speed_time;    if(cur_t&lt;time)&#123;        int len = time-cur_t;        for(int i=0;i&lt;=len;i++)&#123;//時限內最多可以跑多遠            cur_distance = b*speed_time;            cur_t = speed_time+i;            cur_m = (m%c)+d*i;            int step = min(cur_m/c,time-cur_t);            cur_m = cur_m-step*c;            cur_t+=step;            cur_distance += b*step;            cur_distance+=a*(time-cur_t);            max_distance = max(max_distance,cur_distance);        &#125;    &#125;    else max_distance = b*time;    return max_distance;&#125;signed main()&#123;    ios;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;m&gt;&gt;s&gt;&gt;t;    int max_distance = func(t);    if(s&gt;=max_distance)cout&lt;&lt;&quot;No&quot;&lt;&lt;endl&lt;&lt;max_distance&lt;&lt;endl;    else&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        int r = t,l = 0;        while(r-l&gt;1)&#123;            int mid = (r+l)/2;            if(func(mid)&gt;s)r = mid;            else l = mid;        &#125;        cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第四週：枚舉算法","url":"/sprout4/","content":"上課內容這一週的主題是枚舉(enumeration)，內容主要環繞二分搜、三分搜、DFS剪枝這些部分。這一週的內容算是相對輕鬆，解數獨的部分也是蠻有趣的！\n上機作業數獨題目連結首先是數獨，很有趣，之前有做過類似的是八皇后問題用到DFS剪枝，筆記在這\n#include &lt;bits/stdc++.h&gt;using namespace std;class Sudoku&#123;private:    int maze[9][9];    bool flag = false;public:    void print(string s);//    void scan_maze();//    vector&lt;int&gt; select(int, int);    int next_empty(int, int);    void solving();    void dfs(int row, int col );    &#125;;void Sudoku::print(string s)&#123;    cout&lt;&lt;endl&lt;&lt;&quot;=====&quot;&lt;&lt;s&lt;&lt;&quot;======&quot;&lt;&lt;endl;    for (int i=0; i&lt;9;i++)&#123;        cout&lt;&lt;&quot;|&quot;;        for (int j=0;j&lt;9;j++)&#123;            cout&lt;&lt;maze[i][j];            if(j%3==2)cout&lt;&lt;&quot;|&quot;;        &#125;        cout&lt;&lt;endl;        if(i%3==2)cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;    &#125;&#125;vector&lt;int&gt; Sudoku::select(int r, int c)&#123;    bool box[9]=&#123;0&#125;;    for(int i=0;i&lt;9;i++)&#123;        if(maze[i][c]&gt;0)box[maze[i][c]-1] = 1;        if(maze[r][i]&gt;0)box[maze[r][i]-1] = 1;    &#125;    int row_start = 3*(r/3),col_start = 3*(c/3);    for(int i=0;i&lt;3;i++)&#123;        for(int j=0;j&lt;3;j++)&#123;            if(maze[row_start+i][col_start+j]&gt;0)                box[maze[row_start+i][col_start+j]-1] = 1;        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i=0;i&lt;9;i++)        if(!box[i])ans.push_back(i+1);    return ans;&#125;int Sudoku::next_empty(int row, int col)&#123;    int ind = col;    for(int i=row;i&lt;9;i++)&#123;        while(ind&lt;9)&#123;            if(maze[i][ind]==0)&#123;                int pos = i*9+ind;                return pos;            &#125;            ind++;        &#125;        ind = 0;    &#125;    return -1;&#125;void Sudoku::dfs(int row, int col )&#123;    int pos = next_empty(row, col),nr,nc;    if(pos == -1)&#123;        flag = true;        return;    &#125;    vector&lt;int&gt; candidate = select(row, col);    int len = candidate.size();        for(int i=0;i&lt;len;i++)&#123;        maze[row][col] = candidate[i];        pos = next_empty(row, col);        nr = pos/9; nc = pos%9;        dfs(nr, nc);        if(flag)return;    &#125;    maze[row][col] = 0;&#125;void Sudoku::scan_maze()&#123;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 0;            else maze[i][j] = temp -&#x27;0&#x27;;        &#125;    &#125;&#125;void Sudoku::solving()&#123;    int first_empty = next_empty(0, 0),nr,nc;    nr = first_empty/9; nc = first_empty%9;    dfs(nr, nc);    bool f = false;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            vector&lt;int&gt; v = select(i,j);            if(v.size()&gt;0)f = true;        &#125;    &#125;    if(!flag || f)cout&lt;&lt;&quot;No solution.&quot;&lt;&lt;endl;    else&#123;        print(&quot;solved&quot;);    &#125;    flag = false;&#125;int main()&#123;    Sudoku sodoku1;    sodoku1.scan_maze();    sodoku1.print(&quot;begin&quot;);    sodoku1.solving();&#125;\nLotto(UVA)題目連結這一題主要就是建立一個排列樹，把每一種可能的情況用遞迴列出來這一題用DFS明顯比BFS來得好、空間省很多（用一下資芽的圖XD)\n來看程式碼吧！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[15];void permutation(int arr_ind, int cur[],int cur_ind)&#123;    if(arr_ind&gt;n)return;    if(cur_ind&gt;=6)&#123;        for(int i=0;i&lt;6;i++)&#123;            if(i&gt;0)cout&lt;&lt;&quot; &quot;;            cout&lt;&lt;cur[i];        &#125;        cout&lt;&lt;endl;        return;    &#125;    for(int i = 0; i &lt;= n-(6-cur_ind); i++)&#123;        cur[cur_ind] = arr[arr_ind+i];        permutation(arr_ind+i+1, cur, cur_ind+1);    &#125;&#125;bool f=0;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;    if(f)cout&lt;&lt;endl;    memset(arr, 0, sizeof(arr));    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr, arr+n);    int cur[10];    permutation(0, cur, 0);    f=1;    &#125;&#125;\n\n            這一題必須很小心輸入輸出，它們會讓你WA很久呀！行末不要多餘空白測資全部印出來後，末端不要多餘換行大概就這兩點\n          \n田忌賽馬(NPSC)題目連結之前有寫過這一題，不過現在再寫一次還是WA了很久，對於二分搜的維護（到底是取到0還是1）還要更熟悉除此之外，我因為邊界問題（$10^8$ 或是$10^8+1$）沒有仔細注意就一直WA\n#include &lt;bits/stdc++.h&gt;#define N 10000 using namespace std;  lli n,k,t,M,upper = 100000000,lower = -1;  lli mine[N],develop[N],enemy[N],curr[N];  bool win(lli day)&#123;      int it = 0,sum = 0;      for(int i=0;i&lt;n;i++)          curr[i] = mine[i]+day*develop[i];      sort(curr, curr+n);      for(int i=0;i&lt;n;i++)&#123;          if(curr[i]&gt;enemy[it])&#123;              sum++;              it++;          &#125;      &#125;      return (sum&gt;=k);  &#125;    int main()&#123;      ios::sync_with_stdio(false);      cin.tie(0);      cin&gt;&gt;t;      while(t--)&#123;          upper = 100000000;lower = -1;          cin&gt;&gt;n&gt;&gt;k;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;mine[i]&gt;&gt;develop[i];          &#125;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;enemy[i];          &#125;          sort(enemy, enemy+n);          if(!win(upper))cout&lt;&lt;-1&lt;&lt;endl;          else&#123;              while(upper-lower!=1)&#123;                  M = (upper+lower)/2;                  if(win(M))upper = M;                  else lower = M;              &#125;              cout&lt;&lt;upper&lt;&lt;endl;          &#125;      &#125;  &#125;  \n\n            這樣維護二分搜也可以，就是保證 r 一定是1（l就不一定）while(r&gt;l)&#123;    int mid = (l+r)/2, arr[n+5];    for(int i=0;i&lt;n;i++)arr[i] = mine[i]+mid*rate[i];        sort(arr, arr+n,greater&lt;int&gt;());        int f = can_win(arr, enemy);        if(f)r = mid;        else l = mid+1;    &#125;單純二分搜，找01分界點！\n          \nHappiness Function(2013 台清交程式設計競賽)題目連結很酷的題目，首先必須做一點數學上的分析\n            假設題目給定的n個二次函數依序為$A_1(x),A_2(x),…,A_n(x)$令函數$f(t)=max(A_j(t), 1&lt;=j&lt;=n)$則$f(t)$為一個U型函數\n          有了這個性質之後就可以利用三分搜來找U型函數的最小值!\n值得注意的是：\n\nfloat 是單精度浮點數、double 是雙精度浮點數，我用 float吃了好幾個WA，結果用double 直接 AC\nwhile 迴圈裡面的判斷不要用浮點數相減，會出事（TLE）\n\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define float ausing namespace std;int T,n;double a[12],b[12],c[12];double func(double t, int i)&#123;    return a[i]*(t-b[i])*(t-b[i])+c[i];&#125;int main()&#123;    ios;    cout&lt;&lt;fixed&lt;&lt;setprecision(5);    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];        double left = 0.0, right = 300.0;        double now_l = 0,now_r = 0,nl = 0,nr = 0;        int cnt = 0;        while(cnt&lt;=10000)&#123;            nl = (2*left+right)/3;            nr = (2*right+left)/3;            now_l = now_r = 0;            for(int i=0;i&lt;n;i++)now_r = max(now_r, func(nr,i));            for(int i=0;i&lt;n;i++)now_l = max(now_l, func(nl,i));            if(now_r &gt; now_l)right = nr;            else left = nl;            cnt++;        &#125;        cout&lt;&lt;now_l&lt;&lt;endl;    &#125;&#125;\n簡單統整，就是三分搜找最低點！\n東方古墓古文題目連結這一題主要是二分搜工作量上限X，寫一個函數判斷是否工作量X是否可行Debug 超久，不知道在幹嘛，結果最後是卡在二分搜的上界範圍不夠大要開到$10^9$這麼大！時間複雜度：$N$$log$(總工作量)\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;int n,m,arr[100005];bool is_ok(int lim)&#123;    int sum = 0,ans = 1;    for(int i=0;i&lt;n;i++)&#123;        if(arr[i]&gt;lim)return 0;        sum += arr[i];        if(sum+arr[i+1] &gt; lim)&#123;            sum = 0;            ans++;        &#125;    &#125;    if(ans&gt;m)return 0;    else return 1;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n&gt;&gt;m;        memset(arr, 0, sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        arr[n] = -INT_MAX;        int r = 1000000001,l = 0;        while(r-l &gt; 1)&#123;            int mid = (l+r)/2;            if(is_ok(mid))r = mid;            else l = mid;        &#125;        if(r == 1000000001)cout&lt;&lt;1000000000&lt;&lt;endl;        else cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\n極速馬拉松題目連結這一題難的主要是變數太多只要理解它到底要幹嘛，就可以發現可以利用$O(N)$枚舉出固定去間內最大的距離之後再$O(logN)$ 二分搜時間就可以用$O(logN)$ AC這一題\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int a,b,c,d,m,s,t;int func(int time)&#123;    int speed_time = m/c,max_distance = 0,cur_m = m%c;    int cur_distance = b*speed_time,cur_t = speed_time;    if(cur_t&lt;time)&#123;        int len = time-cur_t;        for(int i=0;i&lt;=len;i++)&#123;//時限內最多可以跑多遠            cur_distance = b*speed_time;            cur_t = speed_time+i;            cur_m = (m%c)+d*i;            int step = min(cur_m/c,time-cur_t);            cur_m = cur_m-step*c;            cur_t+=step;            cur_distance += b*step;            cur_distance+=a*(time-cur_t);            max_distance = max(max_distance,cur_distance);        &#125;    &#125;    else max_distance = b*time;    return max_distance;&#125;signed main()&#123;    ios;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;m&gt;&gt;s&gt;&gt;t;    int max_distance = func(t);    if(s&gt;=max_distance)cout&lt;&lt;&quot;No&quot;&lt;&lt;endl&lt;&lt;max_distance&lt;&lt;endl;    else&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        int r = t,l = 0;        while(r-l&gt;1)&#123;            int mid = (r+l)/2;            if(func(mid)&gt;s)r = mid;            else l = mid;        &#125;        cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\n人生低潮題目連結\n手寫作業手寫作業介紹字串比對、各種排序演算法。這是我算是第一次搞懂快速排序在幹嘛，不然之前都是看兩個指針在指來指去不知道確切的功能是什麼。除了快排之外，基數排序也是第一次看到，原來排序可以做到線性時間複雜度！大開眼界！（不過只是用於整數排序）這次手寫覺得有些困難，不過學到了很多東西！（可以來做一個各種排序演算的筆記）\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","枚舉"]},{"title":"[題解]NEOJ 70 Add all(UVA)","url":"/sprout5-1/","content":"Add all(UVA)\n題目連結這一題可以輕鬆觀察出規律：數字越早被相加，被加總的次數就會越多因此，維護一個priority_queue，每次pop出最小的兩個數字再push 回去，可以保證總和一定會是最小的\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    ios;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qq;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            qq.push(temp);        &#125;        int ans = 0;        while(qq.size()&gt;1)&#123;            int a,b;            a = qq.top();qq.pop();            b = qq.top();qq.pop();            qq.push(a+b);            ans+=(a+b);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;        qq.pop();    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 74 円円攻略黃河(TIOJ)","url":"/sprout5-2/","content":"円円攻略黃河(TIOJ)\n題目連結這一題要求最長的長短相間的序列長度，雖然知道是Greedy ，但第一時間想不到具體的作法卡了有一點久，總共嘗試了三次，前兩次以為對，但WA 後還是發現其中的Bug\n\n從第一個數字開始，找到下一個比自己小的數字，再找比那一個大的，重複幾次直到結束\n            問題在於，第一個數字可能很小，導致接下來的序列長度很短\n          \n找到第一個「下一個數比自己小」的數字，接著重複第1點的步驟\n            因為要保證序列是最長的，會希望在找比自己大或小的數字時可以盡量最大或最小，才可以確保所有數字能有機會被包含進去\n          \n對每一個數字如果要找大於自己的，就一直繼續往上找直到最大，如果要找最小的也是一樣\n            以 5 1 2 4 5 3 6 來說，就是從5開始，接下來是1（最小了），接下來往上找，可以找到2, 4, 5，而為了盡量讓數字大才能包到接下來的數字（如果選2下一個就不能是3），所以選5，再來就是3 跟6 。所以序列為： 5 1 5 3 6 ， 長度為5\n          \n想說應該要AC 了，沒想到沒有memset 所以吃了一個WA ！\n\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    int n,arr[1000005];    while(t--)&#123;        cin&gt;&gt;n;        memset(arr,0,sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int height = 0, ind = 0, ans = 1;//0-&gt;down 1-&gt;up        while(ind&lt;n &amp;&amp; arr[ind]&lt;=arr[ind+1])ind++;                while(ind&lt;n)&#123;            if(height == 0 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&gt;=arr[ind+1])ind++;                height = 1;            &#125;            else if(height == 1 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&lt;=arr[ind+1])ind++;                height = 0;                ans+=2;            &#125;            ind++;//如果有連續相同數字需要加        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]TIOJ 1072 誰先晚餐 ","url":"/sprout5-3/","content":"誰先晚餐\n題目連結按照Greegy 的想法，吃最慢的人要最先吃，吃最快的人要後吃，才能讓整個時間盡量的縮短這一題之前學長講解過，所以自然是比較簡單。But! 要怎麼證明這樣可以得到最佳解呢～留到手寫作業！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct student&#123;    int eat,cook;&#125;people[10005];bool comp(student a,student b)&#123;    return a.eat &gt; b.eat;&#125;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;people[i].cook&gt;&gt;people[i].eat;        &#125;        sort(people, people+n, comp);        int ans = 0,cook = 0;        for(int i=0;i&lt;n;i++)&#123;            cook+=people[i].cook;//煮飯時間一定總數不會改變            int leave = cook+people[i].eat;            ans = max(ans, leave);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 78 包裝禮物","url":"/sprout5-4/","content":"包裝禮物\n題目連結一直吃WA ，吃到懷疑人生哎～想法：由大方塊到小方塊，盡量填滿，如果過程中大小為4的方塊變成負的，可以先欠著，直到最後一次由大小為1的來補，這樣可以確保每一格方塊不是被1*1的填滿就是剩下最少的空格\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int a,b,c,d,e,f;signed main()&#123;    ios;    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f)&#123;        if(a==0&amp;&amp;b==0&amp;&amp;c==0&amp;&amp;d==0&amp;&amp;e==0&amp;&amp;f==0)break;        int ans = f+e+d;        a = a - 11*e;//5*5可以用11個1*1填        b = b - 5*d;//一個4*4可以用5個2*2填        ans+=(c/4);        if(c%4!=0)ans++;        if(c%4==1)&#123;            a = a - 7;            b = b - 5;        &#125;        else if(c%4==2)&#123;            a = a - 6;            b = b - 3;        &#125;        else if(c%4==3)&#123;            a = a - 5;            b = b - 1;        &#125;        if(b&gt;0)&#123;            ans+=(b/9);            if(b%9!=0)ans++;            a = a-(36-4*(b%9));        &#125;        else if(b&lt;0)a = a-(4*(-b));//如果b有欠，可以用a來補        if(a&gt;0)&#123;            ans+=a/36;            if(a%36!=0)ans++;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 91 調校高棕櫚","url":"/sprout5-5/","content":"調校高棕櫚\n題目連結如果想要讓數字盡量小，那勢必要讓數字的位數盡量少因此可以先把3個2合併成8，2個3合併成9而剩下的2跟3可以有6 種組合：\n\n\n\n\n數字個數\n0個2\n1個2\n2個2\n\n\n\n\n0個3\n無\n2\n4\n\n\n1個3\n2\n6\n2,6\n\n\n\n\n先把數字做質因數分解，如果有質數大於10，就輸出-1接下來，再用這6種組合用if 排列組合就完成了\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[11]=&#123;0&#125;;cin&gt;&gt;n;        if(n==1)&#123;            cout&lt;&lt;1&lt;&lt;endl;            continue;        &#125;        int ind = 2;        while(ind&lt;=9)&#123;            if(n%ind==0)&#123;                n /= ind;                arr[ind]++;            &#125;            else ind++;        &#125;        if(n&gt;10)&#123;            cout&lt;&lt;-1&lt;&lt;endl;            continue;        &#125;        vector&lt;int&gt;vec;                for(int i=0;i&lt;arr[2]/3;i++)vec.push_back(8);        arr[2]=arr[2]%3;        for(int i=0;i&lt;arr[3]/2;i++)vec.push_back(9);        arr[3]=arr[3]%2;                if(arr[2]==1 &amp;&amp; arr[3]==0)vec.push_back(2);        if(arr[2]==2 &amp;&amp; arr[3]==0)vec.push_back(4);        if(arr[2]==0 &amp;&amp; arr[3]==1)vec.push_back(3);        if(arr[2]==1 &amp;&amp; arr[3]==1)vec.push_back(6);        if(arr[2]==2 &amp;&amp; arr[3]==1)&#123;            vec.push_back(2);            vec.push_back(6);        &#125;        for(int i=0;i&lt;arr[5];i++)vec.push_back(5);        for(int i=0;i&lt;arr[7];i++)vec.push_back(7);        sort(vec.begin(),vec.end());        for(auto i:vec)cout&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第五週：貪心算法","url":"/sprout5/","content":"這一週主題是Greedy，其實貪心法的題目要難可以到很難，有點像一個抽象的想法，需要透過反覆的實作與練習（顯然我缺乏），來更容易的想到題目的解法！\n上課內容影片的內容主要是在證明greedy 的正確性，超複雜的數學證明（又是數學證明！）原本以為上課會延續證明的內容，沒想到完全沒有講到證明的內容，都是在講解例題（也不錯，有很多題需要慢慢理解）所以列了上課講過的例題，一定要搞懂！\n\n絕對不要輕忽 Greedy 啊，想法看似單純，要想出解法，還是需要經驗的！\n上機作業Add all(UVA)題目連結這一題可以輕鬆觀察出規律：數字越早被相加，被加總的次數就會越多因此，維護一個priority_queue，每次pop出最小的兩個數字再push 回去，可以保證總和一定會是最小的\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    ios;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qq;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            qq.push(temp);        &#125;        int ans = 0;        while(qq.size()&gt;1)&#123;            int a,b;            a = qq.top();qq.pop();            b = qq.top();qq.pop();            qq.push(a+b);            ans+=(a+b);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;        qq.pop();    &#125;&#125;\n円円攻略黃河(TIOJ)題目連結這一題要求最長的長短相間的序列長度，雖然知道是Greedy ，但第一時間想不到具體的作法卡了有一點久，總共嘗試了三次，前兩次以為對，但WA 後還是發現其中的Bug\n\n從第一個數字開始，找到下一個比自己小的數字，再找比那一個大的，重複幾次直到結束\n            問題在於，第一個數字可能很小，導致接下來的序列長度很短\n          \n找到第一個「下一個數比自己小」的數字，接著重複第1點的步驟\n            因為要保證序列是最長的，會希望在找比自己大或小的數字時可以盡量最大或最小，才可以確保所有數字能有機會被包含進去\n          \n對每一個數字如果要找大於自己的，就一直繼續往上找直到最大，如果要找最小的也是一樣\n            以 5 1 2 4 5 3 6 來說，就是從5開始，接下來是1（最小了），接下來往上找，可以找到2, 4, 5，而為了盡量讓數字大才能包到接下來的數字（如果選2下一個就不能是3），所以選5，再來就是3 跟6 。所以序列為： 5 1 5 3 6 ， 長度為5\n          \n想說應該要AC 了，沒想到沒有memset 所以吃了一個WA ！\n\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    int n,arr[1000005];    while(t--)&#123;        cin&gt;&gt;n;        memset(arr,0,sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int height = 0, ind = 0, ans = 1;//0-&gt;down 1-&gt;up        while(ind&lt;n &amp;&amp; arr[ind]&lt;=arr[ind+1])ind++;                while(ind&lt;n)&#123;            if(height == 0 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&gt;=arr[ind+1])ind++;                height = 1;            &#125;            else if(height == 1 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&lt;=arr[ind+1])ind++;                height = 0;                ans+=2;            &#125;            ind++;//如果有連續相同數字需要加        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n誰先晚餐題目連結按照Greegy 的想法，吃最慢的人要最先吃，吃最快的人要後吃，才能讓整個時間盡量的縮短這一題之前學長講解過，所以自然是比較簡單。But! 要怎麼證明這樣可以得到最佳解呢～留到手寫作業！\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct student&#123;    int eat,cook;&#125;people[10005];bool comp(student a,student b)&#123;    return a.eat &gt; b.eat;&#125;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;people[i].cook&gt;&gt;people[i].eat;        &#125;        sort(people, people+n, comp);        int ans = 0,cook = 0;        for(int i=0;i&lt;n;i++)&#123;            cook+=people[i].cook;//煮飯時間一定總數不會改變            int leave = cook+people[i].eat;            ans = max(ans, leave);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n包裝禮物題目連結一直吃WA ，吃到懷疑人生哎～想法：由大方塊到小方塊，盡量填滿，如果過程中大小為4的方塊變成負的，可以先欠著，直到最後一次由大小為1的來補，這樣可以確保每一格方塊不是被1*1的填滿就是剩下最少的空格\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int a,b,c,d,e,f;signed main()&#123;    ios;    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f)&#123;        if(a==0&amp;&amp;b==0&amp;&amp;c==0&amp;&amp;d==0&amp;&amp;e==0&amp;&amp;f==0)break;        int ans = f+e+d;        a = a - 11*e;//5*5可以用11個1*1填        b = b - 5*d;//一個4*4可以用5個2*2填        ans+=(c/4);        if(c%4!=0)ans++;        if(c%4==1)&#123;            a = a - 7;            b = b - 5;        &#125;        else if(c%4==2)&#123;            a = a - 6;            b = b - 3;        &#125;        else if(c%4==3)&#123;            a = a - 5;            b = b - 1;        &#125;        if(b&gt;0)&#123;            ans+=(b/9);            if(b%9!=0)ans++;            a = a-(36-4*(b%9));        &#125;        else if(b&lt;0)a = a-(4*(-b));//如果b有欠，可以用a來補        if(a&gt;0)&#123;            ans+=a/36;            if(a%36!=0)ans++;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n調校高棕櫚題目連結如果想要讓數字盡量小，那勢必要讓數字的位數盡量少因此可以先把3個2合併成8，2個3合併成9而剩下的2跟3可以有6 種組合：\n\n\n\n\n數字個數\n0個2\n1個2\n2個2\n\n\n\n\n0個3\n無\n2\n4\n\n\n1個3\n2\n6\n2,6\n\n\n\n\n先把數字做質因數分解，如果有質數大於10，就輸出-1接下來，再用這6種組合用if 排列組合就完成了\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[11]=&#123;0&#125;;cin&gt;&gt;n;        if(n==1)&#123;            cout&lt;&lt;1&lt;&lt;endl;            continue;        &#125;        int ind = 2;        while(ind&lt;=9)&#123;            if(n%ind==0)&#123;                n /= ind;                arr[ind]++;            &#125;            else ind++;        &#125;        if(n&gt;10)&#123;            cout&lt;&lt;-1&lt;&lt;endl;            continue;        &#125;        vector&lt;int&gt;vec;                for(int i=0;i&lt;arr[2]/3;i++)vec.push_back(8);        arr[2]=arr[2]%3;        for(int i=0;i&lt;arr[3]/2;i++)vec.push_back(9);        arr[3]=arr[3]%2;                if(arr[2]==1 &amp;&amp; arr[3]==0)vec.push_back(2);        if(arr[2]==2 &amp;&amp; arr[3]==0)vec.push_back(4);        if(arr[2]==0 &amp;&amp; arr[3]==1)vec.push_back(3);        if(arr[2]==1 &amp;&amp; arr[3]==1)vec.push_back(6);        if(arr[2]==2 &amp;&amp; arr[3]==1)&#123;            vec.push_back(2);            vec.push_back(6);        &#125;        for(int i=0;i&lt;arr[5];i++)vec.push_back(5);        for(int i=0;i&lt;arr[7];i++)vec.push_back(7);        sort(vec.begin(),vec.end());        for(auto i:vec)cout&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\n手寫作業這一週手寫作業是greedy 正確性的證明，把覺得應該怎麼做的想法轉換成數學式子表達，才能讓我們安心的使用greedy ！蠻開心的，上一次以為分數會很低的手寫作業竟然拿到了100/110，就差一點就可以拿滿分了QQ\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","貪心"]},{"title":"[題解]NEOJ 789 好的序列","url":"/sprout6-2/","content":"好的序列\n題目連結題目簡單來說，就是給定n，要構造出一個1~n的序列，其中不包含3個數字以上的等差數列解題想法： 我看不懂資芽的解法QQ上網扣別人的扣，看幾乎都是同樣一個寫法，把奇數項的放前面，偶數項的放後面，之後不斷分治下去直接實作然後AC ，於是我一直想到底要怎麼證明這個方法是正確的於是我大概想到了一個上黑色白色的一個算合理的推倒吧\n            首先，我們把長度為$n$的序列分別交錯塗上黑白再來，把長度為$n$的序列畫一條線分成$[1,\\dfrac{n}{2}]$ 與$[\\dfrac{n}{2}+1,n]$兩個序列，把奇數次項的數字放入第一個序列，再把偶數次項的序列放入第二個我們可以發現，考慮橫跨中間線的兩邊是否有可能形成等差數列，可以發現是不可能，因為如果要橫跨兩邊，勢必要從一邊選出兩個，另一邊選一個，而同顏色的差為偶數，不同顏色的差必為奇數，因此不可能構造出橫跨兩邊的等差數列但可以明顯發現，同一顏色是等差數列，其實只要分兩邊分別遞迴下去就可以了，遞迴處理完就是解答遞迴直到長度為2時就可以return 了\n          \n程式碼：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 100005using namespace std;int ans = 0,n,arr[N],temp[N];void DC(int l,int r)&#123;    if(r-l&lt;=1)return;    int ind = l,mid = (l+r)/2;    for(int i=l;i&lt;=r;i++)temp[i] = arr[i];    for(int i=l;i&lt;=r;i+=2)arr[ind++] = temp[i];    for(int i=l+1;i&lt;=r;i+=2)arr[ind++] = temp[i];    DC(l, mid);    DC(mid+1, r);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)arr[i] = i;    DC(1, n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 124 王老先生有塊地喔","url":"/sprout6-3/","content":"王老先生有塊地喔\n題目連結這一題最需要關注的就是把問題縮小的關鍵大範圍不會做，把規模縮到$2\\times2$ 大小的方格總可以做了吧」想辦法讓每一個$2\\times2$ 大小的方格都有一格是被填滿的剩下三格就很容易放進去注意： 行跟列的維護很重要，一開始就要想好要怎麼樣定義儲存格，一維二維該放什麼\n#include &lt;bits/stdc++.h&gt;bool maze[1025][1025];void DC(int,int,int);void solve(int,int,int);void solve(int N,int X,int Y)&#123;    memset(maze, 0, sizeof(maze));    maze[X][Y] = 1;    DC(1,1,N);&#125;void DC(int x,int y,int n)&#123;    if(n&lt;=1)return;    int new_N = n/2,x_pos=0,y_pos=0;    for(int i=x;i&lt;x+n;i++)&#123;        for(int j=y;j&lt;y+n;j++)&#123;            if(maze[i][j] == 1)&#123;                x_pos = i;                y_pos = j;                break;            &#125;        &#125;    &#125;    int pos;    if(x_pos&gt;=x+new_N)&#123;        if(y_pos&gt;=y+new_N)pos = 4;        else pos = 3;    &#125;    else&#123;        if(y_pos&gt;=y+new_N)pos = 2;        else pos = 1;    &#125;    int nx = x+new_N,ny = y+new_N;    switch (pos) &#123;        case 1:            Report(nx, ny, nx-1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 2:            ny = ny-1;            Report(nx, ny, nx-1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny+1] = 1;            break;        case 3:            nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 4:            ny = ny-1;nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny+1] = 1;            break;        default:            break;    &#125;    DC(x, y, new_N);    DC(x+new_N, y, new_N);    DC(x, y+new_N, new_N);    DC(x+new_N, y+new_N, new_N);&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 128 糟糕陣列","url":"/sprout6-4/","content":"糟糕陣列\n題目連結其中一種構造方式：對於第i列第i行的「糟糕陣列」，必須滿足聯集為 ${1,2,…,2k-1}$的數字，我們可以先構造出2*2的糟糕陣列，把它複製到右邊（加上邊長）、右下、與下方（加上邊長，複製完之後因為會有重複一個數字，扣掉就好\n#include &lt;bits/stdc++.h&gt;using namespace std;int maze[1026][1026];void solve(int);void DC(int n);void solve(int N)&#123;    memset(maze, 0, sizeof(maze));    maze[1][1] = 1;    maze[1][2] = 2;    maze[2][1] = 3;    maze[2][2] = 1;    int temp = 4;    while(temp&lt;=N)&#123;        DC(temp);        temp = temp*2;    &#125;    for(int i=1;i&lt;=N;i++)&#123;        for(int j=1;j&lt;=N;j++)&#123;            Report(maze[i][j]);        &#125;    &#125;&#125;void DC(int n)&#123;    int now_N = n/2;    for(int i=1;i&lt;=now_N;i++)&#123;        for(int j=1;j&lt;=now_N;j++)&#123;            maze[i+now_N][j] = maze[i][j]+n;            maze[i][j+now_N] = maze[i][j]+n;            maze[i+now_N][j+now_N] = maze[i][j];            if(maze[i][j]==1)maze[i][j+now_N]--;        &#125;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 125 逆序數對","url":"/sprout6-1/","content":"逆序數對\n題目連結這是要求逆序數對的兩個數字的和，總共卡了兩個地方：\n\nTLE 計算和的複雜度爆了\nWA 數字溢位後爆了\n\n第一點的解決方式：對於每一層利用O(N)的時間算前墜和第二點的解決方式：每做完一個運算就mod 一次\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int ans = 0,n,arr[N],pre[N];void merge_sort(int l,int r)&#123;    if(r-l&lt;=1)return;    int mid = (l+r)/2;    merge_sort(l,mid);    merge_sort(mid,r);        int nl = l,nr = mid,ind = 0,temp[r-l];    pre[l-1] = 0;    for(int i=l;i&lt;=mid;++i)pre[i] = pre[i-1]+arr[i];    for(;nl&lt;mid;nl++,ind++)&#123;        while(arr[nr]&lt;arr[nl] &amp;&amp; nr&lt;r)&#123;            int times = mid-nl;//逆序數對的數量            ans+=pre[mid-1]-pre[nl-1];            ans+=arr[nr]*times;            ans = ans%10000019;            temp[ind] = arr[nr];            nr++;ind++;        &#125;        temp[ind] = arr[nl];    &#125;    while(nr&lt;r)&#123;//把剩下沒放的放進去        temp[ind] = arr[nr];        nr++;ind++;    &#125;    for(int i=0;i&lt;r-l;++i)arr[i+l] = temp[i];&#125;signed main()&#123;    cin&gt;&gt;n;    memset(arr, 0, sizeof(arr));    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;arr[i]);    merge_sort(1,n+1);    printf(&quot;%lld\\n&quot;,ans%10000019);&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第六週：分治算法","url":"/sprout6/","content":"上課內容分治法，一開始講了三個證明遞迴複雜度的方法：\n\n取代法：三步驟：Guess, Verify, Solve靠經驗假設，並驗證（加一些常數之類的）\n遞迴樹法不太嚴謹，提供猜答案想法，最後用取代法驗證畫出遞迴樹\n主定理（Master Theorem）比較f(n) 和 n^(logba)的關係大於等於小於有三個複雜度\n\n\n還有例題：\n\n區間連續最大和https://zerojudge.tw/ShowProblem?problemid=d784中間切一半，max(左右最大值,跨過中間的最大值)時間複雜度：O(NlogN)有辦法O(n)?\n多項式乘法Tioj 1064FFT? （快速點的乘法）Karatsuba algorithm，複雜度O(N^1.58)，還可以用在矩陣乘法\n平面最近點對 cf429D，Tioj平面分治演算法很多都這樣做，先照x座標排序，中間切割：max(兩點都在左邊、兩點都在右邊、跨過分割線答案)求跨過分割線答案：照y座標排序，距離超過d的不要看，因為附近的點是有限個（最近點距離d），大概最多只需要看7個點，可以在常數時間看完所有點\n尋找第k大 O(N)尋找第k大-利用分治\n\n上機作業逆序數對題目連結這是要求逆序數對的兩個數字的和，總共卡了兩個地方：\n\nTLE 計算和的複雜度爆了\nWA 數字溢位後爆了\n\n第一點的解決方式：對於每一層利用O(N)的時間算前墜和第二點的解決方式：每做完一個運算就mod 一次\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int ans = 0,n,arr[N],pre[N];void merge_sort(int l,int r)&#123;    if(r-l&lt;=1)return;    int mid = (l+r)/2;    merge_sort(l,mid);    merge_sort(mid,r);        int nl = l,nr = mid,ind = 0,temp[r-l];    pre[l-1] = 0;    for(int i=l;i&lt;=mid;++i)pre[i] = pre[i-1]+arr[i];    for(;nl&lt;mid;nl++,ind++)&#123;        while(arr[nr]&lt;arr[nl] &amp;&amp; nr&lt;r)&#123;            int times = mid-nl;//逆序數對的數量            ans+=pre[mid-1]-pre[nl-1];            ans+=arr[nr]*times;            ans = ans%10000019;            temp[ind] = arr[nr];            nr++;ind++;        &#125;        temp[ind] = arr[nl];    &#125;    while(nr&lt;r)&#123;//把剩下沒放的放進去        temp[ind] = arr[nr];        nr++;ind++;    &#125;    for(int i=0;i&lt;r-l;++i)arr[i+l] = temp[i];&#125;signed main()&#123;    cin&gt;&gt;n;    memset(arr, 0, sizeof(arr));    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;arr[i]);    merge_sort(1,n+1);    printf(&quot;%lld\\n&quot;,ans%10000019);&#125;\n好的序列題目連結題目簡單來說，就是給定n，要構造出一個1~n的序列，其中不包含3個數字以上的等差數列解題想法： 我看不懂資芽的解法QQ上網扣別人的扣，看幾乎都是同樣一個寫法，把奇數項的放前面，偶數項的放後面，之後不斷分治下去直接實作然後AC ，於是我一直想到底要怎麼證明這個方法是正確的於是我大概想到了一個上黑色白色的一個算合理的推倒吧\n            首先，我們把長度為$n$的序列分別交錯塗上黑白再來，把長度為$n$的序列畫一條線分成$[1,\\dfrac{n}{2}]$ 與$[\\dfrac{n}{2}+1,n]$兩個序列，把奇數次項的數字放入第一個序列，再把偶數次項的序列放入第二個我們可以發現，考慮橫跨中間線的兩邊是否有可能形成等差數列，可以發現是不可能，因為如果要橫跨兩邊，勢必要從一邊選出兩個，另一邊選一個，而同顏色的差為偶數，不同顏色的差必為奇數，因此不可能構造出橫跨兩邊的等差數列但可以明顯發現，同一顏色是等差數列，其實只要分兩邊分別遞迴下去就可以了，遞迴處理完就是解答遞迴直到長度為2時就可以return 了\n          \n程式碼：\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 100005using namespace std;int ans = 0,n,arr[N],temp[N];void DC(int l,int r)&#123;    if(r-l&lt;=1)return;    int ind = l,mid = (l+r)/2;    for(int i=l;i&lt;=r;i++)temp[i] = arr[i];    for(int i=l;i&lt;=r;i+=2)arr[ind++] = temp[i];    for(int i=l+1;i&lt;=r;i+=2)arr[ind++] = temp[i];    DC(l, mid);    DC(mid+1, r);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)arr[i] = i;    DC(1, n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\n王老先生有塊地喔題目連結這一題最需要關注的就是把問題縮小的關鍵大範圍不會做，把規模縮到$2\\times2$ 大小的方格總可以做了吧」想辦法讓每一個$2\\times2$ 大小的方格都有一格是被填滿的剩下三格就很容易放進去注意： 行跟列的維護很重要，一開始就要想好要怎麼樣定義儲存格，一維二維該放什麼\n#include &lt;bits/stdc++.h&gt;bool maze[1025][1025];void DC(int,int,int);void solve(int,int,int);void solve(int N,int X,int Y)&#123;    memset(maze, 0, sizeof(maze));    maze[X][Y] = 1;    DC(1,1,N);&#125;void DC(int x,int y,int n)&#123;    if(n&lt;=1)return;    int new_N = n/2,x_pos=0,y_pos=0;    for(int i=x;i&lt;x+n;i++)&#123;        for(int j=y;j&lt;y+n;j++)&#123;            if(maze[i][j] == 1)&#123;                x_pos = i;                y_pos = j;                break;            &#125;        &#125;    &#125;    int pos;    if(x_pos&gt;=x+new_N)&#123;        if(y_pos&gt;=y+new_N)pos = 4;        else pos = 3;    &#125;    else&#123;        if(y_pos&gt;=y+new_N)pos = 2;        else pos = 1;    &#125;    int nx = x+new_N,ny = y+new_N;    switch (pos) &#123;        case 1:            Report(nx, ny, nx-1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 2:            ny = ny-1;            Report(nx, ny, nx-1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny+1] = 1;            break;        case 3:            nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 4:            ny = ny-1;nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny+1] = 1;            break;        default:            break;    &#125;    DC(x, y, new_N);    DC(x+new_N, y, new_N);    DC(x, y+new_N, new_N);    DC(x+new_N, y+new_N, new_N);&#125;\n糟糕陣列題目連結其中一種構造方式：對於第i列第i行的「糟糕陣列」，必須滿足聯集為 ${1,2,…,2k-1}$的數字，我們可以先構造出2*2的糟糕陣列，把它複製到右邊（加上邊長）、右下、與下方（加上邊長，複製完之後因為會有重複一個數字，扣掉就好\n#include &lt;bits/stdc++.h&gt;using namespace std;int maze[1026][1026];void solve(int);void DC(int n);void solve(int N)&#123;    memset(maze, 0, sizeof(maze));    maze[1][1] = 1;    maze[1][2] = 2;    maze[2][1] = 3;    maze[2][2] = 1;    int temp = 4;    while(temp&lt;=N)&#123;        DC(temp);        temp = temp*2;    &#125;    for(int i=1;i&lt;=N;i++)&#123;        for(int j=1;j&lt;=N;j++)&#123;            Report(maze[i][j]);        &#125;    &#125;&#125;void DC(int n)&#123;    int now_N = n/2;    for(int i=1;i&lt;=now_N;i++)&#123;        for(int j=1;j&lt;=now_N;j++)&#123;            maze[i+now_N][j] = maze[i][j]+n;            maze[i][j+now_N] = maze[i][j]+n;            maze[i+now_N][j+now_N] = maze[i][j];            if(maze[i][j]==1)maze[i][j+now_N]--;        &#125;    &#125;&#125;\n手寫作業增倍算法！主要是介紹動態陣列，分析複雜度等等的東西上一週的手寫作業被扣爆！\n","categories":["資訊之芽筆記"],"tags":["資芽筆記","分治"]},{"title":"[題解]NEOJ 138 円円數磁磚","url":"/sprout7-1/","content":"円円數磁磚\n題目連結我不會寫轉移式子啊…首先可以觀察到，因為兩個磁磚的排法有3種，首先可以列出$f(n) = 3\\times f(n-2)$ 這個式子，但觀察之後可以發現，如果排列的磁磚不能被兩兩分割，也可是一種新的排法。而對於固定的尺寸大小只會有一種排法，但因為可以顛倒放，因此視為兩種組合。轉移式：$f(n) = 3\\times f(n-2)+2\\times(f(n-4)+f(n-6)…)$經過數學帶入消去：$f(n-2) = 3\\times f(n-4)+2\\times(f(n-6)+f(n-8)…)$$f(n) = 4\\times f(n-2)-f(n-4)$\n邊界：$dp[0] = 1, dp[2] = 3$\n#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    int dp[100005];    memset(dp, 0, sizeof(dp));    dp[0] = 1;dp[2] = 3;dp[3] = 0;    for(int i=4;i&lt;=100001;i+=2)dp[i] =(4*dp[i-2]-dp[i-4]+1000007)%1000007;    while(t--)&#123;        int n;cin&gt;&gt;n;        cout&lt;&lt;dp[n]&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 140 円円送禮物","url":"/sprout7-2/","content":"円円送禮物\n題目連結以後寫DP幾種組合問題就是像這一題一樣暴力破解把每一種情況都寫清楚，不惜開三維陣列也沒關係總之，$dp[i][k][j]$ 代表長度為i，左邊為顏色k，右邊為顏色j（紅色：0、綠色：1、藍色：2）列出每一種狀態的轉移式就好不過，即使頭尾是一藍一綠，但也必須轉移，因為一藍一綠可以在頭或尾加上其他顏色，組成合法解，不過不要輸出就好了\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int t;signed main()&#123;    ios;    int dp[100005][3][3];//0:red,1:green,2:blue    dp[1][0][0] = 1;dp[1][1][1] = 1;dp[1][2][2] = 1;    dp[2][0][0] = dp[2][0][1] = dp[2][0][2] = 1;    dp[2][1][0] = dp[2][1][1] = dp[2][2][0] = dp[2][2][2] = 1;    dp[2][1][2] = dp[2][2][1] = 0;    for(int i=3;i&lt;100005;i++)&#123;        dp[i][0][0] = (dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2])%1000007;        dp[i][0][1] = (dp[i-1][0][0]+dp[i-1][0][1])%1000007;        dp[i][0][2] = (dp[i-1][0][0]+dp[i-1][0][2])%1000007;                dp[i][1][0] = (dp[i-1][1][0]+dp[i-1][1][1]+dp[i-1][1][2])%1000007;        dp[i][1][1] = (dp[i-1][1][0]+dp[i-1][1][1])%1000007;        dp[i][1][2] = (dp[i-1][1][0]+dp[i-1][1][2])%1000007;                dp[i][2][0] = (dp[i-1][2][0]+dp[i-1][2][1]+dp[i-1][2][2])%1000007;        dp[i][2][1] = (dp[i-1][2][0]+dp[i-1][2][1])%1000007;        dp[i][2][2] = (dp[i-1][2][0]+dp[i-1][2][2])%1000007;            &#125;    int n;cin&gt;&gt;n;    while(n--)&#123;        int a;cin&gt;&gt;a;        cout&lt;&lt;(dp[a][0][0]+dp[a][0][1]+dp[a][0][2]+dp[a][1][0]+dp[a][1][1]+dp[a][2][0]+dp[a][2][2])%1000007&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 142 取數字2","url":"/sprout7-4/","content":"取數字2\n題目連結上面取數字1的進階版，可以一樣定義，不過轉移式要稍微改變（其實就只是把原本只有2的區間擴大成k）定義：$dp[i]$ 為取第i個數字的的最大值轉移式：$dp[i]=max(arr[j]+arr[i]),2k\\leq i \\leq n,i-2k\\leq j \\leq i-k$轉移式比較複雜一點，不過就是取數字1的延伸邊界：$dp[i] = arr[i],1\\leq i \\leq k$$dp[i]=max(arr[j]+arr[i]),k+1\\leq i \\leq 2k,1\\leq j \\leq i-k$\n邊界的話，如果要說成是轉移式也是可以啦\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005],k;cin&gt;&gt;n&gt;&gt;k;        int dp[100005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        //[1,k]的邊界轉移        for(int i=1;i&lt;=k;i++)dp[i] = arr[i];        //[k+1,2k]的邊界轉移        for(int i=k+1;i&lt;=2*k;i++)&#123;            for(int j=1;j&lt;=i-k;j++)&#123;//看可以配上[1,k]最大的那一個                dp[i]=max(dp[i],arr[j]+arr[i]);            &#125;        &#125;        for(int i=2*k+1;i&lt;=n;i++)&#123;            for(int j = i-2*k;j&lt;=i-k;j++)&#123;//開始轉移，掃描k次                dp[i] = max(dp[i],dp[j]+arr[i]);            &#125;        &#125;        cout&lt;&lt;max_element(dp, dp+n+1)&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 143 合成円円","url":"/sprout7-5/","content":"合成円円\n題目連結開始接觸到區間DP，比單純的DP又多了一些要注意的地方上網查關於區間DP的資料，一般都會有這些內容：\nfor (枚舉區間長度)    for (枚舉左端點)        for (枚舉分割點)            f[l, r] = f[l, k] + f[k, r] + val(l, r)\n主要就是，從小的區間長度開始（大的區間需要小的區間的答案），枚舉左端點可以知道區間的範圍，接著再依序枚舉在區間內分割點，把長度為n的區間長度跑完之後就完成了有了這一個$O(n^3)$ 的演算法，就可以開始來實作\n定義：$dp[i][j]$ $(1 \\leq i,j \\leq n)$ 為合併區間 $[i,j]$ 所需要的花費轉移式：$dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum_{i,j}),i \\leq k \\leq j$合併區間$dp[i][k],dp[k+1][j]$的花費為兩者相加再加上區間[i,j]的總和（可以用前綴維護）邊界：$dp[i][i] = 0,1 \\leq i \\leq n$\n這個演算法的複雜度是$O(n^3)$，之後可以用dp優化的技巧做到更快\n\n            問題：這題可不可以用Greedy？我們如果每一次都找兩兩相鄰相加總和最小的兩個加起來，做n-1次，是不是可以找到最佳解？（如果可以，那幹嘛還要辛苦維護$n^3$的算法XD）Q:答案是不行，那要反例何時出現？10 7 6 7這一組測資如果用Greedy做是63，用dp做是60，可以發現到，如果數字兩兩相加相等，那先加後加的順序就很重要，有可能因為順序不對（先加中間的7跟6），導致7沒辦法跟10合併產生更加的解法！找反例的方法： 這一筆測資是利用隨機生成大量的數字去找出有沒有不一樣，方法by:\n          \n這一題就先這樣，不過區間DP感覺就是可以很難的東西時間複雜度$O(n^3)$\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[105],pre[105];cin&gt;&gt;n;        int dp[105][105];        memset(pre, 0, sizeof(pre));        memset(dp, 0x3f3f3f3f, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            cin&gt;&gt;arr[i];            pre[i] = pre[i-1]+arr[i];            dp[i][i] = 0;        &#125;                for(int len = 2;len&lt;=n;len++)&#123;            for(int i=1;i+len-1&lt;=n;i++)&#123;//區間[i,j]長度為len，則j = i+len-1                int j = i+len-1;                for(int k=i;k&lt;=j;k++)&#123;                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 141 取數字1","url":"/sprout7-3/","content":"取數字1\n題目連結定義：$dp[i]$ 為取第i個數字的的最大值轉移式：$dp[i] = max(dp[i-2]+dp[i-2])+arr[i]$可以發現到，因為$arr[i]$ 都是正數，因此加越多數字就代表最後的數值越大，而相鄰的兩項不能轉移，因此就要看$dp[i-2],dp[i-2]$其中i-4不用看是因為已經包含在i-2裡面了邊界：$dp[1] = arr[1],dp[2] = arr[2],dp[3] = arr[1]+arr[3]$\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        int dp[10005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        dp[1] = arr[1];dp[2] = arr[2];dp[3] = arr[1]+arr[3];        for(int i=4;i&lt;=n+1;i++)&#123;            dp[i] = max(dp[i-2],dp[i-3])+arr[i];        &#125;        cout&lt;&lt;max(dp[n],dp[n-1])&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第七週：動態規劃（一）","url":"/sprout7/","content":"上課內容\n使用DP時機：\n\n最優解問題\n計數問題\n重複子問題\n\n\nDP 使用過程\n\n定義狀態\n狀態轉移\n找到一個會AC的作法，再慢慢優化\n\n\n\n\n\n使用注意事項：\n\n寫好時間複雜度\n用「拉」的\n用「推」的\n盡量使用由下而上\n\n\nDP例題\n\n跑步問題（zj b589）\n最大連續和\n最大不連續和（npsc 2017）\nChest of Drawers (UVA 11420)\n最大和矩陣問題\n矩陣最大方形\n矩陣乘法問題\n消消樂（UVA 10559 Blocks）\n\n\n\n上機作業円円數磁磚題目連結我不會寫轉移式子啊…首先可以觀察到，因為兩個磁磚的排法有3種，首先可以列出$f(n) = 3\\times f(n-2)$ 這個式子，但觀察之後可以發現，如果排列的磁磚不能被兩兩分割，也可是一種新的排法。而對於固定的尺寸大小只會有一種排法，但因為可以顛倒放，因此視為兩種組合。轉移式：$f(n) = 3\\times f(n-2)+2\\times(f(n-4)+f(n-6)…)$經過數學帶入消去：$f(n-2) = 3\\times f(n-4)+2\\times(f(n-6)+f(n-8)…)$$f(n) = 4\\times f(n-2)-f(n-4)$\n邊界：$dp[0] = 1, dp[2] = 3$\n#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    int dp[100005];    memset(dp, 0, sizeof(dp));    dp[0] = 1;dp[2] = 3;dp[3] = 0;    for(int i=4;i&lt;=100001;i+=2)dp[i] =(4*dp[i-2]-dp[i-4]+1000007)%1000007;    while(t--)&#123;        int n;cin&gt;&gt;n;        cout&lt;&lt;dp[n]&lt;&lt;endl;    &#125;&#125;\n円円送禮物題目連結以後寫DP幾種組合問題就是像這一題一樣暴力破解把每一種情況都寫清楚，不惜開三維陣列也沒關係總之，$dp[i][k][j]$ 代表長度為i，左邊為顏色k，右邊為顏色j（紅色：0、綠色：1、藍色：2）列出每一種狀態的轉移式就好不過，即使頭尾是一藍一綠，但也必須轉移，因為一藍一綠可以在頭或尾加上其他顏色，組成合法解，不過不要輸出就好了\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int t;signed main()&#123;    ios;    int dp[100005][3][3];//0:red,1:green,2:blue    dp[1][0][0] = 1;dp[1][1][1] = 1;dp[1][2][2] = 1;    dp[2][0][0] = dp[2][0][1] = dp[2][0][2] = 1;    dp[2][1][0] = dp[2][1][1] = dp[2][2][0] = dp[2][2][2] = 1;    dp[2][1][2] = dp[2][2][1] = 0;    for(int i=3;i&lt;100005;i++)&#123;        dp[i][0][0] = (dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2])%1000007;        dp[i][0][1] = (dp[i-1][0][0]+dp[i-1][0][1])%1000007;        dp[i][0][2] = (dp[i-1][0][0]+dp[i-1][0][2])%1000007;                dp[i][1][0] = (dp[i-1][1][0]+dp[i-1][1][1]+dp[i-1][1][2])%1000007;        dp[i][1][1] = (dp[i-1][1][0]+dp[i-1][1][1])%1000007;        dp[i][1][2] = (dp[i-1][1][0]+dp[i-1][1][2])%1000007;                dp[i][2][0] = (dp[i-1][2][0]+dp[i-1][2][1]+dp[i-1][2][2])%1000007;        dp[i][2][1] = (dp[i-1][2][0]+dp[i-1][2][1])%1000007;        dp[i][2][2] = (dp[i-1][2][0]+dp[i-1][2][2])%1000007;            &#125;    int n;cin&gt;&gt;n;    while(n--)&#123;        int a;cin&gt;&gt;a;        cout&lt;&lt;(dp[a][0][0]+dp[a][0][1]+dp[a][0][2]+dp[a][1][0]+dp[a][1][1]+dp[a][2][0]+dp[a][2][2])%1000007&lt;&lt;endl;    &#125;&#125;\n取數字1題目連結定義：$dp[i]$ 為取第i個數字的的最大值轉移式：$dp[i] = max(dp[i-2]+dp[i-2])+arr[i]$可以發現到，因為$arr[i]$ 都是正數，因此加越多數字就代表最後的數值越大，而相鄰的兩項不能轉移，因此就要看$dp[i-2],dp[i-2]$其中i-4不用看是因為已經包含在i-2裡面了邊界：$dp[1] = arr[1],dp[2] = arr[2],dp[3] = arr[1]+arr[3]$\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        int dp[10005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        dp[1] = arr[1];dp[2] = arr[2];dp[3] = arr[1]+arr[3];        for(int i=4;i&lt;=n+1;i++)&#123;            dp[i] = max(dp[i-2],dp[i-3])+arr[i];        &#125;        cout&lt;&lt;max(dp[n],dp[n-1])&lt;&lt;endl;    &#125;&#125;\n取數字2題目連結上面取數字1的進階版，可以一樣定義，不過轉移式要稍微改變（其實就只是把原本只有2的區間擴大成k）定義：$dp[i]$ 為取第i個數字的的最大值轉移式：$dp[i]=max(arr[j]+arr[i]),2k\\leq i \\leq n,i-2k\\leq j \\leq i-k$轉移式比較複雜一點，不過就是取數字1的延伸邊界：$dp[i] = arr[i],1\\leq i \\leq k$$dp[i]=max(arr[j]+arr[i]),k+1\\leq i \\leq 2k,1\\leq j \\leq i-k$\n邊界的話，如果要說成是轉移式也是可以啦\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005],k;cin&gt;&gt;n&gt;&gt;k;        int dp[100005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        //[1,k]的邊界轉移        for(int i=1;i&lt;=k;i++)dp[i] = arr[i];        //[k+1,2k]的邊界轉移        for(int i=k+1;i&lt;=2*k;i++)&#123;            for(int j=1;j&lt;=i-k;j++)&#123;//看可以配上[1,k]最大的那一個                dp[i]=max(dp[i],arr[j]+arr[i]);            &#125;        &#125;        for(int i=2*k+1;i&lt;=n;i++)&#123;            for(int j = i-2*k;j&lt;=i-k;j++)&#123;//開始轉移，掃描k次                dp[i] = max(dp[i],dp[j]+arr[i]);            &#125;        &#125;        cout&lt;&lt;max_element(dp, dp+n+1)&lt;&lt;endl;    &#125;&#125;\n合成円円題目連結開始接觸到區間DP，比單純的DP又多了一些要注意的地方上網查關於區間DP的資料，一般都會有這些內容：\nfor (枚舉區間長度)    for (枚舉左端點)        for (枚舉分割點)            f[l, r] = f[l, k] + f[k, r] + val(l, r)\n主要就是，從小的區間長度開始（大的區間需要小的區間的答案），枚舉左端點可以知道區間的範圍，接著再依序枚舉在區間內分割點，把長度為n的區間長度跑完之後就完成了有了這一個$O(n^3)$ 的演算法，就可以開始來實作\n定義：$dp[i][j]$ $(1 \\leq i,j \\leq n)$ 為合併區間 $[i,j]$ 所需要的花費轉移式：$dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum_{i,j}),i \\leq k \\leq j$合併區間$dp[i][k],dp[k+1][j]$的花費為兩者相加再加上區間[i,j]的總和（可以用前綴維護）邊界：$dp[i][i] = 0,1 \\leq i \\leq n$\n這個演算法的複雜度是$O(n^3)$，之後可以用dp優化的技巧做到更快\n\n            問題：這題可不可以用Greedy？我們如果每一次都找兩兩相鄰相加總和最小的兩個加起來，做n-1次，是不是可以找到最佳解？（如果可以，那幹嘛還要辛苦維護$n^3$的算法XD）Q:答案是不行，那要反例何時出現？10 7 6 7這一組測資如果用Greedy做是63，用dp做是60，可以發現到，如果數字兩兩相加相等，那先加後加的順序就很重要，有可能因為順序不對（先加中間的7跟6），導致7沒辦法跟10合併產生更加的解法！找反例的方法： 這一筆測資是利用隨機生成大量的數字去找出有沒有不一樣，方法by:\n          \n這一題就先這樣，不過區間DP感覺就是可以很難的東西時間複雜度$O(n^3)$\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[105],pre[105];cin&gt;&gt;n;        int dp[105][105];        memset(pre, 0, sizeof(pre));        memset(dp, 0x3f3f3f3f, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            cin&gt;&gt;arr[i];            pre[i] = pre[i-1]+arr[i];            dp[i][i] = 0;        &#125;                for(int len = 2;len&lt;=n;len++)&#123;            for(int i=1;i+len-1&lt;=n;i++)&#123;//區間[i,j]長度為len，則j = i+len-1                int j = i+len-1;                for(int k=i;k&lt;=j;k++)&#123;                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;    &#125;&#125;\n手寫作業這一週沒有手寫！因為下禮拜是第一階段認證考\n","categories":["資訊之芽筆記"],"tags":["動態規劃","DP","資芽筆記"]},{"title":"[題解]NEOJ 157 高棕櫚農場","url":"/sprout8-1/","content":"高棕櫚農場\n題目連結這一題不能用重量做，因為重量的範圍可以到$10^5$，因此只能用價值來做有一個要點，無限大可以memset定義為0x3f3f3f3f，以十進位表示1061109567，在int的範圍但不會超過\n定義定義$f(n,m)$為取n樣物品,價值恰為m,重量總和最小值\n轉移方式$f(n,m) = min(f(n-1,m), f(n-1,m-v_n)+w_n), m ≧ v_n$$f(n,m) = f(n-1,m), m &lt; v_n$\n邊界條件f(0,0) = 0, f(0,k) = INF (k&gt;0)$因為取零樣物品價值要k不可能達到，因此重量設為無限大\n我們可以藉由滾動dp來節省空間，壓成一維（跟用重量作為狀態一樣）最後，在從dp裡面取出max(k), for all f(N,k) ≦ W\n程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,val[105],weight[100005];cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[100005];        //定義f(n,m)取n樣物品,價值為m,重量總和最小        //dp[i]：價值為i時,重量最小為dp[i]        memset(dp,INF,sizeof(dp));        dp[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=10000;j&gt;=val[i];j--)&#123;                dp[j] = min(dp[j],dp[j-val[i]]+weight[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;=10000;i++)            if(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 158 高棕櫚農場2","url":"/sprout8-2/","content":"高棕櫚農場2\n題目連結有些細節是必須要注意的，也就是初始化的細節。\n            背包問題是否恰好裝滿對於原本初始化dp[0] = 0，代表對於重量限制為0的背包價值最高為0接下來有兩種情況需要討論，第一種是重量限制為w的背包最多的價值1. 恰好裝滿此時必須初始化dp[i] = -INF，是因為要恰好裝滿的關係，初始化的dp 數組事實上就是在沒有任何物品可以放入背包時的合法狀態，其他除了0之外容量的背包均沒有合法的解，屬於未定義的狀態，所以都應該被賦值為 −∞ 。當前的合法解，一定是從之前的合法狀態推得的(−∞跟−∞取max還是−∞)2. 不需恰好裝滿如果背包並非必須被裝滿，那麼任何容量的背包都有一個合法解“什麼也不裝”，這個解的價值為0,所以初始化時狀態的值也就全部為0了。如果來看轉移式，$dp[j] = max(dp[j],dp[j-weight[i]]+val[i])$，如果兩者的狀態都屬於未定義，對於需恰好裝滿的狀況，兩者都是−∞，表示沒有合法的狀態可以構成此重量。同時，如果不需恰好裝滿的情況，即使$dp[j]$和$dp[j-weight[i]]$都未定義(等於0)，還是可以被更新（在沒有裝滿的情況下，dp[j] = val[i]）\n          這一題除了以上發現，還有一個很重要的東西，就是迴圈到底要放哪一層的問題。主要是卡在 for(int p=1;p&lt;=k;p++)到底要放在哪一層的問題，結果是要放在第三層。\n            問題一：dp[j][p]取決於dp[j][p] 和dp[j-weight[i]][p-1]，而且對於一個物品最多只能放一次，如果放在第二層，dp[j-weight[i]][p-1] 就已經被更新過了，有可能已經取了第 i 樣物品會有重複取的問題，如果放在第三層，代表對每一種不同的重量先更新放入幾樣物品的1到k，再更新重量，這樣就可以保證dp[j][p]不會取到已經更新的格子（dp[j][p] 沒被更新、dp[j-weight[i]][p-1] 其中第一維的j-weight[i] 也還沒被更新）問題二：p要從1到k還是k到1，這其實都可以，因為要取的格子不管從前往後或後往前取都只會取到上一輪(i-1) 的更新東西，因此不影響。還有，因為是定義最多取p樣物品，所以無論i為多少，每一次p皆要更新的k（如果k=5，取一樣物品也符合情況）\n          \n定義定義$f(j,p)$看完 i 樣物品後，重量限制為j，最多取p樣物品的最大價值\n轉移方式$dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i])$\n邊界條件$dp[i][j] = 0$ (for all elements in dp)\n#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,k,val[105],weight[10005];cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[1005][105];        memset(dp, 0, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            for(int j=m;j&gt;=weight[i];j--)&#123;                for(int p=1;p&lt;=k;p++)&#123;                    dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[m][k]&lt;&lt;endl;    &#125;&#125;/* 0 4 5 6 6 6 0 4 5 6 9 10 0 4 5 6 9 10*/\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 416 玩電梯","url":"/sprout8-3/","content":"玩電梯\n題目連結題目連結2\n這一題要用到3個重要的技巧：前綴和、差分、滾動dp差分在某一次手寫作業有寫到，不過那時候沒有很注意這個部分就是了\n            差分差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：b_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：定義一個新的陣列 $b_i$ 表示每一項差分設 $bl = b_l+v$，$b{r+1} = b_{r+1}-v$將差分的每一項加上前一項，即為原數列 $bi = b{i-1}+b_i$第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了O(1)了！\n          \n這一題使用到差分的技巧，讓原本的$O(kn^2)$減少成$O(kn)$，然後就可以過了！\n定義定義 $dp[i][j]$ 為第 i 次走到樓層j的方法數\n轉移式這題如果用拉的比較不好想，所以改用推的試試看$dp[i+1][j] = dp[i+1][j]+dp[i][p],$ for $j\\in[p-r],[p+1,p+r],r = |p-b|-1$\n邊界條件$dp[0][a] = 1$\n轉移式比較複雜一點，不過可以用差分優化搭配前綴和把原本$O(n)$的時間降到$O(1)$從這一題可以發現到，用拉的和用推的有不同的使用時機，可以以思考方式比較清楚的想法去想轉移式。\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define ios ios::sync_with_stdio(0)using namespace std;int n,a,b,k,dp[2][2005];int modify(int x)&#123;    return (x%mod+mod)%mod;&#125;void sec(int l,int r,int v,int id)&#123;     l = max(l,(long long)1);    r = min(r,n);    dp[(id+1)%2][l] = modify(dp[(id+1)%2][l]+v);    dp[(id+1)%2][r+1] = modify(dp[(id+1)%2][r+1]-v);&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k;    memset(dp,0,sizeof(dp));    dp[0][a] = 1;    for(int s=0;s&lt;k;s++)&#123;  //每一次電梯移動        for(int i=1;i&lt;=n;i++)&#123; //每一樓層轉移            int d = abs(b-i)-1;            sec(i-d,i-1,dp[s%2][i],s);            sec(i+1,i+d,dp[s%2][i],s);        &#125;        for(int i=1;i&lt;=n;i++)&#123;            dp[(s+1)%2][i] += dp[(s+1)%2][i-1];            dp[(s+1)%2][i] = modify(dp[(s+1)%2][i]);        &#125;        for(int i=1;i&lt;=n;i++)dp[(s)%2][i] = 0;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=dp[k%2][i];        ans = modify(ans);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;//8樓、2樓開始、5樓不能去、2次電梯\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 421 取名字好困難QQ","url":"/sprout8-4/","content":"取名字好困難QQ\n題目連結跟題目一樣，我覺得要通靈才能想到這一題的作法！結果是問了別人才大概感受到這一種作法！！！\n我們既然不知道到底一個數字要不要乘2，我們可以透過做LIS的過程來做決定。當我們把乘與2之後的數字跟原本數字一起push進去，就可以發現到LIS不可能同時取到2個數字。利用這個方法就可以用LIS的過程決定一個數字到底應該要變2倍還是不用。要找到最長的非嚴格遞增序列，最大的差別就是要把原本的lower_bound改成upper_bound。一整天想一題的感覺超級糟糕QQ\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    vector&lt;int&gt;vec;    FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        if(2*temp&lt;m)continue;        else if(temp&lt;m)&#123;            temp*=2;            vec.push_back(temp);        &#125;        else&#123;            vec.push_back(2*temp);            vec.push_back(temp);        &#125;    &#125;    if(vec.size()&lt;1)&#123;        cout&lt;&lt;0&lt;&lt;endl;        return;    &#125;        //正常做LIS    vector&lt;int&gt; lis;int len = vec.size();    lis.push_back(vec[0]);    for(int i=1;i&lt;len;i++)&#123;        if(lis.back()&lt;=vec[i])lis.push_back(vec[i]);        else *upper_bound(lis.begin(),lis.end(),vec[i]) = vec[i];    &#125;    cout&lt;&lt;lis.size()&lt;&lt;endl;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第八週：動態規劃（二）","url":"/sprout8/","content":"這兩週真是風風雨雨，首先第一週是段考週，所以有很多時間拿去惡補段考。第二週則是疫情關係要在家裡線上上課，結果進度就辣了一大截…趕快追QQ！\n上課內容一堆的背包問題（真的很多種耶）\n01背包問題無限背包問題\n\n先固定背包數量看價值跟先固定價值看背包數量可以互換\n\n有限背包問題\n\n多枚舉每個物品要放入的數量\n\n拆分：把同重量的物品看成不同的物品（複雜度不變）\n把$t_i$ 個物品拆成$\\lfloor \\log_2 t_i+1\\rfloor$個物品\n分成的堆數最少：$\\lceil \\log{t_i}+1\\rceil$(因為分成 $k$ 堆最多只可能有 $2^k$ 個值)\n複雜度：$O(n\\log{max(t_i)}W)$\n\n混合背包問題\n\n遇到什麼樣的物品就怎麼做（對有限個背包拆分）\n分成01背包跟無限背包做\n\n二維背包問題\n\n多一維度狀態轉移（可以壓掉一個維度）\n\n分組背包問題\n\n再多一維儲存第幾組\n\n背包合併\n\n直接把物品混起來做\n\n背包問題變化\n\n(1)求最大價值的方法總數\n用g[i] 儲存重量i 的方法數\n\n\n(2)求最大價值的一組方案\ng[i] 看有沒有被更新過，有就g[I] = 1，回溯找\n\n\n(3)求最大價值的字典序最小的一組方案\n把物品倒過來（由大到小）因為越小的(1)要最後考慮，否則1先考慮後面的大的數字會把1覆蓋掉，字典序就變大\n\n\n(4)求次大價值的解/第K大價值的解\n看投影片\n\n\n\n分數背包\n\nGreedy\n\n不同做法複雜度\n\n用價值做狀態\n用重量做狀態\nV, W都很大但n很小？\n枚舉$2^n$ \n\n\n如果V, W都很大n也蠻大？\n折半枚舉（meet in the middle）根號算法\n\n\n\n上機作業背包問題主要有三個變量：價值、重量、物品數量，因此可以有三個作法：\n\n以物品數量n 作為狀態，爆搜，複雜度：$O(2^n)$\n以價值v 作為狀態(v為物品價值總和），dp作，複雜度：$O(NV)$\n以重量w 作為狀態(w為物品重量上限），dp作，複雜度：$O(NW)$\n\n高棕櫚農場題目連結這一題不能用重量做，因為重量的範圍可以到$10^5$，因此只能用價值來做有一個要點，無限大可以memset定義為0x3f3f3f3f，以十進位表示1061109567，在int的範圍但不會超過\n定義定義$f(n,m)$為取n樣物品,價值恰為m,重量總和最小值\n轉移方式$f(n,m) = min(f(n-1,m), f(n-1,m-v_n)+w_n), m ≧ v_n$$f(n,m) = f(n-1,m), m &lt; v_n$\n邊界條件f(0,0) = 0, f(0,k) = INF (k&gt;0)$因為取零樣物品價值要k不可能達到，因此重量設為無限大\n我們可以藉由滾動dp來節省空間，壓成一維（跟用重量作為狀態一樣）最後，在從dp裡面取出max(k), for all f(N,k) ≦ W\n程式碼#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,val[105],weight[100005];cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[100005];        //定義f(n,m)取n樣物品,價值為m,重量總和最小        //dp[i]：價值為i時,重量最小為dp[i]        memset(dp,INF,sizeof(dp));        dp[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=10000;j&gt;=val[i];j--)&#123;                dp[j] = min(dp[j],dp[j-val[i]]+weight[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;=10000;i++)            if(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n高棕櫚農場2題目連結有些細節是必須要注意的，也就是初始化的細節。\n            背包問題是否恰好裝滿對於原本初始化dp[0] = 0，代表對於重量限制為0的背包價值最高為0接下來有兩種情況需要討論，第一種是重量限制為w的背包最多的價值1. 恰好裝滿此時必須初始化dp[i] = -INF，是因為要恰好裝滿的關係，初始化的dp 數組事實上就是在沒有任何物品可以放入背包時的合法狀態，其他除了0之外容量的背包均沒有合法的解，屬於未定義的狀態，所以都應該被賦值為 −∞ 。當前的合法解，一定是從之前的合法狀態推得的(−∞跟−∞取max還是−∞)2. 不需恰好裝滿如果背包並非必須被裝滿，那麼任何容量的背包都有一個合法解“什麼也不裝”，這個解的價值為0,所以初始化時狀態的值也就全部為0了。如果來看轉移式，$dp[j] = max(dp[j],dp[j-weight[i]]+val[i])$，如果兩者的狀態都屬於未定義，對於需恰好裝滿的狀況，兩者都是−∞，表示沒有合法的狀態可以構成此重量。同時，如果不需恰好裝滿的情況，即使$dp[j]$和$dp[j-weight[i]]$都未定義(等於0)，還是可以被更新（在沒有裝滿的情況下，dp[j] = val[i]）\n          這一題除了以上發現，還有一個很重要的東西，就是迴圈到底要放哪一層的問題。主要是卡在 for(int p=1;p&lt;=k;p++)到底要放在哪一層的問題，結果是要放在第三層。\n            問題一：dp[j][p]取決於dp[j][p] 和dp[j-weight[i]][p-1]，而且對於一個物品最多只能放一次，如果放在第二層，dp[j-weight[i]][p-1] 就已經被更新過了，有可能已經取了第 i 樣物品會有重複取的問題，如果放在第三層，代表對每一種不同的重量先更新放入幾樣物品的1到k，再更新重量，這樣就可以保證dp[j][p]不會取到已經更新的格子（dp[j][p] 沒被更新、dp[j-weight[i]][p-1] 其中第一維的j-weight[i] 也還沒被更新）問題二：p要從1到k還是k到1，這其實都可以，因為要取的格子不管從前往後或後往前取都只會取到上一輪(i-1) 的更新東西，因此不影響。還有，因為是定義最多取p樣物品，所以無論i為多少，每一次p皆要更新的k（如果k=5，取一樣物品也符合情況）\n          \n定義定義$f(j,p)$看完 i 樣物品後，重量限制為j，最多取p樣物品的最大價值\n轉移方式$dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i])$\n邊界條件$dp[i][j] = 0$ (for all elements in dp)\n#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,k,val[105],weight[10005];cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[1005][105];        memset(dp, 0, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            for(int j=m;j&gt;=weight[i];j--)&#123;                for(int p=1;p&lt;=k;p++)&#123;                    dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[m][k]&lt;&lt;endl;    &#125;&#125;/* 0 4 5 6 6 6 0 4 5 6 9 10 0 4 5 6 9 10*/\n玩電梯題目連結題目連結2\n這一題要用到3個重要的技巧：前綴和、差分、滾動dp差分在某一次手寫作業有寫到，不過那時候沒有很注意這個部分就是了\n            差分差分是前綴和的逆運算，也就是說，把兩項的差算出來就是差分。定義如下：b_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}差分的使用時機是區間加值，一個區間內的數字都加上一個定值，這時候就可以使用到差分的技巧。使用方式如下，當我要在區間 $[l,r]$ 的每一個數字都加上一個值$v$，以下步驟：定義一個新的陣列 $b_i$ 表示每一項差分設 $bl = b_l+v$，$b{r+1} = b_{r+1}-v$將差分的每一項加上前一項，即為原數列 $bi = b{i-1}+b_i$第二步驟可以重複好幾次做，這樣複雜度從原本的$O(n)$就變成了O(1)了！\n          \n這一題使用到差分的技巧，讓原本的$O(kn^2)$減少成$O(kn)$，然後就可以過了！\n定義定義 $dp[i][j]$ 為第 i 次走到樓層j的方法數\n轉移式這題如果用拉的比較不好想，所以改用推的試試看$dp[i+1][j] = dp[i+1][j]+dp[i][p],$ for $j\\in[p-r],[p+1,p+r],r = |p-b|-1$\n邊界條件$dp[0][a] = 1$\n轉移式比較複雜一點，不過可以用差分優化搭配前綴和把原本$O(n)$的時間降到$O(1)$從這一題可以發現到，用拉的和用推的有不同的使用時機，可以以思考方式比較清楚的想法去想轉移式。\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define ios ios::sync_with_stdio(0)using namespace std;int n,a,b,k,dp[2][2005];int modify(int x)&#123;    return (x%mod+mod)%mod;&#125;void sec(int l,int r,int v,int id)&#123;     l = max(l,(long long)1);    r = min(r,n);    dp[(id+1)%2][l] = modify(dp[(id+1)%2][l]+v);    dp[(id+1)%2][r+1] = modify(dp[(id+1)%2][r+1]-v);&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k;    memset(dp,0,sizeof(dp));    dp[0][a] = 1;    for(int s=0;s&lt;k;s++)&#123;  //每一次電梯移動        for(int i=1;i&lt;=n;i++)&#123; //每一樓層轉移            int d = abs(b-i)-1;            sec(i-d,i-1,dp[s%2][i],s);            sec(i+1,i+d,dp[s%2][i],s);        &#125;        for(int i=1;i&lt;=n;i++)&#123;            dp[(s+1)%2][i] += dp[(s+1)%2][i-1];            dp[(s+1)%2][i] = modify(dp[(s+1)%2][i]);        &#125;        for(int i=1;i&lt;=n;i++)dp[(s)%2][i] = 0;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=dp[k%2][i];        ans = modify(ans);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;//8樓、2樓開始、5樓不能去、2次電梯\n取名字好困難QQ題目連結跟題目一樣，我覺得要通靈才能想到這一題的作法！結果是問了別人才大概感受到這一種作法！！！\n我們既然不知道到底一個數字要不要乘2，我們可以透過做LIS的過程來做決定。當我們把乘與2之後的數字跟原本數字一起push進去，就可以發現到LIS不可能同時取到2個數字。利用這個方法就可以用LIS的過程決定一個數字到底應該要變2倍還是不用。要找到最長的非嚴格遞增序列，最大的差別就是要把原本的lower_bound改成upper_bound。一整天想一題的感覺超級糟糕QQ\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    vector&lt;int&gt;vec;    FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        if(2*temp&lt;m)continue;        else if(temp&lt;m)&#123;            temp*=2;            vec.push_back(temp);        &#125;        else&#123;            vec.push_back(2*temp);            vec.push_back(temp);        &#125;    &#125;    if(vec.size()&lt;1)&#123;        cout&lt;&lt;0&lt;&lt;endl;        return;    &#125;        //正常做LIS    vector&lt;int&gt; lis;int len = vec.size();    lis.push_back(vec[0]);    for(int i=1;i&lt;len;i++)&#123;        if(lis.back()&lt;=vec[i])lis.push_back(vec[i]);        else *upper_bound(lis.begin(),lis.end(),vec[i]) = vec[i];    &#125;    cout&lt;&lt;lis.size()&lt;&lt;endl;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n手寫作業這一週是講歸約法，作業如下：這一週手寫作業的狀況還不錯，71/75，不過第一題是緊急向別人求救才把答案改掉原本是寫B，後來改A，原因有以下兩點：\n\n因為函數在 return 時不會把 stack memory 上的資料清空，所以所有的區域變數都會被留在 stack memory 上，其他函數可能會共用到同一塊記憶體空間。\n有可能會對非法的陣列位址取值(RE的情況)，而存取到別的函數的區域變數。\n\n所以A是錯誤的！下面是解答的畫法，其實跟我蠻像的XDD\n","categories":["資訊之芽筆記"],"tags":["動態規劃","DP","資芽筆記"]},{"title":"[題解]NEOJ 188 円円賣漢堡","url":"/sprout9-1/","content":"円円賣漢堡\n題目連結首先在做任何優化之前，都必須先列出定義與轉移式。\n定義定義$dp[i]$為在第1到i個點開店，且第i個點有開店時的最大盈利\n轉移式$dp[i] = val[i]+max(dp[j]-c(i-j)),i-k≤j≤i-1$\n邊界$dp[i] = 0, 1≤i≤n$\n做完以上的定義與轉移式之後，可以得到複雜度：$O(NK)$就可以得到以下的結果：試著利用單調隊列優化，把複雜度降到$O(N)$利用單調隊列可以確保所有的數字都只會被push與pop一次，因此總複雜度為$O(n)$差一個K時間就差很多！\n具體的作法如下，因為我們要維護的單調隊列的dp後面有一些東西，因此我們要做一些調整，把有i的提出來（不然當i不一樣的時候就很難處理）\n\\begin{split}dp[i] &= val[i]+max(dp[j]-c(i-j)),i-k≤j≤i-1\\\\&=val[i]-ci+max(dp[j]+cj)\\end{split}這時候令 $t[j] = dp[j]+cj$，可以把加上 $cj$ 想像成跟頭的距離（跟當前的 $-ci$ 合在一起就是我們要的距離），則 $max(t[j]),i-k≤j≤i-1$ 就可以使用單調隊列優化！\n\n            單調隊列優化單調隊列優化名稱的由來是因為維護的容器具有單調性（在這裡用到的是單調遞減），這一次嘗試的是用deque","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 187 高棕櫚觀光農場：旅行銷售員問題TSP","url":"/sprout9-2/","content":"高棕櫚觀光農場：旅行銷售員問題TSP\n題目連結第一次寫TSP(Traveling Salesman Problem)，題目敘述如下：\n\n給定一系列城市和每對城市之間的距離，求解存取每一座城市一次並回到起始城市的最短迴路。\n\n這是一個已經被證明$NP-Hard$ 的問題，暴力作法是要檢查所有路徑的情況，因為共有n個點，每一個點又連接n-1個點，繼續下去總共會有N!種情況，因此複雜度為$O(n!)$。總共的點數共有n個，根據多邊形的邊數公式可以知道一共有$\\frac{n^2-n}{2}$條邊，每一條邊都有各自的距離。如果改用DP做，時間複雜度可以壓到時間複雜度$O(n^2\\cdot2^n)$，比$O(n!)$還優秀！這一題用到的是DP優化中的狀態壓縮，具體的實作細節如下：\n\n            位元運算在這一題需要用到位元運算，用16個bit表示每一個點有沒有被走訪過。用這樣的表示方法可以讓code更為節儉，也就是狀態壓縮的概念。左移運算子(&lt;&lt;)這一題會一直反覆被用到，1&lt;&lt;t代表把1往左移動t單位，用10進位表示就是$2^t$。每往左移動一格，數字就會變成原來的兩倍！狀態壓縮將十進位整數s以二進位表示，會得到一串01字串，假設s=10，則 $s = 1010_{(2)}$。以這題來說，這樣的字串我們可以用來表示第4和第2個點已經被拜訪，而第3跟第1個點還沒有被拜訪。\n          \n定義定義 $dp[n][s]$ 表示目前在第n點上，s為走過的點（狀態壓縮）的最短距離\n轉移式$dp[n][s] = min(dp[i][s-(1&lt;&lt;n)]+dis[i][n])$, for all i such that s&amp;(1&lt;&lt;i)!=0\n這個轉移式很有意思，因為s代表了每一個點是否有被走過，當我要更新dp[n][s]時，我要確保此時的狀態s中的點n必須為1。同時，因為1&lt;&lt;i用二進位表示只有第i位會是1其他都是0，做and運算就看s的第i位決定結果。\n對於每一個i必須確保第i點在狀態s中有被造訪，因此有了後面的條件。另外轉移式中的s-(1&lt;&lt;N)是把第n個點從未造訪的狀態轉移。\n邊界$dp[0][1] = 0,\\quad dp[i][j]= \\infty$\n距離的預設狀態為無限大，第一個點的初始狀態是最短距離0\n實作小細節迴圈順序在轉移的過程中，迴圈的第一層必須是狀態，第二層才是城市。如果顛倒過來的話，會導致前面的城市在狀態還沒有被更新的時候就已經失去了之後被更新的機會，因此城市的迴圈必須放在第二層！\n求答案因為我們要求的是回到原點的最短距離，因此在全部轉移完成之後，利用一個迴圈把回去原點的路的距離加上去，求得最小值。\n#include &lt;bits/stdc++.h&gt;#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,dis[20][20];cin&gt;&gt;n;    memset(dis,0,sizeof(dis));        for(int i=0;i&lt;n-1;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            cin&gt;&gt;dis[i][j];            dis[j][i] = dis[i][j];        &#125;    &#125;        int dp[N][66000],m = 1&lt;&lt;n;    memset(dp,0x3f3f3f3f,sizeof(dp));    dp[0][1] = 0;   //將0點到自己的距離設為1        //O(n^2 2^n)    for(int i=0;i&lt;m;i++)&#123;            //i表示2^n每一種狀態        for(int j=0;j&lt;n;j++)&#123;        //j表示城市            if(!(i&amp;(1&lt;&lt;j)))continue; //j城市要是被造訪過的狀態            for(int k=0;k&lt;n;k++)&#123;    //可以到的所有點中的狀態                if(i &amp; 1&lt;&lt;k)&#123;        //確保轉移過去的有被造訪過                    dp[j][i] = min(dp[j][i],dp[k][i-(1&lt;&lt;j)]+dis[j][k]);                &#125;            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)ans = min(ans,dp[i][m-1]+dis[i][0]);    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 255 憤怒的小鳥","url":"/sprout9-3/","content":"憤怒的小鳥\n題目連結Submission玩憤怒鳥遊戲的概念，給定二維平面上n個點代表n個豬（皆在第一象限），這時候可以從原點(0,0)的位置發射軌跡為拋物線的小鳥，打到豬豬後並不會改變飛行的軌跡，題目想要問最少要發射幾個小鳥才能射下所有的豬豬？\n\n範例測資71 32 43 32 64 81 11 2\n\n如果畫在圖上就長這樣：\n如果把拋物線畫出來就像這樣：\n因為$n\\le24$，所以可以知道這一題可能只能把所有情況都掃一遍（才不是因為剛好講狀態壓縮XD）\n作法1： 時間複雜度$O(n^2\\cdot 2^n)$我們可以利用一個二維陣列g[i][j]表示經過i豬和j豬與原點所形成的拋物線所能經過的所有點的狀態。這樣我們可以利用$O(n^3)$的時間完成預處理，知道一條由i豬和j豬形成的拋物線能經過的點的狀態（用二進位表示），在dp轉移的時候則需枚舉所有的i和j，所需時間是$n^2$。轉移式的話一開始是寫用推的：$dp[s|g[i][j]] = min(dp[s]+1)$，比較直覺一點。\n作法2： 時間複雜度$O(n\\cdot 2^n)$當我們在做狀態s的時候，如果是上面的方法就是$n^2$掃過所有的點的組合，其實我們可以只要找到s其中一位第k位是1的，因為那一位所對應到的豬豬一定會經過，所以就可以針對那一位做轉移，如此一來跟k同在一個拋物線的最多只會有n個，複雜度就降到了$O(n\\cdot 2^n)$。這裡可以搭配一個vectorline[N]裝每一位有經過的可能的狀態。\n定義$dp[s]$為狀態為s的時候的最小拋物線數量\n轉移式$dp[s]=min(dp[s\\&amp;(\\sim mask)]+1)$\n這個轉移式挺有趣的，我們知道如果要從狀態p得到狀態s，對於s是0的bit，p也應該是0；對於s是1的bit，若mask是1，則p的bit要是0，反之則是1。\nst=&gt;start: for each bit p in ssub1=&gt;subroutine: My Subroutinecond=&gt;condition: if p=1e=&gt;operation: set dp[i] to 0io=&gt;condition: if mask[i]=1ss=&gt;operation: set dp[i] to 1sp1=&gt;operation: set dp[i] to 0sp2=&gt;operation: set dp[i] to 1st-&gt;cond-&gt;iocond(yes)-&gt;io-&gt;econd(no)-&gt;eio(yes)-&gt;sp1io(no)-&gt;sp2\n這個轉移式可以有另外一個表示的方式，可以達到同樣的效果：$dp[s]=min(dp[s\\&amp;(i\\oplus mask)]+1)$\n邊界$for\\ each\\ dp[i]=0$\n以下程式碼是以$O(n^3)$的預處理，$O(n\\cdot 2^n)$的轉移，因此總時間複雜度是$O(2^n)$，在時限內是可以過的！\n\n[time=Thu, Sep 16, 2021 3:03 PM]更新\n\n結果呢，有人問了我這一題，我回去看我的code，結果發現明明應該是 $O(n\\cdot 2^n)$ 轉移，但每一個line_mask中在worst case卻有 $n^2$ 個狀態，這樣子下來一樣還是 $O(n^2\\cdot 2^n)$ 沒有進步。發現問題在於，當全部的點都在同一條拋物線上的時候，會有重複的狀態被push很多次的問題，所以只要用visit去紀錄這種狀態是否出現過，讓最多被推入一次就好!\n\n#include &lt;bits/stdc++.h&gt;#define long long ll#define N 24#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t,n,x[N],y[N];void solve()&#123;    vector&lt;int&gt;line_mask[N];    scanf(&quot;%d&quot;,&amp;n);    for(int i = 0;i &lt; n;i++)scanf(&quot;%d %d&quot;,&amp;x[i],&amp;y[i]);    int m = 1&lt;&lt;n,dp[m];    bool visit[m];memset(visit,0,sizeof(visit));    //calculate all lines O(n^3)    for(int i=0;i&lt;n;i++)&#123;        line_mask[i].push_back(1&lt;&lt;i);       //有可能此點孤立一人，要確保也在裡面        for(int j=i+1;j&lt;n;j++)&#123;            int x1 = x[i],y1 = y[i];            int x2 = x[j],y2 = y[j];            if(x1==x2)continue;            double a = (double)((x1*y2)-(x2*y1))/(x1*x2*(x2-x1));            double b = (double)(y1-a*x1*x1)/x1;            if(a &gt;= 0)continue;            int mask1 = 1&lt;&lt;i|1&lt;&lt;j;            for(int k = 0;k &lt; n;k++)&#123;                if(fabs((double)a*x[k]*x[k]+b*x[k]-y[k])&lt;=1e-6)mask1|=(1&lt;&lt;k);            &#125;            if(visit[mask1])continue;            for(int k = 0;k &lt; n;k++)&#123;                if((mask1&gt;&gt;k) &amp; 1)line_mask[k].push_back(mask1);            &#125;            visit[mask1] = 1;            //過k點的所有經過的點的狀態        &#125;    &#125;    memset(dp,0x3f3f3f,sizeof(dp));    dp[0] = 0;    //O(n 2^n轉移)    for(int s = 1;s &lt; m;s++)&#123;        int cur = __lg(s),len = line_mask[cur].size();        for(int i = 0;i &lt; len;i++)&#123;            int mk = line_mask[cur][i];            dp[s] = min(dp[s], dp[(s&amp;(~mk))] + 1);            if(dp[s] == 1)break;        &#125;    &#125;    printf(&quot;%d\\n&quot;,dp[m-1]);&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 159 硬幣問題","url":"/sprout9-4/","content":"硬幣問題\n題目連結\n有點訝異，原本想說把code丟上去測一下，看看能過前面幾筆測資，結果卻直接全部過了！我也沒有做什麼特別的DP優化，丟上去卻直接Accept了！這題跟原本的硬幣問題有些許的不同，在於他有限制每一種硬幣的數量，面額為 $C_i$ 的硬幣共有 $K_i$ 個，也就是要問你能否用這些固定數量的硬幣湊出特定的面額。\n我們可以討論不同的面額的餘數，時間複雜度分析估計約為：$O(N\\times C_i\\times \\frac{M}{C_i})=O(NM)$，照理來說因為要執行t次，算下來有可能會TLE，不過這一題沒有卡就是了。\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,m,val[N],num[N];cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i]&gt;&gt;num[i];        bool dp[20005];    memset(dp,0,sizeof(dp));    dp[0] = 1;        for(int i=0;i&lt;n;i++)&#123;        for(int k=0;k&lt;val[i];k++)&#123;            int left = num[i];            for(int j=k+val[i];j&lt;=m;j+=val[i])&#123;                if(dp[j]!=0)left = num[i];                else if(left&gt;0 &amp;&amp; dp[j-val[i]])&#123;                    left--;                    dp[j] = 1;                &#125;            &#125;        &#125;    &#125;    if(dp[m]==1)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"[題解]NEOJ 185 烏龜疊疊樂---易","url":"/sprout9-5/","content":"烏龜疊疊樂—-易\n題目連結這題簡單來說，是給定一個數列，要嘗試分配成好幾堆，每一堆的數量不超過k個。其中第i堆的總和乘上(i-1)，算出來的總和要最小。由題目敘述可以知道，每一堆到後面乘上的數字是越來越大，也就是被加上的次數會越來越多，如果我們將數列倒過來dp會比正面做來得容易維護。\n\n            轉移式dp[i] = max(dp[j]+pref[j]),for i-k≤j≤i-1，pref是維護已經反序過後的數列之前綴和。以範測為例，當k=2時，dp[i]可以選擇的就是從dp[i-1]跟dp[i-2]轉移，如果選擇dp[i-2]就表示第i項會和第i-1項合併成一堆，加上pref[i-2]也就是把前面的每一堆的數量乘上的數字都加一，也就是加上一個前綴和（由於每一個數字只會被合併一次）小證明：每一個數字只會被合併一次在轉移的過程中，有沒有可能會發生dp[i]要轉移的對象是dp[i-2]，但dp[i-1]卻已經被融合過了，造成三個烏龜融合在一起的情況？也就是下圖這一種情況，dp[i-1]、dp[i-2]合併，dp[i]、dp[i-1]合併，變成三個融合超過k的情況（dp[i-2],dp[i-1],dp[i]合併）。答案：不會首先先從dp[i-3]轉移的dp[i-1]表示第i-2跟i-1是合併成一堆，接下來的dp[i]從dp[i-2]轉移，加上了pref[i-2]，也就是把i-2獨立出去，i跟i-1合併成一堆，因此不會有大於k個烏龜合併在一起的情況。\n          \n這一題的轉移式不好想，要把東西反序之後比較好dp，轉移式也比較好寫出來！觀察到越後面的數字被重複加的機會比較大（高度越高），因此將數列的順續顛倒搭配前綴和就能比較方便的轉移！\n定義$dp[i]$定義為使用1到i個烏龜，違和度的最大值\n轉移式$dp[i] = max(dp[j]+pref[j]),for\\ i-k≤j≤i-1$這個轉移式是建立在順序顛倒的情況，在輸入的時候順便把逆序。\n邊界$for\\ each\\ dp[i] = 0$\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 500005#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int n,k,arr[N],pref[N];signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;k;    for(int i=n;i&gt;0;i--)cin&gt;&gt;arr[i];    for(int i=1;i&lt;=n;i++)pref[i] = pref[i-1]+arr[i];        int dp[N];    memset(dp,0,sizeof(dp));        deque&lt;pair&lt;int,int&gt;&gt; deq;    deq.push_back(make_pair(0,0));        for(int i=1;i&lt;=n;i++)&#123;        while(!deq.empty() &amp;&amp; deq.front().second&lt;i-k)deq.pop_front();        dp[i] = deq.front().first;        while(!deq.empty() &amp;&amp; deq.back().first &lt;= dp[i]+pref[i])deq.pop_back();        deq.push_back(make_pair(dp[i]+pref[i],i));    &#125;    cout&lt;&lt;dp[n]&lt;&lt;endl;&#125;\n","categories":["資芽題解"],"tags":["題解","資訊之芽"]},{"title":"資芽第九週：動態規劃（三）","url":"/sprout9/","content":"上課內容首先是影片的重點整理，主題是DP優化：\nDP優化\n\n矩陣快速冪優化\n費氏數列：O(n)-&gt;O(logN)\nDC\n把很大的n做矩陣快速冪降到logN\n\n\n狀態壓縮\n\nTSP旅行銷售員問題\n權重最小的漢米頓迴路\n暴力做：n個點、n-1點、…、1個點\n暴力複雜度：O(N!)\n使用位元紀錄\nDP[n][s]用s的二進位第i位表示是否去過該城市\n複雜度：轉移$O(N)\\times O(N\\times 2^N)=O(n^2\\times 2^n)$\n\n\n資料結構優化（單調隊列優化）\n\n開一個新的dpMAX，O(n^2)-&gt;O(n)\n不大於K，用heap來O(nlogn)維護遞增的固定區間最大值\n方法三：用Deque實作，O(n)\nIdp[j] 具有單調性（單調遞減）\n\n\n円円開店\n\ndp[n] = val[n]+max(dp[i]-c(n-i)),n-k≤i≤n-1\nO(NK)-&gt;O(N)使用單調隊列優化\n令t[I] = dp[i]+c*i\n\n\n有限背包問題優化\n\n分推湊出每一種重量\n如何分推：二進位 ${1,2,4,8,…,2^p,q}$，使 $2^{p+1}-1$ 不大於k[i]的最大整數\n原O(NWK) -&gt; O(NW*logK)\n利用單調隊列優化：O(NW)!!!\n\n\n\n上機作業円円賣漢堡題目連結首先在做任何優化之前，都必須先列出定義與轉移式。\n定義定義$dp[i]$為在第1到i個點開店，且第i個點有開店時的最大盈利\n轉移式$dp[i] = val[i]+max(dp[j]-c(i-j)),i-k≤j≤i-1$\n邊界$dp[i] = 0, 1≤i≤n$\n做完以上的定義與轉移式之後，可以得到複雜度：$O(NK)$就可以得到以下的結果：試著利用單調隊列優化，把複雜度降到$O(N)$利用單調隊列可以確保所有的數字都只會被push與pop一次，因此總複雜度為$O(n)$差一個K時間就差很多！\n具體的作法如下，因為我們要維護的單調隊列的dp後面有一些東西，因此我們要做一些調整，把有i的提出來（不然當i不一樣的時候就很難處理）\n\\begin{split}dp[i] &= val[i]+max(dp[j]-c(i-j)),i-k≤j≤i-1\\\\&=val[i]-ci+max(dp[j]+cj)\\end{split}這時候令 $t[j] = dp[j]+cj$，可以把加上 $cj$ 想像成跟頭的距離（跟當前的 $-ci$ 合在一起就是我們要的距離），則 $max(t[j]),i-k≤j≤i-1$ 就可以使用單調隊列優化！\n\n            單調隊列優化單調隊列優化名稱的由來是因為維護的容器具有單調性（在這裡用到的是單調遞減），這一次嘗試的是用deque","categories":["資訊之芽筆記"],"tags":["動態規劃","DP","資芽筆記"]},{"title":"字串演算法 (String)","url":"/string1/","content":"這個暑假看了動態規劃(1),(2)，線段樹、最短路徑、計算幾何、字串演算法，這一篇的完成算是暑假的一個里程吧！接下來繼續學習不同的主題，再把筆記更新到部落格中！\n課程內容字串\n定義\n大寫 $\\Sigma$ 表示字元集\n字串：有限個字元集組成\n$|\\Sigma|$ 字元集大小、|S|字串長度\nS[a:b]表示連續從字元a到b\n\n\n子字串：S[a:b]\n前綴：S[0:b]\n後綴：S[a:|S|-1]\n\n字典樹Trie\n定義\n例題：字串出現次數\n一顆由根、邊一綠往下指的有向樹\n每個邊為字元、每一點代表字串\n每經過一條邊，字串加上邊的字元\n根節點為空字串！\n\n\n操作\n查詢字串：$O(L)$，由根順著邊往下找\n插入字串：$O(L)$，不斷往下走直到空節點，在Trie加入一個節點\n節點必須記錄當前是否為有效字串\nTrie結構中包含：字串、紀錄字串出現次數\n\n\n\nKMP\n功能：進行字串匹配\n例題：字串S在字串T哪些位置出現\n暴力匹配：時間 $O(|S|\\times|T|)$\n\n\nF[i]表示當配對成功A[0:i]後即配對失敗，將A[F[i]]對齊原本A[i]的位置\n搭配F[i]調整在串移動的長度\n匹配：複雜度 $O(|T|)$，建立F函數：$O(|S|)$\n\n漢明距離(Hamming distance)\n兩個等長字符串對應位置的不同字符的個數\n\nZ-value\nz[i] 是指由 s[i] 開始的字串，與 s[0] 開始的字串可以匹配到多長\nS[0:k-1] = S[i:i+k-1]\nz[0] = 0\n\nRolling Hash\n之前隨機講過\n\n後綴數組（Suffix Array）\n將一個字串的所有後綴進行排序\n基數排序（Radix Sort）\n\n最長共同前綴（LCP,Longest Common Prefix）\n兩字串的最長共同前綴\n將最長共同前綴轉換成區間最小值問題\n\n字串演算法主題字典樹Trie字典樹是以指標型態建立的一棵樹，邊代表一個字元、節點代表從根一路走來的邊形成的字串，從根節點開始（根節點為空），每經過一條邊，就把字串加上那一條邊對應的字元，直到找出要匹配的字串。如果有多筆獨立的詢問，只要加上Delete函數就可以了！\nTrie結構實作上的陣列c指向個別的字元，不一定要用cnt，根據題目的所求調整不同的變數設定。\nstruct Trie&#123;        //利用指標建立一棵樹    Trie* c[26];    //對應a-z每一條邊    int cnt;        //字串出現次數    Trie(): cnt(0)&#123; //初始設定        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root;\nInsert函數在插入的過程中言錄新增路徑，一樣嘢可以根據題目要求在過程中進行變數紀錄等。如NEOJ 267 自動完成系統。\nvoid insert(char *s)&#123;    Trie *ptr = root;           //從根節點尋找    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //如果樹上無此字元則new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //繼續造訪Trie        s += 1;                 //字串下一個字元    &#125;    ptr-&gt;cnt += 1;              //字串出現次數(字串對應唯一葉節點)&#125;\n查詢函數一個字串對應到唯一的路徑，從根節點根據每一個字元決定路徑。\nint find(char *s)&#123;              //查找字串s    Trie *ptr = root;           //根節點尋找    while(*s)&#123;                  //無此字串，回傳次數0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //字串下一個字元    &#125;    return ptr-&gt;cnt;            //回傳字串出現次數&#125;\nDelete函數void clear(Trie *s)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(s-&gt;c[i])&#123;            clear(s-&gt;c[i]);            delete s-&gt;c[i];            s-&gt;c[i] = nullptr;    //很重要        &#125;    &#125;&#125;\nKMP Algorithm首先要求出Failure Function，它可以在 $O(|S|)$ 建立。失敗函數的定義是：\n\n$F[i]$ 表示當成功配對 $A[0:i]$ 之後，配對失敗時，我們會將 $A[ F[i]]$ 對齊原本 $A[i]$ 的位置\n\n如果寫成數學式的定義：\nF_A(J)=\\left\\{\n\\begin{array}{l}\n-1,&&\\text{if j = 0}\\\\\nmax\\{p:A_{0...p} = A_{j-p...j} \\text{ and 0≤p","categories":["C++進階主題","字串演算法"],"tags":["演算法","字串"]},{"title":"[題解]NEOJ 266 溫力的故事","url":"/string2-1/","content":"NEOJ 266 溫力的故事\n題目連結Submission\n\n題目敘述給你n個字串m筆詢問一個字串，對每一筆詢問輸出詢問在n個字串中出現的次數。\n\n這一題在隨機算法做過，今天用字典樹Trie做一次。在隨機算法中，透過Rolling Hash的公式，對每一個字串生成一個值，利用這個值查詢出現的次數。如果我們用Trie的話，則是建立一棵指標樹，透過走法這一棵字典樹得知詢問字串出現的次數！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;        //利用指標建立一棵樹    Trie* c[26];    //對應a-z每一條邊    int cnt;        //字串出現次數    Trie(): cnt(0)&#123; //初始設定        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void insert(char *s)&#123;    Trie *ptr = root;           //從根節點尋找    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //如果樹上無此字元則new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //繼續造訪Trie        s += 1;                 //字串下一個字元    &#125;    ptr-&gt;cnt += 1;              //字串出現次數(字串對應唯一葉節點)&#125;int find(char *s)&#123;              //查找字串s    Trie *ptr = root;           //根節點尋找    while(*s)&#123;                  //無此字串，回傳次數0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //字串下一個字元    &#125;    return ptr-&gt;cnt;            //回傳字串出現次數&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,n-1)&#123;        char s[105];cin&gt;&gt;s;        insert(s);    &#125;    rep(i,0,m-1)&#123;        char s[105];cin&gt;&gt;s;        cout&lt;&lt;find(s)&lt;&lt;endl;    &#125;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]TIOJ 1497 喝醉的宿主 The drunk host","url":"/string2-10/","content":"TIOJ 1497 喝醉的宿主 The drunk host\n題目連結Submission\n\n題目敘述裸後綴數組。\n\n後綴數組我看了好久（大概有4天吧），一直對著它發呆，不知道它的精髓到底在哪裡。。剛好又遇到開學，不能整天快樂寫題XD\n倍增優化對著螢幕發呆的日子終於結束了，直到我看了這一篇（雖然說我前幾天也有看但看不懂，可能是消化的天數不夠多吧），尤其是裡面的一張圖，深刻說明了倍增的精髓。\n後綴數組求法就不多解釋（上面有），放幾個實作上的小細節。\n\n            實作小細節我們要求進行 $O(\\log n)$ 層的倍增，可以使用C++內建的log10()再用ceil去處理，但顯然有點慢，如果套用以下函數，它會回傳數字二進位之後最大的1前面總共有多少個0（前綴0的數量），與32相減（32是long long的關係）就是我們要的log的次數。int lg = __builtin_clz(n)另外一個小小細節，就是在字串的後半部分，如果跟前面一樣倍增一個比較大的數字，有可能會超出範圍，這時候初始值就很重要了！初始設定rk[n] = -1，導致任何只要超出範圍的都會取到這個-1，表示只要後面沒有字串、如果前面都相同但長度比較長的字串比起來，較短的會排在比較前面的位置！\n          \n這個算法是 $O(n\\log^2 n)$，TIOJ這一題可以過，不過到SPOJ就會被卡TLE\n\n$O(n^2 log(n))$ is expected to score about 20-30. (Naive sorting all suffixes)$O(n log^2(n))$ is expected to score about 40. (OK for most programming contest problems)$O(n log n)$ is expected to score about 60-70. (Use counting sort for small alphabet size)$O(n)$ without tweaks is expected to score about 80-90.$O(n)$ with tweaks is expected to score 100. (This is meant for fun only :)\n\n越後面就越毒瘤XD\n\ntest 1 - AC (score=0.000000, sig=0, time=0.009123, mem=5372)test 2 - AC (score=0.000000, sig=0, time=0.006427, mem=5508)test 3 - AC (score=0.000000, sig=0, time=0.014975, mem=5468)test 4 - AC (score=0.000000, sig=0, time=0.031332, mem=5536)test 5 - AC (score=0.000000, sig=0, time=0.026948, mem=5456)test 6 - AC (score=0.000000, sig=0, time=0.023113, mem=5396)test 7 - TLE (score=0.000000, sig=0, time=0.210000, mem=7340)test 8 - TLE (score=0.000000, sig=0, time=0.210000, mem=7152)test 9 - AC (score=0.000000, sig=0, time=0.170094, mem=7284)test 10 - AC (score=0.000000, sig=0, time=0.140098, mem=7340)\n\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//第一位、第二位比較以及後綴編號bool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //回傳第一個1之前0的個數（二進位）    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //現在倍增的大小        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)&#123;            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //設定rk，與前一個相同則設定跟前一個一樣        &#125;        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\nRadix Sort 優化Submission\n比較一下 $O(n\\log^2 n)$ 以及 $O(n\\log n)$ 的時間，兩者花了近兩倍的時間差距。看了一下這一題的TopCoder，竟然可以做到十位數毫秒！如果要繼續優化成線性 $O(n)$ 的複雜度，就會使用到 DC3 的演算法，雖然好像很複雜不實用QQ\n\n\n\n使用 $O(n\\log^2n)$ 的算法會TLE第八、九筆測資，不過使用基數排序就可以AC了！\n\ntest 1 - AC (score=0.000000, sig=0, time=0.006565, mem=6048)test 2 - AC (score=0.000000, sig=0, time=0.006594, mem=6300)test 3 - AC (score=0.000000, sig=0, time=0.012431, mem=7860)test 4 - AC (score=0.000000, sig=0, time=0.012267, mem=7208)test 5 - AC (score=0.000000, sig=0, time=0.011158, mem=6804)test 6 - AC (score=0.000000, sig=0, time=0.012057, mem=7892)test 7 - AC (score=0.000000, sig=0, time=0.140876, mem=17720)test 8 - AC (score=0.000000, sig=0, time=0.077631, mem=21952)test 9 - AC (score=0.000000, sig=0, time=0.074905, mem=21340)test 10 - AC (score=0.000000, sig=0, time=0.076732, mem=30160)\n\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//第一位、第二位比較以及後綴編號vector&lt;pt&gt; temp,box[N];void init()&#123;    temp.clear();    rep(i,0,n-1)box[i].clear();&#125;bool cmp(pt a,pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void raddix_sort(vector&lt;pt&gt; &amp;cur)&#123;    init();    rep(i,0,n-1)&#123;        if(cur[i].y == -1)temp.push_back(cur[i]);        else box[cur[i].y].push_back(cur[i]);    &#125;    rep(i,0,n-1)        for(auto j : box[i])temp.push_back(j);    rep(i,0,n-1)box[i].clear();    rep(i,0,n-1)        box[temp[i].x].push_back(temp[i]);    cur.clear();    rep(i,0,n-1)        for(auto j : box[i])cur.push_back(j);&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);//回傳第一個1之前0的個數（二進位）    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1) cur[i] = &#123;S[i],0,i&#125;;    sort(all(cur),cmp);    rk[cur[0].id] = 0;    rep(i,1,n-1)        rk[cur[i].id] = (cur[i]==cur[i-1])?rk[cur[i-1].id]:i;    rep(i,0,n-1)cur[i] = &#123;rk[i],0,i&#125;;    rep(p,0,lg)&#123;                //進行O(lgn)次        int k = 1 &lt;&lt; p;         //現在倍增的大小        raddix_sort(cur);        rk[cur[0].id] = 0;        rep(i,1,n-1)            //設定rk，與前一個相同則設定跟前一個一樣            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);        rep(i,0,n-1)            //倍增pair的second            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;    &#125;    raddix_sort(cur);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]TIOJ 1515 Problem E. 似曾相識","url":"/string2-11/","content":"TIOJ 1515 Problem E. 似曾相識\n題目連結Submission\n\n題目敘述裸後綴數組 LCP。\n\n這題我想好久，一直想不通轉移的條件以及k-1的原因，不過最後還是想通了！這一題只要把 $lcp$ 求出來之後，找最大值就是題目要求的答案。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 200005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//第一位、第二位比較以及後綴編號bool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //回傳第一個1之前0的個數（二進位）    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //現在倍增的大小        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //設定rk，與前一個相同則設定跟前一個一樣        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;vector&lt;int&gt; LCP(string s)&#123;    vector&lt;int&gt; rk(n,0),lcp(n,0);    rep(i,0,n-1)rk[sa[i]] = i;      //利用sa反函數得到rk    int k = 0;    rep(i,0,n-1)&#123;        if(k)k--;        if(rk[i] == n-1)continue;   //rk[n-1]未定義        int j = sa[rk[i]+1];        //下一名後綴從何開始        while(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;        lcp[rk[i]] = k;    &#125;    return lcp;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;cin.ignore();    string S;getline(cin,S);    suffix_array(S);    vector&lt;int&gt; lcp = LCP(S);        int ans = 0;    rep(i,0,n-1)ans = max(lcp[i],ans);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]NEOJ 265 欸迪的字串","url":"/string2-2/","content":"NEOJ 265 欸迪的字串\n題目連結Submission\n\n題目敘述給你字串S和字串T，求出S在T中出現的位置\n\n這一題在隨機演算法也有出現過，當時是用Rolling Hash的方式透過扣掉Hash的方法比對字串是否相同（推一下公式就知道）。現在要用的是KMP演算法，很複雜不好想。\n比較一下隨機跟KMP的時間，下方為KMP，上方則是隨機算法，兩者時間差了將近1倍，雖然兩者都可以在O(|T|)時間內進行匹配，但是建立Rolling Hash的常數是比較大的！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;vector&lt;int&gt; KMP_match(char *S,int *F,char *T)&#123;    vector&lt;int&gt; ans;            //回傳匹配相同地方    int p = -1;                 //紀錄短字串有多少被匹配    for(int i=0;T[i];i++)&#123;      //每一迴圈都讓T[i]被匹配到        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];           //使T[i]一定可以被匹配到        if(S[p+1] == T[i])            p += 1;             //T的第i個與S的p+1可以匹配        if(!S[p+1])&#123;            //S[p]已經匹配完成            ans.push_back(i-p); //回推匹配開頭            p = F[p];           //繼續下一輪匹配        &#125;    &#125;    return ans;&#125;//O(|S|)要配對的字串以及Fail Functionvoid KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;              //初始設定為-1    for(int i=1;S[i];i++)&#123;          //1到接下來字元        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];               //無法繼續配對，尋找更短字串        if(S[p+1] == S[i])          //配對成功(如都沒有一樣的就-1)            p += 1;        F[i] = p;                   //設定F[i]    &#125;&#125;signed main()&#123;    Orz;    char S[N],T[N];     //詢問短字串、長在串    int F[N];           //失敗函數    cin&gt;&gt;S&gt;&gt;T;    KMP_build(S,F);    vector&lt;int&gt; ans = KMP_match(S,F,T);    if(ans.size()&gt;0)&#123;        cout&lt;&lt;ans[0];        rep(i,1,ans.size()-1)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]NEOJ 267 自動完成系統","url":"/string2-3/","content":"NEOJ 267 自動完成系統\n題目連結Submission\n\n題目敘述點這裡有FB Hacker Cup的原題連結，簡單來說就是想像手機的自動填入系統，每加入一個字串會記錄到資料庫中，當資料庫裡面沒有相同前綴的字串時就輸出前綴長度。\n\n用字典樹Trie插入每一個字串，插入過程中返回從頭到開始new新的節點之間經過的節點樹，代表需要輸入多少個字元才能觸發自動完成系統。這一題是基礎的Trie應用。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n;char S[N];int ch(char a)&#123;    return a-&#x27;a&#x27;;&#125;struct Trie&#123;    Trie* c[26];    Trie()&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie *root = new Trie();int insert(char *S)&#123;    Trie *ptr = root;    int step = 0,f = 1;    while(*S)&#123;        if(f)step++;        if(!ptr-&gt;c[ch(*S)])&#123;            ptr-&gt;c[ch(*S)] = new Trie();            f = 0;        &#125;        ptr = ptr-&gt;c[ch(*S)];        S++;    &#125;    return step;&#125;void clear(Trie *s)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(s-&gt;c[i])&#123;            clear(s-&gt;c[i]);            delete s-&gt;c[i];            s-&gt;c[i] = nullptr;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;t;    int cnt = 0;    while(t--)&#123;        cnt++;        cin&gt;&gt;n;        int step = 0;        rep(i,0,n-1)&#123;            cin&gt;&gt;S;            step +=insert(S);        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;step&lt;&lt;endl;        clear(root);    &#125;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]NEOJ 264 欸迪的字串","url":"/string2-4/","content":"NEOJ 264 欸迪的字串\n題目連結Submission\n\n題目敘述給你字串S，求一個最短字串T的長度，滿足經由複製若干次後接起來會是字串S。\n\n這一題在一開始看到感覺好難，不過在慢慢理解 Z_Algorithm 之後，在講義中發現到這個問題也可以用這個演算法來解決！因為Z函數是滿足從i開始的最長前綴，因此當 $i$ 為 字串長度 $n$ 的因數的時候，只要 $i+Z[i+1]=n$ 成立，就必定可以用 $S[1:i]$ 組成字串 $S$ 。實作上要注意字串是0-base，i+1就相等於字串第i個位置，處理上要特別注意！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;void Z_algo(char *S,int *Z)&#123;    int l = 0,r = 0;    Z[0] = 0;    for(int i=1;S[i];i++)&#123;        Z[i] = max(0,min(Z[i-l],r-i));        while(S[Z[i]]&amp;&amp;S[Z[i]] == S[i+Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    char s[N];cin&gt;&gt;s;    int Z[N],n = strlen(s),ans = n;    Z_algo(s,Z);        rep(i,1,n-1)&#123;        if(n%i==0 &amp;&amp; i+Z[i]==n)&#123;            ans = i;            break;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]ZJ d518: 文字抄寫 II","url":"/string2-5/","content":"ZJ d518: 文字抄寫 II\n題目連結\n\n題目敘述若這個字串之前已經出現過，則輸出的出現號碼，若沒有則輸出它將被編寫的號碼.\n\n裸題Trie，不過要注意每一次要重置，將所有的實體Delete掉。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 110#define Orz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;    Trie* c[26];    int ind;    Trie(): ind(0)&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void clear(Trie *cur)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(cur-&gt;c[i])&#123;            clear(cur-&gt;c[i]);            delete[] cur-&gt;c[i];            cur-&gt;c[i] = NULL;        &#125;    &#125;&#125;void insert(char *s,int num)&#123;    Trie *ptr = root;           //從根節點尋找    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //如果樹上無此字元則new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //繼續造訪Trie        s += 1;                 //字串下一個字元    &#125;    ptr-&gt;ind = num;&#125;int find(char *s)&#123;              //查找字串s    Trie *ptr = root;           //根節點尋找    while(*s)&#123;                  //無此字串，回傳次數0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //字串下一個字元    &#125;    return ptr-&gt;ind;&#125;signed main()&#123;    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;        int ans,cur_id = 1;        rep(i,1,n)&#123;            char s[N];scanf(&quot;%s&quot;,s);            ans = find(s);            if(ans == 0)&#123;                printf(&quot;New! %d\\n&quot;,cur_id);                insert(s,cur_id);                cur_id += 1;            &#125;            else&#123;                printf(&quot;Old! %d\\n&quot;,ans);            &#125;        &#125;        clear(root);    &#125;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]TIOJ 1306 字串中的字串","url":"/string2-6/","content":"TIOJ 1306 字串中的字串\n題目連結Submission\n\n題目敘述裸字串匹配。對於每個詢問輸出 $S$ 在 $T$ 中出現過幾次。\n\n裸KMP字串匹配，統計出現次數。可以嘗試不要看資料自己寫一次，會更了解KMP算法！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n,F[N];;char T[N],S[N];int KMP_match(char *S,char *T,int *F)&#123;    int p = -1,ans = 0;    for(int i=0;T[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];        if(S[p+1] == T[i])            p += 1;        if(!S[p+1])&#123;            ans += 1;            p = F[p];        &#125;    &#125;    return ans;&#125;void KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;    for(int i=1;S[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];        if(S[p+1] == S[i])            p += 1;        F[i] = p;    &#125;&#125;void solve()&#123;    while(n--)&#123;        memset(F,0,sizeof(F));        cin&gt;&gt;S;        KMP_build(S,F);        cout&lt;&lt;KMP_match(S,T,F)&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T&gt;&gt;n;        solve();    &#125;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]TIOJ 1321 好多回文 ndromePali","url":"/string2-7/","content":"TIOJ 1321 好多回文 ndromePali\n題目連結Submission\n\n題目敘述給一個長度 ≤ $10^6$ 的字串 A，問有幾種把該字串的某前綴搬到最後面的方法，使得最後的字串為回文。(提示:可以用類似 Z 函數的概念計算出以某字元為中心的最長回文長度。)\n\n這一題搞得我快掛了QQQ。為什麼呢？看看以下照片就知道了：\n\n根據上面的「提示」，要用類似Z函數的概念把以某點為中心的最長回文算出來。一個Naive裸的作法，把用 $O(n)$ 枚舉每一個點為分割點，把分割點前面的子字串接到後面，用 $O(n)$ 的時間看是否為一回文字串。如此一來時間複雜度為 $O(n^2)$ ，對這一題來說顯然是不可行的，因為字串長度達到 $10^6$！\n當我們用Manacher’s Algorithm $O(n)$ 的時間每一個字元的最大回文之後，就可以枚舉每一個可以作為分割點的地方，檢查回文的狀況。討論分割點在前半部分的情況下，也就是把短的（長度小於一半）前綴搬到後面的狀況。當分割的索引值為 $i$ ，必須保證 $s[0:i]$ 跟 $s[i:2i]$ 對稱，移到字串尾巴才能成為回文。除此之外，也必須滿足 $Z[mid+i] = mid-i$ 的情況，以就是剩下不是分割點兩側的字串必須是回文，把前綴接到後面之後才能對稱！\n實作上很多細節，我DEBUG超久最後才想到不能枚舉所有字元，會出事（就像上面的三色WA），只要枚舉以 $’.’$ 為分割點的情況（分割在字元上就不行），還有很多細節，WA很多次才會知道XD\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N];bool ans[2*N];char S[2*N],T[N];//T原字串、S插入點字串void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;T;    Longest();        for(int i=0;i&lt;m;i++)Z[i]--;    memset(ans,0,sizeof(ans));        int mid = (m-1)/2,i;        if(Z[mid] == mid)ans[0] = 1;    for(i=2;i&lt;mid;i+=2)&#123;        if(Z[i] == i &amp;&amp; Z[mid+i] == mid-i)&#123;            ans[(i/2)] = 1;        &#125;    &#125;    for(;i&lt;m;i+=2)&#123;        if(Z[i] == m-i-1 &amp;&amp; Z[i-mid] == i-mid)&#123;            ans[(i/2)] = 1;        &#125;    &#125;        int sum = 0;    for(int i=0;i&lt;n;i++)if(ans[i])sum++;    if(sum == 0)cout&lt;&lt;&quot;none&quot;&lt;&lt;endl;    else&#123;        cout&lt;&lt;sum&lt;&lt;&quot;:&quot;;        for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;&quot; &quot;&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]ZJ d978: 最长回文字串","url":"/string2-8/","content":"ZJ d978: 最长回文字串\n題目連結\n\n題目敘述題目即題意，給你一個字串，求出最長的回文字串長度為何？\n\n一題LPS的裸題，用Manacher’s Algorithm可以將時間複雜度做到 $O(n)$！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N],t;bool ans[2*N];char S[2*N],T[N];//T原字串、S插入點字串void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T;        Longest();        int ans = 0;        for(int i=0;i&lt;m;i++)&#123;            int z = (Z[i]-1);            ans = max(ans,z);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"[題解]TIOJ 1725 Massacre at Camp Happy","url":"/string2-9/","content":"TIOJ 1725 Massacre at Camp Happy\n題目連結Submission\n\n題目敘述：定義字串 A 和 B「k-幾乎相同」代表把字串 A 的前 k 字元搬到最後面時，與 B 恰有一個字元相異。給你兩個長度 ≤ $10^6$ 的字串 A 和 B，求所有使 A 和 B「k-幾乎相同」成立的 k 值。\n\n這一題好特別，一樣要用 $O(n)$ 的時間求出答案，對於每一個操作將前k個字元搬到後面，只能用 $O(1)$ 算出來到底符不符合一字元相異的條件。以兩個相等長度的字串 $A,B$ 為例，長度為 $l$，假設 $A=aabba,B = aacba$，兩者相差一個字元的情況下，必定會滿足$l = LCP(A,B)+LCP(rev(A),rev(B))+1$，其中rev函數表示reverse。\n我們要做的就是在 $O(1)$ 的時間內求出LCP，因為題目的字串 $A$ 要求不同的起始位置，因此我們假設一個非常特別的字串 $B@AA$ ，其中@為任意沒出現過的字元。只要計算這一個字串的Z函數，就表示了 $A$ 和 $B$ 的最長共同前綴，需要兩個A的原因是因為模擬不同的k-位移下情形。\n\n\n            實作小細節程式碼的第42行可以試著推推看逆序之後的尾巴的索引值為何。我是利用列出幾個數字之後推出來的，不過應該可以寫成比較嚴謹的數學證明！Z1[n+1+i]+Z2[2*n-i+1]+1 == n\n          \n時間複雜度$O(n)$ 建立z函數，$O(n)$ 枚舉每一個起始點，總時間為 $O(n)$。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z1[3*N],Z2[3*N];char A[3*N],B[3*N];void Z_algo(int *z,char *S)&#123;    int l = 0,r = 0;    z[0] = 0;    for(int i=1;i&lt;m;i++)&#123;        z[i] = max(min(z[i-l],r-i),0);        while(S[i+z[i]] &amp;&amp; S[z[i]] == S[i+z[i]])&#123;            l = i;r = i+z[i];            z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;    m = 3*n+1;    B[n] = &#x27;@&#x27;;    //正常序列求Z value    rep(i,n+1,2*n)B[i] = A[i-n-1];    rep(i,2*n+1,3*n)B[i] = A[i-2*n-1];    Z_algo(Z1,B);    //逆序求Z value    reverse(B,B+n);reverse(B+n+1,B+m);    Z_algo(Z2,B);        vector&lt;int&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        if(Z1[n+1+i]+Z2[2*n-i+1]+1 == n)vec.push_back(i);    &#125;    if(vec.size())&#123;        cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl;        for(auto i:vec)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;    &#125;//[0,n-1][n,n][n+1,2n][2n+1,3n]\n","categories":["字串題解"],"tags":["題解","字串"]},{"title":"字串演算法例題 (String)","url":"/string2/","content":"題目目錄\nNEOJ 266 溫力的故事\nNEOJ 265 欸迪的字串\nNEOJ 267 自動完成系統\nNEOJ 264 欸迪的字串\nZJ d518: 文字抄寫 II\nTIOJ 1306 字串中的字串\nTIOJ 1321 好多回文 ndromePali\nZJ d978: 最长回文字串\nTIOJ 1725 Massacre at Camp Happy\nTIOJ 1497 喝醉的宿主 The drunk host\nTIOJ 1515 Problem E. 似曾相識\n\n\nNEOJ 266 溫力的故事題目連結Submission\n\n題目敘述給你n個字串m筆詢問一個字串，對每一筆詢問輸出詢問在n個字串中出現的次數。\n\n這一題在隨機算法做過，今天用字典樹Trie做一次。在隨機算法中，透過Rolling Hash的公式，對每一個字串生成一個值，利用這個值查詢出現的次數。如果我們用Trie的話，則是建立一棵指標樹，透過走法這一棵字典樹得知詢問字串出現的次數！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;        //利用指標建立一棵樹    Trie* c[26];    //對應a-z每一條邊    int cnt;        //字串出現次數    Trie(): cnt(0)&#123; //初始設定        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void insert(char *s)&#123;    Trie *ptr = root;           //從根節點尋找    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //如果樹上無此字元則new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //繼續造訪Trie        s += 1;                 //字串下一個字元    &#125;    ptr-&gt;cnt += 1;              //字串出現次數(字串對應唯一葉節點)&#125;int find(char *s)&#123;              //查找字串s    Trie *ptr = root;           //根節點尋找    while(*s)&#123;                  //無此字串，回傳次數0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //字串下一個字元    &#125;    return ptr-&gt;cnt;            //回傳字串出現次數&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,n-1)&#123;        char s[105];cin&gt;&gt;s;        insert(s);    &#125;    rep(i,0,m-1)&#123;        char s[105];cin&gt;&gt;s;        cout&lt;&lt;find(s)&lt;&lt;endl;    &#125;&#125;\nNEOJ 265 欸迪的字串題目連結Submission\n\n題目敘述給你字串S和字串T，求出S在T中出現的位置\n\n這一題在隨機演算法也有出現過，當時是用Rolling Hash的方式透過扣掉Hash的方法比對字串是否相同（推一下公式就知道）。現在要用的是KMP演算法，很複雜不好想。\n比較一下隨機跟KMP的時間，下方為KMP，上方則是隨機算法，兩者時間差了將近1倍，雖然兩者都可以在O(|T|)時間內進行匹配，但是建立Rolling Hash的常數是比較大的！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;vector&lt;int&gt; KMP_match(char *S,int *F,char *T)&#123;    vector&lt;int&gt; ans;            //回傳匹配相同地方    int p = -1;                 //紀錄短字串有多少被匹配    for(int i=0;T[i];i++)&#123;      //每一迴圈都讓T[i]被匹配到        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];           //使T[i]一定可以被匹配到        if(S[p+1] == T[i])            p += 1;             //T的第i個與S的p+1可以匹配        if(!S[p+1])&#123;            //S[p]已經匹配完成            ans.push_back(i-p); //回推匹配開頭            p = F[p];           //繼續下一輪匹配        &#125;    &#125;    return ans;&#125;//O(|S|)要配對的字串以及Fail Functionvoid KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;              //初始設定為-1    for(int i=1;S[i];i++)&#123;          //1到接下來字元        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];               //無法繼續配對，尋找更短字串        if(S[p+1] == S[i])          //配對成功(如都沒有一樣的就-1)            p += 1;        F[i] = p;                   //設定F[i]    &#125;&#125;signed main()&#123;    Orz;    char S[N],T[N];     //詢問短字串、長在串    int F[N];           //失敗函數    cin&gt;&gt;S&gt;&gt;T;    KMP_build(S,F);    vector&lt;int&gt; ans = KMP_match(S,F,T);    if(ans.size()&gt;0)&#123;        cout&lt;&lt;ans[0];        rep(i,1,ans.size()-1)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];    &#125;    cout&lt;&lt;endl;&#125;\nNEOJ 267 自動完成系統題目連結Submission\n\n題目敘述點這裡有FB Hacker Cup的原題連結，簡單來說就是想像手機的自動填入系統，每加入一個字串會記錄到資料庫中，當資料庫裡面沒有相同前綴的字串時就輸出前綴長度。\n\n用字典樹Trie插入每一個字串，插入過程中返回從頭到開始new新的節點之間經過的節點樹，代表需要輸入多少個字元才能觸發自動完成系統。這一題是基礎的Trie應用。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n;char S[N];int ch(char a)&#123;    return a-&#x27;a&#x27;;&#125;struct Trie&#123;    Trie* c[26];    Trie()&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie *root = new Trie();int insert(char *S)&#123;    Trie *ptr = root;    int step = 0,f = 1;    while(*S)&#123;        if(f)step++;        if(!ptr-&gt;c[ch(*S)])&#123;            ptr-&gt;c[ch(*S)] = new Trie();            f = 0;        &#125;        ptr = ptr-&gt;c[ch(*S)];        S++;    &#125;    return step;&#125;void clear(Trie *s)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(s-&gt;c[i])&#123;            clear(s-&gt;c[i]);            delete s-&gt;c[i];            s-&gt;c[i] = nullptr;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;t;    int cnt = 0;    while(t--)&#123;        cnt++;        cin&gt;&gt;n;        int step = 0;        rep(i,0,n-1)&#123;            cin&gt;&gt;S;            step +=insert(S);        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;step&lt;&lt;endl;        clear(root);    &#125;&#125;\nNEOJ 264 欸迪的字串題目連結Submission\n\n題目敘述給你字串S，求一個最短字串T的長度，滿足經由複製若干次後接起來會是字串S。\n\n這一題在一開始看到感覺好難，不過在慢慢理解 Z_Algorithm 之後，在講義中發現到這個問題也可以用這個演算法來解決！因為Z函數是滿足從i開始的最長前綴，因此當 $i$ 為 字串長度 $n$ 的因數的時候，只要 $i+Z[i+1]=n$ 成立，就必定可以用 $S[1:i]$ 組成字串 $S$ 。實作上要注意字串是0-base，i+1就相等於字串第i個位置，處理上要特別注意！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;void Z_algo(char *S,int *Z)&#123;    int l = 0,r = 0;    Z[0] = 0;    for(int i=1;S[i];i++)&#123;        Z[i] = max(0,min(Z[i-l],r-i));        while(S[Z[i]]&amp;&amp;S[Z[i]] == S[i+Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    char s[N];cin&gt;&gt;s;    int Z[N],n = strlen(s),ans = n;    Z_algo(s,Z);        rep(i,1,n-1)&#123;        if(n%i==0 &amp;&amp; i+Z[i]==n)&#123;            ans = i;            break;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nZJ d518: 文字抄寫 II題目連結\n\n題目敘述若這個字串之前已經出現過，則輸出的出現號碼，若沒有則輸出它將被編寫的號碼.\n\n裸題Trie，不過要注意每一次要重置，將所有的實體Delete掉。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 110#define Orz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;    Trie* c[26];    int ind;    Trie(): ind(0)&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void clear(Trie *cur)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(cur-&gt;c[i])&#123;            clear(cur-&gt;c[i]);            delete[] cur-&gt;c[i];            cur-&gt;c[i] = NULL;        &#125;    &#125;&#125;void insert(char *s,int num)&#123;    Trie *ptr = root;           //從根節點尋找    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //如果樹上無此字元則new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //繼續造訪Trie        s += 1;                 //字串下一個字元    &#125;    ptr-&gt;ind = num;&#125;int find(char *s)&#123;              //查找字串s    Trie *ptr = root;           //根節點尋找    while(*s)&#123;                  //無此字串，回傳次數0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //字串下一個字元    &#125;    return ptr-&gt;ind;&#125;signed main()&#123;    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;        int ans,cur_id = 1;        rep(i,1,n)&#123;            char s[N];scanf(&quot;%s&quot;,s);            ans = find(s);            if(ans == 0)&#123;                printf(&quot;New! %d\\n&quot;,cur_id);                insert(s,cur_id);                cur_id += 1;            &#125;            else&#123;                printf(&quot;Old! %d\\n&quot;,ans);            &#125;        &#125;        clear(root);    &#125;&#125;\nTIOJ 1306 字串中的字串題目連結Submission\n\n題目敘述裸字串匹配。對於每個詢問輸出 $S$ 在 $T$ 中出現過幾次。\n\n裸KMP字串匹配，統計出現次數。可以嘗試不要看資料自己寫一次，會更了解KMP算法！\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n,F[N];;char T[N],S[N];int KMP_match(char *S,char *T,int *F)&#123;    int p = -1,ans = 0;    for(int i=0;T[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];        if(S[p+1] == T[i])            p += 1;        if(!S[p+1])&#123;            ans += 1;            p = F[p];        &#125;    &#125;    return ans;&#125;void KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;    for(int i=1;S[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];        if(S[p+1] == S[i])            p += 1;        F[i] = p;    &#125;&#125;void solve()&#123;    while(n--)&#123;        memset(F,0,sizeof(F));        cin&gt;&gt;S;        KMP_build(S,F);        cout&lt;&lt;KMP_match(S,T,F)&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T&gt;&gt;n;        solve();    &#125;&#125;\nTIOJ 1321 好多回文 ndromePali題目連結Submission\n\n題目敘述給一個長度 ≤ $10^6$ 的字串 A，問有幾種把該字串的某前綴搬到最後面的方法，使得最後的字串為回文。(提示:可以用類似 Z 函數的概念計算出以某字元為中心的最長回文長度。)\n\n這一題搞得我快掛了QQQ。為什麼呢？看看以下照片就知道了：\n\n根據上面的「提示」，要用類似Z函數的概念把以某點為中心的最長回文算出來。一個Naive裸的作法，把用 $O(n)$ 枚舉每一個點為分割點，把分割點前面的子字串接到後面，用 $O(n)$ 的時間看是否為一回文字串。如此一來時間複雜度為 $O(n^2)$ ，對這一題來說顯然是不可行的，因為字串長度達到 $10^6$！\n當我們用Manacher’s Algorithm $O(n)$ 的時間每一個字元的最大回文之後，就可以枚舉每一個可以作為分割點的地方，檢查回文的狀況。討論分割點在前半部分的情況下，也就是把短的（長度小於一半）前綴搬到後面的狀況。當分割的索引值為 $i$ ，必須保證 $s[0:i]$ 跟 $s[i:2i]$ 對稱，移到字串尾巴才能成為回文。除此之外，也必須滿足 $Z[mid+i] = mid-i$ 的情況，以就是剩下不是分割點兩側的字串必須是回文，把前綴接到後面之後才能對稱！\n實作上很多細節，我DEBUG超久最後才想到不能枚舉所有字元，會出事（就像上面的三色WA），只要枚舉以 $’.’$ 為分割點的情況（分割在字元上就不行），還有很多細節，WA很多次才會知道XD\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N];bool ans[2*N];char S[2*N],T[N];//T原字串、S插入點字串void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;T;    Longest();        for(int i=0;i&lt;m;i++)Z[i]--;    memset(ans,0,sizeof(ans));        int mid = (m-1)/2,i;        if(Z[mid] == mid)ans[0] = 1;    for(i=2;i&lt;mid;i+=2)&#123;        if(Z[i] == i &amp;&amp; Z[mid+i] == mid-i)&#123;            ans[(i/2)] = 1;        &#125;    &#125;    for(;i&lt;m;i+=2)&#123;        if(Z[i] == m-i-1 &amp;&amp; Z[i-mid] == i-mid)&#123;            ans[(i/2)] = 1;        &#125;    &#125;        int sum = 0;    for(int i=0;i&lt;n;i++)if(ans[i])sum++;    if(sum == 0)cout&lt;&lt;&quot;none&quot;&lt;&lt;endl;    else&#123;        cout&lt;&lt;sum&lt;&lt;&quot;:&quot;;        for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;&quot; &quot;&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\nZJ d978: 最长回文字串題目連結\n\n題目敘述題目即題意，給你一個字串，求出最長的回文字串長度為何？\n\n一題LPS的裸題，用Manacher’s Algorithm可以將時間複雜度做到 $O(n)$！\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N],t;bool ans[2*N];char S[2*N],T[N];//T原字串、S插入點字串void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T;        Longest();        int ans = 0;        for(int i=0;i&lt;m;i++)&#123;            int z = (Z[i]-1);            ans = max(ans,z);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nTIOJ 1725 Massacre at Camp Happy題目連結Submission\n\n題目敘述：定義字串 A 和 B「k-幾乎相同」代表把字串 A 的前 k 字元搬到最後面時，與 B 恰有一個字元相異。給你兩個長度 ≤ $10^6$ 的字串 A 和 B，求所有使 A 和 B「k-幾乎相同」成立的 k 值。\n\n這一題好特別，一樣要用 $O(n)$ 的時間求出答案，對於每一個操作將前k個字元搬到後面，只能用 $O(1)$ 算出來到底符不符合一字元相異的條件。以兩個相等長度的字串 $A,B$ 為例，長度為 $l$，假設 $A=aabba,B = aacba$，兩者相差一個字元的情況下，必定會滿足$l = LCP(A,B)+LCP(rev(A),rev(B))+1$，其中rev函數表示reverse。\n我們要做的就是在 $O(1)$ 的時間內求出LCP，因為題目的字串 $A$ 要求不同的起始位置，因此我們假設一個非常特別的字串 $B@AA$ ，其中@為任意沒出現過的字元。只要計算這一個字串的Z函數，就表示了 $A$ 和 $B$ 的最長共同前綴，需要兩個A的原因是因為模擬不同的k-位移下情形。\n\n\n            實作小細節程式碼的第42行可以試著推推看逆序之後的尾巴的索引值為何。我是利用列出幾個數字之後推出來的，不過應該可以寫成比較嚴謹的數學證明！Z1[n+1+i]+Z2[2*n-i+1]+1 == n\n          \n時間複雜度$O(n)$ 建立z函數，$O(n)$ 枚舉每一個起始點，總時間為 $O(n)$。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z1[3*N],Z2[3*N];char A[3*N],B[3*N];void Z_algo(int *z,char *S)&#123;    int l = 0,r = 0;    z[0] = 0;    for(int i=1;i&lt;m;i++)&#123;        z[i] = max(min(z[i-l],r-i),0);        while(S[i+z[i]] &amp;&amp; S[z[i]] == S[i+z[i]])&#123;            l = i;r = i+z[i];            z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;    m = 3*n+1;    B[n] = &#x27;@&#x27;;    //正常序列求Z value    rep(i,n+1,2*n)B[i] = A[i-n-1];    rep(i,2*n+1,3*n)B[i] = A[i-2*n-1];    Z_algo(Z1,B);    //逆序求Z value    reverse(B,B+n);reverse(B+n+1,B+m);    Z_algo(Z2,B);        vector&lt;int&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        if(Z1[n+1+i]+Z2[2*n-i+1]+1 == n)vec.push_back(i);    &#125;    if(vec.size())&#123;        cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl;        for(auto i:vec)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;    &#125;//[0,n-1][n,n][n+1,2n][2n+1,3n]\nTIOJ 1497 喝醉的宿主 The drunk host題目連結Submission\n\n題目敘述裸後綴數組。\n\n後綴數組我看了好久（大概有4天吧），一直對著它發呆，不知道它的精髓到底在哪裡。。剛好又遇到開學，不能整天快樂寫題XD\n倍增優化對著螢幕發呆的日子終於結束了，直到我看了這一篇（雖然說我前幾天也有看但看不懂，可能是消化的天數不夠多吧），尤其是裡面的一張圖，深刻說明了倍增的精髓。\n後綴數組求法就不多解釋（上面有），放幾個實作上的小細節。\n\n            實作小細節我們要求進行 $O(\\log n)$ 層的倍增，可以使用C++內建的log10()再用ceil去處理，但顯然有點慢，如果套用以下函數，它會回傳數字二進位之後最大的1前面總共有多少個0（前綴0的數量），與32相減（32是long long的關係）就是我們要的log的次數。int lg = __builtin_clz(n)另外一個小小細節，就是在字串的後半部分，如果跟前面一樣倍增一個比較大的數字，有可能會超出範圍，這時候初始值就很重要了！初始設定rk[n] = -1，導致任何只要超出範圍的都會取到這個-1，表示只要後面沒有字串、如果前面都相同但長度比較長的字串比起來，較短的會排在比較前面的位置！\n          \n這個算法是 $O(n\\log^2 n)$，TIOJ這一題可以過，不過到SPOJ就會被卡TLE\n\n$O(n^2 log(n))$ is expected to score about 20-30. (Naive sorting all suffixes)$O(n log^2(n))$ is expected to score about 40. (OK for most programming contest problems)$O(n log n)$ is expected to score about 60-70. (Use counting sort for small alphabet size)$O(n)$ without tweaks is expected to score about 80-90.$O(n)$ with tweaks is expected to score 100. (This is meant for fun only :)\n\n越後面就越毒瘤XD\n\ntest 1 - AC (score=0.000000, sig=0, time=0.009123, mem=5372)test 2 - AC (score=0.000000, sig=0, time=0.006427, mem=5508)test 3 - AC (score=0.000000, sig=0, time=0.014975, mem=5468)test 4 - AC (score=0.000000, sig=0, time=0.031332, mem=5536)test 5 - AC (score=0.000000, sig=0, time=0.026948, mem=5456)test 6 - AC (score=0.000000, sig=0, time=0.023113, mem=5396)test 7 - TLE (score=0.000000, sig=0, time=0.210000, mem=7340)test 8 - TLE (score=0.000000, sig=0, time=0.210000, mem=7152)test 9 - AC (score=0.000000, sig=0, time=0.170094, mem=7284)test 10 - AC (score=0.000000, sig=0, time=0.140098, mem=7340)\n\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//第一位、第二位比較以及後綴編號bool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //回傳第一個1之前0的個數（二進位）    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //現在倍增的大小        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)&#123;            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //設定rk，與前一個相同則設定跟前一個一樣        &#125;        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\nRadix Sort 優化Submission\n比較一下 $O(n\\log^2 n)$ 以及 $O(n\\log n)$ 的時間，兩者花了近兩倍的時間差距。看了一下這一題的TopCoder，竟然可以做到十位數毫秒！如果要繼續優化成線性 $O(n)$ 的複雜度，就會使用到 DC3 的演算法，雖然好像很複雜不實用QQ\n\n\n\n使用 $O(n\\log^2n)$ 的算法會TLE第八、九筆測資，不過使用基數排序就可以AC了！\n\ntest 1 - AC (score=0.000000, sig=0, time=0.006565, mem=6048)test 2 - AC (score=0.000000, sig=0, time=0.006594, mem=6300)test 3 - AC (score=0.000000, sig=0, time=0.012431, mem=7860)test 4 - AC (score=0.000000, sig=0, time=0.012267, mem=7208)test 5 - AC (score=0.000000, sig=0, time=0.011158, mem=6804)test 6 - AC (score=0.000000, sig=0, time=0.012057, mem=7892)test 7 - AC (score=0.000000, sig=0, time=0.140876, mem=17720)test 8 - AC (score=0.000000, sig=0, time=0.077631, mem=21952)test 9 - AC (score=0.000000, sig=0, time=0.074905, mem=21340)test 10 - AC (score=0.000000, sig=0, time=0.076732, mem=30160)\n\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//第一位、第二位比較以及後綴編號vector&lt;pt&gt; temp,box[N];void init()&#123;    temp.clear();    rep(i,0,n-1)box[i].clear();&#125;bool cmp(pt a,pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void raddix_sort(vector&lt;pt&gt; &amp;cur)&#123;    init();    rep(i,0,n-1)&#123;        if(cur[i].y == -1)temp.push_back(cur[i]);        else box[cur[i].y].push_back(cur[i]);    &#125;    rep(i,0,n-1)        for(auto j : box[i])temp.push_back(j);    rep(i,0,n-1)box[i].clear();    rep(i,0,n-1)        box[temp[i].x].push_back(temp[i]);    cur.clear();    rep(i,0,n-1)        for(auto j : box[i])cur.push_back(j);&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);//回傳第一個1之前0的個數（二進位）    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1) cur[i] = &#123;S[i],0,i&#125;;    sort(all(cur),cmp);    rk[cur[0].id] = 0;    rep(i,1,n-1)        rk[cur[i].id] = (cur[i]==cur[i-1])?rk[cur[i-1].id]:i;    rep(i,0,n-1)cur[i] = &#123;rk[i],0,i&#125;;    rep(p,0,lg)&#123;                //進行O(lgn)次        int k = 1 &lt;&lt; p;         //現在倍增的大小        raddix_sort(cur);        rk[cur[0].id] = 0;        rep(i,1,n-1)            //設定rk，與前一個相同則設定跟前一個一樣            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);        rep(i,0,n-1)            //倍增pair的second            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;    &#125;    raddix_sort(cur);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\nTIOJ 1515 Problem E. 似曾相識題目連結Submission\n\n題目敘述裸後綴數組 LCP。\n\n這題我想好久，一直想不通轉移的條件以及k-1的原因，不過最後還是想通了！這一題只要把 $lcp$ 求出來之後，找最大值就是題目要求的答案。\n程式碼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 200005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//第一位、第二位比較以及後綴編號bool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //回傳第一個1之前0的個數（二進位）    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //現在倍增的大小        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //設定rk，與前一個相同則設定跟前一個一樣        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;vector&lt;int&gt; LCP(string s)&#123;    vector&lt;int&gt; rk(n,0),lcp(n,0);    rep(i,0,n-1)rk[sa[i]] = i;      //利用sa反函數得到rk    int k = 0;    rep(i,0,n-1)&#123;        if(k)k--;        if(rk[i] == n-1)continue;   //rk[n-1]未定義        int j = sa[rk[i]+1];        //下一名後綴從何開始        while(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;        lcp[rk[i]] = k;    &#125;    return lcp;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;cin.ignore();    string S;getline(cin,S);    suffix_array(S);    vector&lt;int&gt; lcp = LCP(S);        int ans = 0;    rep(i,0,n-1)ans = max(lcp[i],ans);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n心得字串演算法跟最短路徑、計算幾何比起來，數學推導成分就多了很多，有許多的遞迴概念，例如失敗函數以及z函數的概念，也有很多是要理解在不同條件下做什麼事，以及其他優化處理。最初的是字典樹Trie，就是一些資料結構的運用；接下來的KMP、Z Algorithm以及LPS就很吃觀念，追蹤整個程式的過程。最後是後綴數組，在這邊卡了超久，遲遲無法理解倍增的概念、以及LCP的作法。可能這就是頓悟吧，每天看了同篇解說很久之後，總有一天會突然頓悟，想到演算法的精髓！\n","categories":["C++進階主題","字串演算法"],"tags":["演算法","字串"]},{"title":"數獨問題（Sudoku）：以C++實作","url":"/sudoku/","content":"資訊之芽的上課內容，用了幾節下課加回家的時間把程式實作出來用紙跟筆解數獨的過程就是把所有可能剔除明顯不可能的之後下去試，如果遇到問題就換下一種方式用程式模擬也是一樣的概念，先把明顯不可能的情況剔除，接下來就一一透過DFS搜尋下去，如果碰壁就回朔回來NEOJ、TIOJ（他的範測給得不是很好閱讀XD\n架構先想出以下的實作步驟，就可以透過程式碼實現\n\n讀測資並處理\n從左到右、由上而下，找出下一個要填入數字的位置\n對每一個點要知道有哪些數字可以被放入（把明顯不行的剔除）\n從左上角的空格開始DFS\n\n大概就是這一些實作步驟，如果用物件導向class 把所有東西包起來，看起來比較厲害DFS 剪枝！\n整個大致架構：\nclass Sudoku&#123;private:    int maze[9][9];    bool flag = false;    public:    void print(string s);    void scan_maze();    vector&lt;int&gt; select(int, int);    int next_empty(int, int);    void solving();    void dfs(int row, int col );&#125;;\n這可以讓main函式顯得更簡單：\nint main()&#123;    Sudoku sodoku1;//宣告物件    sodoku1.scan_maze();//讀入測資    sodoku1.print(&quot;begin&quot;);//印出目前數獨（未解）    sodoku1.solving();//開始解&#125;\n輸入與輸出設計一個印出數獨的函式，讓輸出方便閱讀一點（一行81個字元有夠醜。。。\nvoid Sudoku::print(string s)&#123;    cout&lt;&lt;endl&lt;&lt;&quot;=====&quot;&lt;&lt;s&lt;&lt;&quot;======&quot;&lt;&lt;endl;    for (int i=0; i&lt;9;i++)&#123;        cout&lt;&lt;&quot;|&quot;;        for (int j=0;j&lt;9;j++)&#123;            cout&lt;&lt;maze[i][j];            if(j%3==2)cout&lt;&lt;&quot;|&quot;;        &#125;        cout&lt;&lt;endl;        if(i%3==2)cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;    &#125;&#125;\n接下來是讀入測資，0代表空格\nvoid Sudoku::scan_maze()&#123;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 0;            else maze[i][j] = temp -&#x27;0&#x27;;        &#125;    &#125;&#125;\n有了好的輸出可以讓眼睛比較輕鬆一點Q\n檢查哪些數字可以試試這一個函式主要是實現上面的第三點，把明顯不行（在同一行、列、方格）出現過的數字剔除\nvector&lt;int&gt; Sudoku::select(int r, int c)&#123;    bool box[9]=&#123;0&#125;;//把出現過的數字紀錄下來        for(int i=0;i&lt;9;i++)&#123;        if(maze[i][c]&gt;0)box[maze[i][c]-1] = 1;//同一列        if(maze[r][i]&gt;0)box[maze[r][i]-1] = 1;//同一行    &#125;    int row_start = 3*(r/3),col_start = 3*(c/3);//方格起始位置    for(int i=0;i&lt;3;i++)&#123;//同一方格        for(int j=0;j&lt;3;j++)&#123;            if(maze[row_start+i][col_start+j]&gt;0)                box[maze[row_start+i][col_start+j]-1] = 1;        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i=0;i&lt;9;i++)        if(!box[i])ans.push_back(i+1);    return ans;//把可以試試看得數字push進vector後回傳&#125;\n在遞迴的時候很需要知道下一個要填空的位置在哪裏，又題目要求如果有多組解要輸出字典序最小的解，所以要從左而右再由上而下開始找\nint Sudoku::next_empty(int row, int col)&#123;    int ind = col;    for(int i=row;i&lt;9;i++)&#123;        while(ind&lt;9)&#123;            if(maze[i][ind]==0)&#123;//找到0就停止                int pos = i*9+ind;                return pos;            &#125;            ind++;        &#125;        ind = 0;    &#125;    return -1;//找不檔任何空格，已經填滿&#125;\n開始遞迴DFS!跟八皇后問題很像，都只不過八皇后問題只有放跟不放的問題，而數獨是要決定放什麼進去首先，找到第一個空格之後DFS，在DFS結束後記得要確認數獨結果有沒有符合數獨原本的定義(要不然只會對第一個子題QQ)\n            Q: 明明空格是一個一個填上去，為啥還要再檢查一次？A: 經過一小時的debug 之後發現，他給的測資不一定合法呀！可能測資只有第一行第一格一空格，很高興填上去然後說 YA!解完了，但其實在第九行第九格出現了重複數字?!根本不會檢查到啊，但對第一行第一格一空格來說，一切都符合規則、很美好\n          \nvoid Sudoku::solving()&#123;    int first_empty = next_empty(0, 0),nr,nc;    nr = first_empty/9; nc = first_empty%9;//找到出發點    dfs(nr, nc);//dfs下去    bool f = false;    for(int i=0;i&lt;9;i++)&#123;//81個數字再check一次        for(int j=0;j&lt;9;j++)&#123;            vector&lt;int&gt; v = select(i,j);            if(v.size()&gt;0)f = true;//DFS完正常大小要是0        &#125;    &#125;    if(!flag || f)cout&lt;&lt;&quot;No solution.&quot;&lt;&lt;endl;//無解    else print(&quot;solved&quot;);//印出解    flag = false;&#125;\n對每一種可能進行遞迴：\nvoid Sudoku::dfs(int row, int col )&#123;    int pos = next_empty(row, col),nr,nc;    if(pos == -1)&#123;        flag = true;//有一組解了        return;    &#125;    vector&lt;int&gt; candidate = select(row, col);    int len = candidate.size();        for(int i=0;i&lt;len;i++)&#123;        maze[row][col] = candidate[i];        pos = next_empty(row, col);        nr = pos/9; nc = pos%9;        dfs(nr, nc);        if(flag)return;//如果要輸出很多組解的話可以刪掉這行    &#125;    maze[row][col] = 0;&#125;\n\n這份程式碼只是為了上傳oj，所以只需要一種情況就好完整程式碼在這不過，也可以用程式把每一種方法都列出來，數量可以多到不可想像！(我用程式跑了一下，結果直接它直接不理我，上網查才發現 $5\\times 10^{27}$之多，天荒地老也算不完！）\n這是測試用的數獨：\n這是用線上解數獨的軟題跑出來的結果：這是程式實測跑出來的結果，都吻合：\n相關延伸：八皇后問題題目連結這一份程式碼是leetcode八皇后問題的解。像下面這一張圖就是一組合法的解，透過遞迴可以找出每一組解。\n\n網路上的資料指出這是一個$NP-Complete$的問題，表示並沒有多項式時間的解法。透過2個簡單的函數（是否可行、遞迴函數）即可實作出來。以下表格給出n為1到11的合法解個數：\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n1\n0\n0\n2\n10\n4\n40\n92\n352\n724\n2680\n\n\n\n\n可以利用這個解直接丟原本的題目，就可以贏過78.93%的Submission（還是乖乖用遞迴寫啦） XD\n以下是用遞迴寫的程式碼：\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; temp;    int ans = 0;    void turn_zero(int n)&#123;        vector&lt;int&gt; vec(n,0);        for(int i=0;i&lt;n;i++)&#123;            temp.push_back(vec);        &#125;    &#125;        bool isSafe(int x,int y,int n)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int k=0;k&lt;n;k++)&#123;                if(x==i &amp;&amp; y==k)continue;                if(temp[i][k])                    if(abs(i-x)==abs(k-y)||y==k)                        return false;            &#125;        &#125;        return true;    &#125;        void Queen_Problem(int n)&#123;        for(int i=0;i&lt;n;i++)&#123;            temp[0][i] = 1;            DFS(1,n);            temp[0][i] = 0;         &#125;    &#125;    void DFS(int row,int n)&#123;        if(row==n)&#123;            ans++;            return;        &#125;        for(int i=0;i&lt;n;i++)&#123;            if(isSafe(row,i,n))&#123;                temp[row][i] = 1;                DFS(row+1,n);                temp[row][i] = 0;            &#125;        &#125;    &#125;    int totalNQueens(int n) &#123;        turn_zero(n);        Queen_Problem(n);        return ans;    &#125;&#125;;\n","categories":["C++基礎主題","枚舉"],"tags":["數學","數獨","DFS"]},{"title":"歐拉函數 (Euler's φ Function)","url":"/totient/","content":"多元選修課提到歐拉函數 $\\phi$，想說蠻有趣的可以跟程式結合一下，看會發生什麼有趣的事情！\n定義與公式對於一個正整數 $n$，歐拉函數 $\\phi(n)$ 表示閉區間 $[1,n]$ 中的正整數與 $n$ 互質的個數。定義序列 $p$ 為所有正整數 $n$ 質因數分解之後的數字。在不失一般性的假設序列 $p$ 的長度為 $r$，以質因數分解表示 $n$ 即為 $n = p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_r^{k_r}$，則歐拉函數滿足以下關係式：\n\\begin{split}\\phi(n) &= n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r})\n\\\\&=n\\prod_{p|n}(1-\\frac{1}{p})\n\\end{split}\n特別定義 $\\phi(1) = 1$\n來看看實際的例子，以20為例。以質因數分解來看，$20 = 2^2\\times 5$，因此序列 $p = {2,5}$，則歐拉函數 $\\phi(20) = 20\\times (1-\\frac{1}{2})(1-\\frac{1}{5}) = 8$，稍微驗證一下，從1到20的正整數中，與20互質的有 $1,3,7,9,11,13,17,19$ 一共8個數字。\n推導與證明證明1證明一個公式，可以先多加上一些限制，從簡單推導到較複雜的情況。\n\n$n$ 是質數這種情況比較好處理，因為所有小於等於 $n$ 的正整數都會和 $n$ 互質，因此對於 $n$ 是質數的情況下：\n\\phi(n) = n-1\n$n$ 是合數首先看簡化的情況。假設 $n = p^a$，其中 $p$ 為質數，$a$ 為一大於等於2的正整數。因為 $p$ 是質數，所有不和 $p$ 互質的數字大概會是以下這些：$p,2p,3p,…,(p^{a-1})p$，一共有 $p^{a-1}$ 個數字。我們只要把所有的數字扣掉這些即為歐拉函數 $\\phi$ 的函數值：\n\\phi(p^a) = p^a - p^{a-1} = p^a(1-\\frac{1}{p})\n\n由這個式子推廣到歐拉函數原本的公式。我們讓 $n = p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_r^{k_r}$，因為歐拉函數為一積性函數，滿足 $\\phi(nm) = \\phi(n)\\phi(m)$，其證明如下：\n觀察一個有 $m$ 列 $n$ 行的矩陣，一共有 $mn$ 個數字，從 $1$ 到 $mn$ 。如以下矩陣：\n\\begin{matrix}\n1 & 2 & \\cdots & n\n\\\\n+1 & n+2 & \\cdots & 2n\n\\\\\\vdots&\\vdots&\\ddots&\\vdots\n\\\\(m-1)n+1 &  & \\cdots & mn\n\\end{matrix}\\quad因為每一列都是加上不定數量的 $n$，我們從第一列挑出 $\\phi(n)$ 個與 $n$ 互質的數，其他每一列也都是如此，把他們設為 $t1,t_2,…,t{\\phi(n)}$：\n\\begin{matrix}\nt_1 & t_2 & \\cdots & t_{\\phi(n)}\n\\\\n+t_1 & n+t_2 & \\cdots & n+t_{\\phi(n)}\n\\\\\\vdots&\\vdots&\\ddots&\\vdots\n\\\\(m-1)n+t_1 &  & \\cdots & (m-1)n+t_{\\phi(n)}\n\\end{matrix}\\quad觀察一下每一直行，由於 $n$ 和 $m$ 互質，同一直行中的每一個數字和 $m$ 都會不同餘。在不同餘的情況下，每一直行都會有 $\\phi(m)$ 個與 $m$ 互質的數字。因此，從上面的矩陣可以發現總共有 $\\phi(n)\\phi(m)$ 個與 $nm$ 互質的數字，因此有$\\phi(nm)=\\phi(n)\\phi(m)$。\n有了上述性質之後，我們就可以直接推導公式：\n\\begin{split}\\phi(n) &=\\phi(p_1^{k_1})\\cdot\\phi(p_2^{k_2})\\cdots\\phi(p_r^{k_r})\n\\\\&=p_1^{k_1}(1-\\frac{1}{p_1})\\cdot p_2^{k_2}(1-\\frac{1}{p_2})\\cdots p_r^{k_r}(1-\\frac{1}{p_r})\n\\\\&=p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_r^{k_r}\\cdot(1-\\frac{1}{p_1})\\cdot(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r})\n\\\\&= n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r})\\end{split}以上就是歐拉函數公式的推導過程！\n證明2使用到的是排容原理。這個證明就沒有像上面那麽繁雜，不過有點難理解就是了。首先我們討論 $n$ 的質因數分解由三個質數組成，寫成：$n = p_1^{k_1}\\cdot p_2^{k_2}\\cdot p_3^{k_3}$，假設在小於等於 $n$ 中能被 $p_1$,$p_2$,$p_3$ 給整除的數字集合為 $A_1,A_2,A_3$，則我們要求的就是：\n(A_1' \\cap A_2' \\cap A_3') = (A_1 \\cup A_2 \\cup A_3)'我們要求的就是聯集的補集的部分：\n這是公式展開的情況：\n\\begin{split}\\phi(n) &= n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})\n\\\\&=n(1-\\frac{1}{p_1}-\\frac{1}{p_2}-\\frac{1}{p_3}+\\frac{1}{p_1p_2}+\\frac{1}{p_1p_3}+\\frac{1}{p_2p_3}-\\frac{1}{p_1p_2p_3})\n\\\\&=(n-\\frac{n}{p_1}-\\frac{n}{p_2}-\\frac{n}{p_3}+\\frac{n}{p_1p_2}+\\frac{n}{p_1p_3}+\\frac{n}{p_2p_3}-\\frac{n}{p_1p_2p_3})\\end{split}這展開之後跟集合寫成的樣子是一樣的，根據排容原理也間接證明公式的正確性！\n程式實現基本概念就是從2開始往後找所有的質因數，因為個數不重要，只要每一次找到之後更新答案即可。值得注意的是，最後必須對剩下的 $n$ 在做一次，其原因不難理解，當我有兩個質因數剩下還沒有被 i 走過的時候，因為兩個互質，因此必定有一個數會在迴圈內被走到，剩下那一個留下來的就會在外面被更新答案。\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans;int phi()&#123;    ans = n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n % i == 0)&#123;            ans = ans - ans/i;            while(n % i==0)n /= i;        &#125;    &#125;    if(n &gt; 1)ans = ans - ans/n;    return ans;&#125;int main()&#123;    cin&gt;&gt;n;    cout&lt;&lt;phi()&lt;&lt;endl;&#125;\n這是用程式跑出來的1到10000的歐拉函數，可以參考看看！\n好難的圖形這張圖是歐拉函數的函數圖形，x軸是 $n$，y軸則是 $\\phi(n)$。利用python的matplotlib模組繪製出來的！\n以下為待解決問題：\n\n$(n,\\phi(n))$ 的圖形中，斜率為 $1,\\frac{1}{2},\\frac{2}{3},\\frac{4}{5},\\frac{1}{3}$，其原因？\n這些斜率是否可以求出數字落在每一條線上的機率？\n函數總和的圖形，其方程式是如何推導的？\n函數總和公式的誤差圖形呈現類似常態分佈，求其原因。\n倒數總和的公式如何推導？\n最後一個極限下界公式的推導，跟歐拉-馬斯刻若尼常數關係為何？\n\n一般的 $n$ 與 $\\phi(n)$ 關係圖我覺得這東西超酷，有一條斜率為1的很明顯的直線，他代表的是 $\\phi(n) = n-1$，這種情況就是當 $n$ 屬於質數的時候會發生。\n$n$ 的範圍是1到150\n$n$ 的範圍是1到1500\n$n$ 的範圍是1到10000\n斜率 $\\frac{1}{2}$ 的情況這是嘗試解決問題的區域。\n首先，我把斜率為 $0.5\\pm0.01$ 的點全部描出來，大概就是這樣：\n小範圍跑出來，在100內一共有6個符合條件的數字，分別是：\n\n248163264\n\n哇！一切豁然開朗。當 $n$ 為 2 的冪次時，就只有一個 $2$ 是質因數，因此 $\\phi(n) = n(1-\\frac{1}{2}) = \\frac{n}{2}$。但這樣的數字只會越來越少，但點卻沒有變得越來越稀疏，於是我們必須加大數字範圍觀察，數字的列表在這，丟到線上質因數分解器，會發現有很多數字都是有2個因數，其中一個為2，另外一個為一個較大的質數，數字越大對影響力就越小，因此他們會在斜率為 $\\frac{1}{2}$ 的線上。\n\n像1964就會是$\\frac{1}{2}\\times \\frac{490}{491}$，後面的影響很小，所有大致上接近 $\\frac{1}{2}$。\n斜率 $\\frac{1}{3}$ 的情況紅線標出來的是斜率為 $\\frac{1}{3}$ 的線條。\n情況大概就是這幾種，這些質因數算出來大概就是 $\\frac{1}{3}$ 左右。\n斜率 $\\frac{2}{3}$ 的情況\n這些數字很多事3乘上某個大質數。\n斜率 $\\frac{4}{5}$ 的情況\n一樣的情況，大多是5盛放某個大質數\n來比較一下\n我們設定不同的 $n$ ，看在不同值域中個別斜率上面的點的數量，不過因為我設了小數點後兩位當作可接受的誤差範圍，因此會稍微多一點：\n\n\n\n\n斜率/次數\n1000\n10000\n100000\n1000000\n10000000\n\n\n\n\n1\n144\n1205\n10860\n118298\n1186321\n\n\n1/2\n152\n1425\n13531\n141771\n1401372\n\n\n1/3\n78\n858\n8031\n82782\n826322\n\n\n2/3\n67\n721\n6131\n65638\n664881\n\n\n4/5\n32\n387\n3281\n33560\n348334\n\n\n其他\n572\n5404\n58166\n557951\n5572770\n\n\n\n\n\n\n\n\n斜率\n點的占比\n\n\n\n\n1\n11.86%\n\n\n1/2\n14.01%\n\n\n1/3\n8.26%\n\n\n2/3\n6.65%\n\n\n4/5\n3.48%\n\n\n其他\n55.73%\n\n\n\n\n我想要計算一下他們變化的狀況：\n\n觀察圖形，好像有那麼一點會趨近於一個常數之類的，不過當數字超過 $10^7$ 之後，不管是用 C++或是 PYTHON 都跑不太出來。\nimport numpy as npimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansx = []y = []x2 = []y2 = []times = [1000000]for j in range(1):    cnt = 0    for i in range(1,1000000+1):        if i%100000 == 0:            print(&quot;Now = &quot;,i/100000)        ans = int(phi(i))        x.append(i)        y.append(ans)        if abs(ans/i-(4/5)) &lt;= 0.01:            x2.append(i)            y2.append(ans)            #print(i)            cnt += 1    print(&quot;Cnt = &quot;,cnt)        #plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.1)#plt.plot(x,y,&#x27;o&#x27;,markersize = 1)#plt.plot(x2,y2,&#x27;o&#x27;,markersize = 1,c = &quot;red&quot;)#plt.show()\nimport numpy as npimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansx = []y = []for i in range(1,1500+1):    ans = int(phi(i))    x.append(i)    y.append(ans)    plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.1)plt.plot(x,y,&#x27;o&#x27;,markersize = 1)plt.show()\n總和的關係圖除此之外，這個東西也很酷，以下是 $f(n)$ 與 $n$ 的關係圖。滿足以下式子：\nf(n) = \\sum^n_{i=1}\\phi(i)\n上網查後發現這一條線可以用一個關係式表達：\nf(n) = \\sum^n_{i=1}\\phi(i) = \\frac{3n^2}{\\pi^2}下圖藍線就是公式的圖，紅色的點則是 $\\phi(n)$：\nimport numpy as npimport math import matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansdef func(x):    s = (math.pi)*(math.pi)    return 3*x*x/s    x = []y = []y2 = []sum = 0for i in range(1,101):    ans = int(phi(i))    sum += ans    x.append(i)    y2.append(func(i))    y.append(sum)plt.plot(x,y,&#x27;o&#x27;,color = &#x27;red&#x27;,markersize = 2)plt.plot(x,y2,color = &#x27;blue&#x27;,markersize = 0.1)plt.show()\n如果計算一下這一條理論線跟實際的誤差繪製出來的圖形：\n\\frac{1}{n}(\\sum^n_{i=1}\\phi(i)-\\frac{3n^2}{\\pi^2})\n很酷喔，當我把每一個誤差的數字當做x軸，y軸則是發生的次數，跑了1000000次之後，他的圖會出來會是像這樣，有點像常態分佈的東西（網路上是說埃爾米特多項式乘上高斯函數之類的東西）：\n\nThe histogram has a distinctive shape, maybe hard to prove. I suspect it’s the Gaussian Unitary Ensemble (a Hermite polynomial times a Gaussian).\n\n\nimport numpy as npimport mathimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansdef func(x):    s = (math.pi)*(math.pi)    return 3*x*x/sx = []y = []box = [0]*2000sum = 0for i in range(1000):    box[i] = 0    for i in range(1,10000000+1):    ans = int(phi(i))    sum += ans    temp = int(((sum-func(i))/i)*2000)    box[temp] += 1    if i % 100000 == 0:        print(&quot;Cur = &quot;,i/100000)    for i in range(1400):    x.append(i/2000)    y.append(box[i])plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.4)plt.plot(x,y,&#x27;o&#x27;,markersize = 2)plt.show()\n倒數加總的圖形下圖則是每一個 $\\phi$ 的倒數繪製出來的圖形：\nf(n) = \\sum^n_{i=1}\\frac{1}{\\phi(i)}\n很酷，但我一樣不知道怎麼解釋\n取一堆怪怪的東西還沒有結束，這一張圖表示的是 $n$ 對上 $\\phi(n)\\frac{\\ln\\ln n}{n}$ 呈現的圖形，據說會滿足以下關係式：\n\\lim_{n\\to\\infty}\\inf\\phi(n)\\frac{\\ln\\ln n}{n} = e^{-\\gamma}指數次方上面是歐拉-馬斯刻若尼常數，畫出來的圖長這樣：\n\n一樣，公式有夠複雜！\nimport numpy as npimport mathimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansx = []y = []for i in range(1,5000+1):    ans = int(phi(i))    x.append(i)    temp = np.log(i)    ans *= np.log(temp)        y.append(ans/i)    plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.05)plt.plot(x,y,&#x27;o&#x27;,markersize = 1)plt.show()\n\n參考連結：\n\n連結1\n連結2\n連結3\n\nP2303 [SDOI2012] Longge 的问题題目敘述Submission\n這是歐拉函數簡單的應用，對於一個輸入 $n$ 要輸出的是 $\\sum_{i=1}^n gcd(i,n)$，也就是每一個數字與 $n$ 的最大公因數總和。簡單的概念就是，$O(n)$ 枚舉所有的因數 $i$ 作為最大公因數，此時只要看與 $\\frac{n}{i}$ 互質的數量，$i\\times\\phi(\\frac{n}{i})$ 就會是以 $i$ 作為最大公因數的總和。\n特別注意到，我們可以在枚舉 $i$ 的時候，也可以順便處理 $\\frac{n}{i}$ 的情況，這樣就可以只枚舉 $\\sqrt{n}$ 次就好了！\n#include &lt;bits/stdc++.h&gt;#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,ans = 0;int phi(int n)&#123;    int ans = n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n % i == 0)&#123;            ans = ans - ans/i;            while(n % i==0)n /= i;        &#125;    &#125;    if(n &gt; 1)ans = ans - ans/n;    return ans;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    int qt = sqrt(n);    for(int i=1;i&lt;=qt;i++)&#123;        if(n % i == 0)&#123;            ans += (n/i) * phi(i);            if(i*i!=n)ans += i * phi(n/i);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["數學筆記"],"tags":["數學","高二上筆記"]}]